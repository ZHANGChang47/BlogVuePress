---
title: 网络编程
date: 2023-02-04 15:47:07
permalink: /pages/1f9618/
categories:
  - Java基础
tags:
  - 
---
# 网络编程

## 1、概述

计算机网络是指将地理位置不同的具有独立功能的多台计算机及外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。

**网络编程的目的：**

无线电台...传播交流信息，数据交换，通信

**想要达到这个效果需要什么：**

1. 如何确定的定位网络上的一台主机 192.168.16.124:端口，定位到这个计算机上的某个资源
2. 找到了这个主机，如何传输数据？

javaweb：网页编程 B/S

网路编程：TCP/IP

## 2、网络通信要素

如何实现网络的通信？

通信双方的地址：

- ip
- 端口号
- 192.168.16.124:5900

**规则：网络通信协议**

OSI七层模型和TCP/IP模型及其对应的网络协议：

![img](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/20190105164025264.png)

小结：

1. 网络编程中有两个主要的问题
   - 如何准确的定位到网络上的一台或者多台主机
   - 找到主机后如何进行通信
2. 网络编程中的要素
   - IP和端口号
   - 网络通信协议：tcp、udp
3. 万物皆对象

## 3、IP地址

ip地址：InetAddress

- 唯一定位一台网络上计算机

- 127.0.0.1：本机localhost

- ip地址分类

  - ipv4/ipv6

    - ipv4：127.0.0.1	4个字节组成	每个字节长度0~255，42亿个，30亿都在北美，亚洲4亿，2011年就用尽了

    - ipv6：128位  8个无符号整数

      ```bash
      2001:0bb2:aaaa:0015:0000:0000:1aaa:1312
      ```

  - 公网（互联网）-私网（局域网）

    - ABCD类地址
    - 192.168.xx.xx，局域网专门给组织内部使用

- 域名：记忆IP问题

  - IP：www.vip.com 万网

```java
package com.chang.intenet;

import java.net.InetAddress;
import java.net.UnknownHostException;

//测试IP
public class testInetAddress {
    public static void main(String[] args) {
        try {
            //查询本机地址
            InetAddress inetAddress1 = InetAddress.getByName("127.0.0.1");
            System.out.println(inetAddress1);   ///127.0.0.1
            InetAddress inetAddress2 = InetAddress.getByName("localhost");
            System.out.println(inetAddress2);   //localhost/127.0.0.1
            InetAddress inetAddress3 = InetAddress.getLocalHost();
            System.out.println(inetAddress3);   //Inspiron7490/10.180.16.114

            //查询网站ip地址
            InetAddress inetAddress4 = InetAddress.getByName("www.baidu.com");
            System.out.println(inetAddress4);   //www.baidu.com/14.215.177.39

            //常用方法
//            System.out.println(inetAddress4.getAddress());              //[B@1b6d3586
//            System.out.println(inetAddress4.getCanonicalHostName());    //14.215.177.39 规范的名字 
            System.out.println(inetAddress4.getHostAddress());          //14.215.177.39 ip
            System.out.println(inetAddress4.getHostName());             //www.baidu.com 域名，或者自己电脑的名字
            
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
```

## 4、端口Port

端口表示计算机上的一个程序的进程；

- 不同的进程有不同的端口号！用来区分软件！

- 被规定有0~65535个

- TCP、UDP：65535*2个，单个协议下，端口号不能冲突

- 端口分类

  - 公有端口0~1023

    - HTTP：80
    - HTTPS：443
    - FTP：21
    - Telent：23

  - 程序注册端口：2014~49151，分配用户或者程序

    - Tomcat：8080
    - MySQL：3306
    - Oracle：1521

  - 动态端口、私有端口：49152~65535

    ```bash
    #查看本机端口
    netstat -ano	#查看所有端口
    
    netstat -ano|findstr "5900"		#查看指定端口
    
    tasklist|findstr "8696"		#查看指定端口的进程
    
    Ctrl+Shift+Esc
    ```

```java
package com.chang.intenet;

import java.net.InetSocketAddress;

public class testInetSocketAddress {
    public static void main(String[] args) {
        InetSocketAddress socketAddress = new InetSocketAddress("127.0.0.1",8080);
        InetSocketAddress socketAddress2 = new InetSocketAddress("localhost",8080);
        System.out.println(socketAddress);      // /127.0.0.1:8080
        System.out.println(socketAddress2);     // localhost/127.0.0.1:8080
        System.out.println(socketAddress.getAddress());     // /127.0.0.1
        System.out.println(socketAddress.getHostName());    // 127.0.0.1
        System.out.println(socketAddress.getPort());        // 8080
    }
}

```

## 5、通信协议

协议：约定，就好比我们现在说的普通话

**网络通信协议**：速率、传输码率、代码结构、传输控制...

**TCP/IP协议簇：是一组协议**：

重要：

- TCP：用户传输协议
- UDP：用户数据报文协议
- IP：网络互联协议

**TCP与UDP对比：**

TCP（eg:打电话）

- 连接、稳定
- 三次握手、四次挥手
- 传输完成，释放连接、效率低

UDP（eg:发短信）

- 不连接，不稳定
- 客户端、服务端：没有明确的界限
- 不管有没有准备好，都可以发给你
- 导弹
- DDOS：洪水攻击

## 6、TCP

### 6.1、聊天

客户端

1. 连接服务器Socket
2. 发送消息

**TcpClientDemo01**

```java
package com.chang.intenet;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;

//客户端
public class TcpClientDemo01 {
    public static void main(String[] args) {
        Socket socket=null;
        OutputStream os=null;
        try {
            //1、要知道服务器的地址、端口号
            InetAddress serverIP = InetAddress.getByName("127.0.0.1");
            int port = 9999;
            //2、创建一个socket连接
            socket = new Socket(serverIP,port);
            //3、发送消息
            os = socket.getOutputStream();
            os.write("你好，欢迎学习java网络编程".getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if(os!=null){
                try {
                    os.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(socket!=null){
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

服务器

1. 建立服务的端口ServerSocket
2. 等待用户的链接accept

**TcpServerDemo01**

```java
package com.chang.intenet;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

//服务端
public class TcpServerDemo01 {
    public static void main(String[] args) {
        ServerSocket serverSocket=null;
        Socket socket=null;
        InputStream is=null;
        ByteArrayOutputStream baos=null;
        try {
            //1、我得有一个地址
            serverSocket = new ServerSocket(9999);
            //2、等待客户端连接过来
            socket = serverSocket.accept();
            //3、读取客户端的消息
            is = socket.getInputStream();
            //管道流
            baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int len;
            while ((len=is.read(buffer))!=-1){
                baos.write(buffer,0,len);
            }
            System.out.println(baos.toString());
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            if(baos!=null){
                try {
                    baos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(is!=null){
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(socket!=null){
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(serverSocket!=null){
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

### 6.2、文件上传

客户端

```java
package com.chang.intenet;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class TcpClientDemo02 {
    public static void main(String[] args) throws IOException {
        //1、创建一个Socket连接
        Socket socket = new Socket(InetAddress.getByName("127.0.0.1"), 9999);
        //2、创建一个输出流
        OutputStream os = socket.getOutputStream();
        //3、读取文件
        FileInputStream fis = new FileInputStream(new File("dog.jpg"));
        //4、写出文件
        byte[] buffer = new byte[1024];
        int len;
        while ((len=fis.read(buffer))!=-1){
            os.write(buffer,0,len);
        }

        //4.5.1、通知服务器，我已经结束了
        socket.shutdownOutput();    //我已经传输完了


        //4.5.2、确定服务器接收完毕后，才能断开连接
        InputStream inputStream = socket.getInputStream();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer2 = new byte[1024];
        int len2;
        while ((len2=inputStream.read(buffer2))!=-1){
            baos.write(buffer2,0,len2);
        }
        System.out.println(baos.toString());

        //5、关闭资源
        baos.close();
        inputStream.close();
        fis.close();
        os.close();
        socket.close();
    }
}
```

服务端

```java
package com.chang.intenet;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

public class TcpServerDemo02 {
    public static void main(String[] args) throws Exception {
        //1、创建服务
        ServerSocket serverSocket = new ServerSocket(9999);
        //2、监听客户端的连接
        Socket socket = serverSocket.accept();//阻塞式监听，会一直等待客户端连接
        //3、获取输入流
        InputStream is = socket.getInputStream();
        //4、文件输出
        FileOutputStream fos = new FileOutputStream(new File("receive.jpg"));
        byte[] buffer = new byte[1024];
        int len;
        while ((len=is.read(buffer))!=-1){
            fos.write(buffer,0,len);
        }

        //4.5、通知客户端我接收完毕了
        OutputStream os = socket.getOutputStream();
        os.write("我接收完毕了，可以断开了".getBytes());

        //5、关闭
        fos.close();
        is.close();
        socket.close();
        serverSocket.close();
    }
}
```

### 6.3、Tomcat

服务器

- 自定义 S
- Tomcat服务器 S

客户端

- 自定义 C
- 浏览器 B

## 7、UDP

不用连接，但是仍然需要知道对方地址

### 7.1、发送消息

```java
package com.chang.intenet;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

//不需要连接服务器
public class UDPClientDemo01 {
    public static void main(String[] args) throws Exception {
        //1、建立一个socket
        DatagramSocket socket = new DatagramSocket();
        //2、建个包
        String msg="你好，服务器";
        //发送给谁
        InetAddress localhost = InetAddress.getByName("localhost");
        int port=9090;
        //数据，数据的长度起始，发送的地址以及端口号
        DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,9090);
        //3、发送包
        socket.send(packet);

        //4、关闭流
        socket.close();
    }
}
```

### 7.2、接收消息

```java
package com.chang.intenet;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class UDPServerDemo01 {
    public static void main(String[] args) throws Exception {
        //开放端口
        DatagramSocket socket = new DatagramSocket(9090);

        //接收数据包
        byte[] buffer = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//接收
        socket.receive(packet);

        System.out.println(packet.getAddress().getHostAddress());
        System.out.println(new String(packet.getData(),0, packet.getLength()));
        //关闭连接
        socket.close();
    }
}
```

### 7.3、接收端持续接收发送端消息

#### 7.3.1、发送端

```java
package com.chang.intenet;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;

public class UDPSenderDemo01 {
    public static void main(String[] args) throws Exception {
        DatagramSocket socket = new DatagramSocket(8888);

        //准备数据，从控制台读取System.in
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        while (true){
            String data = reader.readLine();

            DatagramPacket packet = new DatagramPacket(data.getBytes(),0,data.getBytes().length,new InetSocketAddress("localhost",6666));

            socket.send(packet);

            if(data.equals("bye")){
                break;
            }
        }

        socket.close();
    }
}
```

#### 7.3.2、接收端

```java
package com.chang.intenet;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class UDPReceiveDemo01 {
    public static void main(String[] args) throws Exception {
        DatagramSocket socket = new DatagramSocket(6666);

        while (true){
            //准备接收包裹
            byte[] container = new byte[1024];

            DatagramPacket packet = new DatagramPacket(container,0,container.length);

            socket.receive(packet);//阻塞式接收包裹

            //断开连接 bye
            byte[] data = packet.getData();
            String receiveData = new String(data, 0, packet.getLength());
            System.out.println(receiveData);
            if(receiveData.equals("bye")){
                break;
            }
        }
        socket.close();
    }
}
```

### 7.4、UDP多线程在线咨询

#### 7.4.1、发送端

```java
package com.chang.intenet;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;

public class TalkSend implements Runnable{
    DatagramSocket socket;
    BufferedReader reader;

    public TalkSend(int fromPort, String toIP, int toPort) {
        this.fromPort = fromPort;
        this.toIP = toIP;
        this.toPort = toPort;
        try {
            socket = new DatagramSocket(fromPort);
            //准备数据，从控制台读取System.in
            reader = new BufferedReader(new InputStreamReader(System.in));
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }

    private int fromPort;
    private String toIP;
    private int toPort;

    @Override
    public void run() {
        while (true){
            try{
                String data = reader.readLine();

                DatagramPacket packet = new DatagramPacket(data.getBytes(),0,data.getBytes().length,new InetSocketAddress(this.toIP,this.toPort));

                socket.send(packet);

                if(data.equals("bye")){
                    break;
                }
            }catch (Exception e){
                e.printStackTrace();
            }
        }

        socket.close();
    }
}
```

#### 7.4.2、接收端

```java
package com.chang.intenet;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class TalkReceive implements Runnable {
    DatagramSocket socket;

    private int port;
    private String msgFrom;

    public TalkReceive(int port,String msgFrom){
        this.port=port;
        this.msgFrom=msgFrom;
        try {
            socket = new DatagramSocket(port);
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        while (true){
            try {
                //准备接收包裹
                byte[] container = new byte[1024];
                DatagramPacket packet = new DatagramPacket(container,0,container.length);
                socket.receive(packet);//阻塞式接收包裹

                //断开连接 bye
                byte[] data = packet.getData();
                String receiveData = new String(data, 0, packet.getLength());
                System.out.println(msgFrom+"："+receiveData);
                if(receiveData.equals("bye")){
                    break;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        socket.close();
    }
}
```

#### 7.4.3、学生发送接收消息

```java
package com.chang.intenet;

public class TalkStudent {
    public static void main(String[] args) {
        //开启两个线程
        new Thread(new TalkSend(7777,"localhost",9999)).start();
        new Thread(new TalkReceive(8888,"老师")).start();
    }
}
```

#### 7.4.4、老师发送接收消息

```java
package com.chang.intenet;

public class TalkTeacher {
    public static void main(String[] args) {
        //开启两个线程
        new Thread(new TalkSend(5555,"localhost",8888)).start();
        new Thread(new TalkReceive(9999,"学生")).start();
    }
}
```

## 8、URL下载网络资源

url是统一资源定位符：定位互联网上的某一个资源

DNS域名解析：将www.baidu.com解析成xxx.xxx.xxx.xx

URL组成部分：

```bash
协议://ip地址:端口号/项目名/资源
```

### 8.1、URL常用方法

```java
package com.chang.intenet;

import java.net.MalformedURLException;
import java.net.URL;

public class URLDemo01 {
    public static void main(String[] args) throws MalformedURLException {
        URL url = new URL("http://localhost:8080/helloworld/index.jsp?username=zhangchang&password=123");
        //协议
        System.out.println(url.getProtocol());  //http
        //主机ip
        System.out.println(url.getHost());      //localhost
        //端口
        System.out.println(url.getPort());      //8080
        //文件
        System.out.println(url.getPath());      ///helloworld/index.jsp
        //全路径
        System.out.println(url.getFile());      ///helloworld/index.jsp?username=kuangshen&password=123
        //参数
        System.out.println(url.getQuery());     //username=zhangchang&password=123
    }
}
```

### 8.2、URL下载资源

```java
package com.chang.intenet;

import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;

public class URLDemo02 {
    public static void main(String[] args) throws Exception {
        //1、下载地址
        URL url = new URL("http://localhost:8080/zhangchang/SecurityFile.txt");
        //2、连接到这个url
        HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();
        InputStream inputStream = urlConnection.getInputStream();
        //3、输出文件
        FileOutputStream fos = new FileOutputStream("SecurityFile.txt");
        byte[] buffer = new byte[1024];
        int len;
        while ((len=inputStream.read(buffer))!=-1){
            fos.write(buffer,0,len);    //写出数据
        }
        //4、断开连接
        fos.close();
        inputStream.close();
        urlConnection.disconnect(); //url断开连接
    }
}
```

## 9、网络编程基本概念

### 9.1、什么是计算机网络

把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息， 共享硬件、 软件、 数据信息等资源。

### 9.2、计算机网络的主要功能

资源共享
信息传输与集中处理
均衡负荷与分布处理
综合信息服务(www/综合业务数字网络ISDN)等

### 9.3、网络通信协议

要使计算机连成的网络能够互通信息， 需要对数据**传输速率、 传输代码、 代码结构、 传输控制步骤、 出错控制**等制定一组标准， 这一组共同遵守的通信标准就是网络通信协议， 不同的计算机之间必须使用相同的通讯协议才能进行通信。

网络通信接口:
为了使两个结点之间能进行对话， 必须在它们之间建立通信工具(即接口)， 使彼此之间能进行信息交换。 接口包括两部分：
（1） 硬件装置： 实现结点之间的信息传送
（2） 软件装置： 规定双方进行通信的约定协议  

### 9.4、TCP/IP

TCP/IP： 传输控制协议/因特网互联协议， 又叫网络通讯协议， 这个协议是Internet最基本的协议、 Internet国际互联网络的基础， 简单地说， 就是**由网络层的IP协议和传输层的TCP协议组成**的。

IP地址： 网络中每台计算机的一个标识号， 本地IP： 127.0.0.1 localhost

端口号(PORT)： 端口号的范围： 0~65535之间， 0~1023之间的端口数是用于一些知名的网络服务和应用

| 应用层     |
| ---------- |
| 表示层     |
| 会话层     |
| 传输层     |
| 网络层     |
| 数据链接层 |
| 物理层     |

### 9.5、程序开发结构

网络编程主要是指完成C/S程序的开发， 程序的开发结构有两种：
**C/S（客户端/服务器）**
开发两套程序， 两套程序需要同时维护， 例如： QQ。 CS程序一般比较稳定

**B/S（浏览器/服务器）**
开发一套程序， 客户端使用浏览器进行访问， 例如： 各个论坛。 BS程序一般稳定性较差， 而且安全性较差。

但是， C/S的程序开发在实际的Java应用中毕竟很少了， 而且整个java基本上都是以B/S为主。

C/S程序主要可以完成以下两种程序的开发：
TCP： （Transmission Control Protocol） 传输控制协议， 采用三方握手的方式， 保证准确的连接操作。
UDP： （User Datagram Protocol） 数据报协议， 发送数据报， 例如： 手机短信或者是QQ消息。
TCP、 UDP的数据帧格式简单图例：

| 协议类型 | 源IP | 目标IP | 源端口 | 目标端口 | 帧序号 | 帧数据 |
| -------- | ---- | ------ | ------ | -------- | ------ | ------ |

其中协议类型用于区分TCP、 UDP  

***

## 10、网络编程TCP协议

### 10.1、TCP程序概述

TCP是一个可靠的协议， 面向连接的协议。

实现TCP程序， 需要编写服务器端和客户端， Java API为我们提供了java.net 包， 为实现网络应用程序提供类。

**ServerSocket** ： 此类实现服务器套接字。
**Socket** ： 此类实现客户端套接字（也可以就叫“ 套接字” ）。

**Socket是网络驱动层提供给应用程序编程的接口和一种机制。**  

![image-20211010195940848](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211010195940848.png)

![image-20211010200129869](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211010200129869.png)

![image-20211010200144895](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211010200144895.png)

### 10.2、实现服务器端与客户端程序

**服务器端：**

**public class ServerSocket extends Object**
此类实现服务器套接字。 服务器套接字等待请求通过网络传入。 它基于该请求执行某些操作， 然后可能向请求者返回结果。

**ServerSocket(int port)**
创建绑定到特定端口的服务器套接字。

**void setSoTimeout(int timeout)**
通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。

**InetAddress getInetAddress()**
返回此服务器套接字的本地地址。

**Socket accept()**
侦听并接受到此套接字的连接  

**客户端：**
**public class Socket extends Object**
此类实现客户端套接字（也可以就叫“ 套接字” ） 。 套接字是两台机器间通信的端点。

**Socket(String host, int port)**
创建一个流套接字并将其连接到指定主机上的指定端口号。

**InputStream getInputStream()**
返回此套接字的输入流。

**OutputStream getOutputStream()**
返回此套接字的输出流。

**void setSoTimeout(int timeout)**
启用/禁用带有指定超时值的SO_TIMEOUT， 以毫秒为单位。  

## 11、TCP实现ECHO程序

Echo， 意为应答， 程序的功能是客户端向服务器发送一个字符串， 服务器不做任何处理， 直接把字符串返回给客户端， Echo程序是最为基本的客户/服务器程序。  

### 11.1、EchoServerDemo

```java
package com.vince;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

/**
 */
public class EchoServerDemo {
    public static void main(String[] args) {
        //创建一个服务器端的Socket(1024-65535)
        try {
            ServerSocket server = new ServerSocket(6666);
            System.out.println("服务器已启动，正在等待客户端的连接...");
            //等待客户端的连接，造成阻塞，如果有客户端连接成功，立即返回一个Socket对象
            Socket socket = server.accept();
            System.out.println("客户端连接成功:"+server.getInetAddress().getHostAddress());
            BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            //通过输入流读取网络数据,如果没有数据，那么会阻塞
            String info = br.readLine();
            System.out.println(info);
            //获取输出流，向客户端返回消息
            PrintStream ps = new PrintStream(new BufferedOutputStream(socket.getOutputStream()));

            ps.println("echo:"+info);
            ps.flush();
            //关闭
            ps.close();
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

### 11.2、EchoClientDemo

```java
package com.vince;

import java.io.*;
import java.net.Socket;

/**
 */
public class EchoClientDemo {
    public static void main(String[] args) {
        //创建一个Socket对象，指定要连接的服务器
        try {
            Socket socket = new Socket("localhost",6666);
            //获取socket的输入输出流
            PrintStream ps = new PrintStream(new BufferedOutputStream(socket.getOutputStream()));
            BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            ps.println("hello,my name is Bin");
            ps.flush();
            //读取服务器端返回的数据
            String info = br.readLine();
            System.out.println(info);
            ps.close();
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

![image-20211010201436910](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211010201436910.png)

![image-20211010201500054](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211010201500054.png)

***

## 12、服务器与多客户端通信

目前为止我们编写的程序中， 服务器只能同时处理一个客户端连接， **要想服务器同时支持多个客户端的连接， 就必须加入多线程的处理机制， 将每一个连接的客户端都创建一个新的线程对象。**  

### 12.1、MutilServerDemo

```java
package com.vince;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 处理多个客户端
 * 主线程用于监听客户端的连接，每次有连接成功，开启一个线程来处理该客户端的消息
 */
public class MutilServerDemo {
    public static void main(String[] args) {

        ExecutorService es = Executors.newFixedThreadPool(3);
        try {
            ServerSocket server = new ServerSocket(6666);
            System.out.println("服务器已启动，正在等待连接。。。");
            while(true){
                Socket s = server.accept();
                System.out.println(s.getInetAddress().getHostAddress());
                es.execute(new UserThread(s));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

/**
 * 用来处理客户端请求的线程任务
 */
class UserThread implements Runnable{
    private Socket s;
    public UserThread(Socket s){
        this.s = s;
    }
    @Override
    public void run() {
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
            PrintStream ps= new PrintStream(new BufferedOutputStream(s.getOutputStream()));
            String info = br.readLine();
            System.out.println(info);
            ps.println("echo:"+info);
            ps.flush();
            ps.close();
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

### 12.2、MutilClientDemo

```java
package com.vince;

import java.io.*;
import java.net.Socket;
import java.util.Scanner;

/**
 * Created by vince on 2017/6/6.
 *
 */
public class MutilClientDemo {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        //创建一个Socket对象，指定要连接的服务器
        try {
            Socket socket = new Socket("localhost",6666);
            //获取socket的输入输出流
            PrintStream ps = new PrintStream(new BufferedOutputStream(socket.getOutputStream()));
            BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            System.out.println("请输入：");
            String info = input.nextLine();
            ps.println(info);
            ps.flush();
            //读取服务器端返回的数据
            info = br.readLine();
            System.out.println(info);
            ps.close();
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

***

## 13、多客户端之间的通信  

服务器可以与多个客户端实现通信了， 那我们真正的目的是要实现多个客户端之间的通信， 使用TCP协议实现的方案是：
**客户端的数据包通过服务器中转， 发送到另一个客户端**， 如下图所示：  

![image-20211010201658135](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211010201658135.png)

### 13.1、Message

```java
package com.vince.communication;

import java.io.Serializable;

/**
 * 消息包
 */
public class Message implements Serializable{
    private String from;//发送者
    private String to;//接收者
    private int type;//消息类型
    private String info;//消息

    public String getFrom() {
        return from;
    }

    public void setFrom(String from) {
        this.from = from;
    }

    public String getTo() {
        return to;
    }

    public void setTo(String to) {
        this.to = to;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getInfo() {
        return info;
    }

    public void setInfo(String info) {
        this.info = info;
    }

    public Message() {
    }

    public Message(String from, String to, int type, String info) {
        this.from = from;
        this.to = to;
        this.type = type;
        this.info = info;
    }

    @Override
    public String toString() {
        return "Message{" +
                "from='" + from + '\'' +
                ", to='" + to + '\'' +
                ", type=" + type +
                ", info='" + info + '\'' +
                '}';
    }
}

```

### 13.2、MassageType

```java
package com.vince.communication;

/**
 */
public final class MessageType {
    public static final int TYPE_LOGIN = 0x1;//登录消息类型
    public static final int TYPE_SEND = 0x2;//发送消息的类型
}

```

### 13.3、Server

```java
package com.vince.communication;

import javax.security.sasl.SaslClient;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Vector;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 服务器端
 */
public class Server {

    public static void main(String[] args) {
        //保存客户端处理的线程
        Vector<UserThread> vector = new Vector<>();
        ExecutorService es = Executors.newFixedThreadPool(5);
        //创建服务器端的Socket
        try {
            ServerSocket server = new ServerSocket(8888);
            System.out.println("服务器已启动，正在等待连接...");
            while(true){
                Socket socket = server.accept();
                UserThread user = new UserThread(socket,vector);
                es.execute(user);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}

/**
 * 客户端处理的线程
 */
class UserThread implements Runnable{
    private String name;//客户端的用户名称（唯一）
    private Socket socket;
    private Vector<UserThread> vector;//客户端处理线程的集合
    private ObjectInputStream ois;
    private ObjectOutputStream oos;
    private boolean flag = true;

    public UserThread(Socket socket,Vector<UserThread> vector){
        this.socket = socket;
        this.vector = vector;
        vector.add(this);
    }
    @Override
    public void run() {
        try{
            System.out.println("客户端"+socket.getInetAddress().getHostAddress()+"已连接");
            ois = new ObjectInputStream(socket.getInputStream());
            oos = new ObjectOutputStream(socket.getOutputStream());

            while (flag){
                //读取消息对象
                Message msg  = (Message)ois.readObject();
                int type = msg.getType();
                switch (type){
                    case MessageType.TYPE_SEND:
                        String to = msg.getTo();
                        UserThread ut;
                        int size = vector.size();
                        for (int i = 0; i < size; i++) {
                            ut = vector.get(i);
                            if (to.equals(ut.name) && ut!=this){
                                ut.oos.writeObject(msg);
                                break;
                            }
                        }
                        break;
                    case MessageType.TYPE_LOGIN:
                        name = msg.getFrom();
                        msg.setInfo("欢迎你：");
                        oos.writeObject(msg);
                        break;
                }
            }
            ois.close();
            oos.close();
        }catch (IOException | ClassNotFoundException e){
            e.printStackTrace();
        }
    }
}
```

### 13.4、Client

```java
package com.vince.communication;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 */
public class Client {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        ExecutorService es = Executors.newSingleThreadExecutor();
        try {
            Socket socket = new Socket("localhost", 8888);
            System.out.println("服务器连接成功");
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            //向服务器发送登录信息
            System.out.println("请输入名称：");
            String name = input.nextLine();
            Message msg = new Message(name, null, MessageType.TYPE_LOGIN, null);
            oos.writeObject(msg);
            msg = (Message) ois.readObject();
            System.out.println(msg.getInfo() + msg.getFrom());

            //启动读取消息的线程
            es.execute(new ReadInfoThread(ois));

            //使用主线程来实现发送消息
            boolean flag = true;
            while(flag){
                msg = new Message();
                System.out.println("To:");
                msg.setTo(input.nextLine());
                msg.setFrom(name);
                msg.setType(MessageType.TYPE_SEND);
                System.out.println("Info:");
                msg.setInfo(input.nextLine());
                oos.writeObject(msg);
            }

        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

//读取消息
class ReadInfoThread implements Runnable {
    private ObjectInputStream in;

    public ReadInfoThread(ObjectInputStream in){
        this.in = in;
    }
    private boolean flag = true;

    public void setFlag(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        try {
            while (flag) {

                Message message = (Message) in.readObject();
                System.out.println("[" + message.getFrom() + "]对我说：" + message.getInfo());

            }
            if(in!=null){
                in.close();
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

***

## 14、网络编程UDP协议

### 14.1、UDP协议概述

UDP是User Datagram Protocol的简称， **是一种无连接的协议， 每个数据报都是一个独立的信息**， 包括**完整的源地址或目的地址**， 它在网络上以任何可能的路径传往目的地， **因此能否到达目的地， 到达目的地的时间以及内容的正确性都是不能被保证的**， 每个被传输的数据报必须限定在64KB之内。

主要使用以下的两个类：
**DatagramPacket：** 此类表示数据报包。
**DatagramSocket：** 此类表示用来发送和接收数据报包的套接字  

### 14.2、UDP服务器与客户端程序

**服务器端：**

```java
String info = “….”
// 将信息封装成数据报
byte[] bytes = info.getBytes();
DatagramPacket dp = new DatagramPacket(bytes, 0, bytes.length(), InetAddress.getByName("localhost"), 5000);// 客户端在5000端口监听
DatagramSocket server = new DatagramSocket(3000);// 服务器的端口
server.send(dp);// 发送数据报
server.close();
```

**客户端：**

```java
byte b[] = new byte[1024];// 接收内容
DatagramPacket dp = new DatagramPacket(b, b.length);// 接收内容
// 客户端在5000端口等待
DatagramSocket client = new DatagramSocket(5000);
client.receive(dp); // 接收内容
System.out.println(new String(dp.getData(), 0, dp.getLength()));
client.close();  
```

**UDPClientDemo先启动，准备接受数据后，再启动UDPServerDemo发送数据**

**否则会造成阻塞**

### 14.3、UDPServerDemo

```java
package com.vince;

import com.sun.xml.internal.bind.v2.runtime.unmarshaller.SAXConnector;

import java.io.IOException;
import java.net.*;

/**
 */
public class UDPServerDemo {

    public static void main(String[] args) {

        String info = "good good 学习，天天 UP";
        byte[] bytes = info.getBytes();
        try {
            //封装一个数据报包
            /*
            buf - 数据包数据。
            offset - 分组数据偏移量。
            length - 分组数据长度。
            address - 目的地址。
            port - 目的端口号。
             */
            DatagramPacket dp = new DatagramPacket(
                    bytes,
                    0,
                    bytes.length,
                    InetAddress.getByName("127.0.0.1"),
                    8000);
            //本程序的端口
            DatagramSocket socket = new DatagramSocket(9000);
            socket.send(dp);
            socket.close();
        }catch (UnknownHostException|SocketException e){
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 14.4、UDPClientDemo

```java
package com.vince;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

/**
 * Created by vince on 2017/6/7.
 * 客户端
 */
public class UDPClientDemo {
    public static void main(String[] args) {

        byte[] bytes = new byte[1024];
        DatagramPacket dp = new DatagramPacket(bytes,bytes.length);
        try {
            DatagramSocket socket = new DatagramSocket(8000);
            System.out.println("正在接收数据中...");
            socket.receive(dp);//接收数据
            String s = new String(dp.getData(),0,dp.getLength());
            System.out.println(s);
            socket.close();
        } catch (SocketException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```

## 15、URL

### 15.1、URL概述

URL(uniform resource location )类 URL 代表一个统一资源定位符， 它是指向互联网“ 资源” 的指针。

抽象类 URLConnection 是所有类的超类， 它代表应用程序和 URL 之间的通信链接  

### 15.2、URLDemo

根据提供的URL下载图片资源，并保存到D盘，保存不到C盘。中间使用文件流进行操作。

```java
package com.vince;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

/**
 */
public class URLDemo {

    public static void main(String[] args) {

        //URL 统一资源定位符
        try {
            URL url=new URL("https://b.zhutix.com/bizhi/win11-wp/01.jpg");
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
            BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream("D:\\weiruan.jpg"));
            byte[] bytes = new byte[1024];
            int len =-1;
            while((len=in.read(bytes))!=-1){
                out.write(bytes,0,len);
                out.flush();
            }
            in.close();
            out.close();
            System.out.println("下载成功");
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

***

## 16、MINA框架

1、 什么是MINA？ 一句话就是： 一个简洁易用的基于 TCP/IP 通信的 JAVA框架。

2、 下载地址： [MINA Downloads — Apache MINA](http://mina.apache.org/downloads-mina_2_1.html)

3、 一个简单的网络程序需要的最少jar包： mina-core-2.1.3.jar、 slf4j-api-1.7.26.jar

4、 开发一个 Mina 应用， 简单的说， 就是创建连接， 设定过滤规则， 编写自己的消息处理器

5、 示例：

```java
//创建一个非阻塞的Server端Socket，用NIO
SocketAcceptor acceptor = new NioSocketAcceptor(); //创建接收数据的过滤器
DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();
//设定这个过滤器将一行一行(/r/n)的读取数据
chain.addLast("myChin", new ProtocolCodecFilter(new TextLineCodecFactory()));
//设定服务器端的消息处理器:一个SampleMinaServerHandler对象
acceptor.setHandler(new SampleMinaServerHandler());
int bindPort = 9999;
//绑定端口,启动服务器
try {acceptor.bind(new InetSocketAddress(bindPort)); } catch (IOException e) {e.printStackTrace();}
System.out.println("Mina Server is Listing on:= " + bindPort);  
```

```java
public class SampleMinaServerHandler extends IoHandlerAdapter{
	public void sessionOpened(IoSession session) throws Exception {
		super.sessionOpened(session);
		System.out.println("incomming client : "+session.getRemoteAddress());
	}
    public void sessionClosed(IoSession session) throws Exception {
		super.sessionClosed(session);
		System.out.println("one Clinet Disconnect !");
	}
    public void messageReceived(IoSession session, Object message) throws Exception {
		//我们己设定了服务器解析消息的规则是一行一行读取,这里就可转为String:
		String s=(String)message;
		System.out.println("收到客户机发来的消息: "+s);
		session.write("echo:"+s);
	}
}
```

**1、 使用telnet测试： telnet localhost 9999**
**2、 编写客户端：**

```java
NioSocketConnector connector = new NioSocketConnector(); // 创建接收数据的过滤器
DefaultIoFilterChainBuilder chain = connector.getFilterChain();
//设定这个过滤器将一行一行(/r/n)的读取数据
chain.addLast("myChin", new ProtocolCodecFilter(new TextLineCodecFactory()));
//设定服务器端的消息处理器:一个 SamplMinaServerHandler 对象
connector.setHandler(new SampleMinaClientHandler());
connector.setConnectTimeout(30);// Set connect timeout.
//连接到服务器:
ConnectFuture cf = connector.connect(new InetSocketAddress("localhost", 9999));
// Wait for the connection attempt to be finished.
cf.awaitUninterruptibly();
//发送消息
//cf.getSession().getCloseFuture().awaitUninterruptibly();
//connector.dispose();  
```

```java
public class SampleMinaClientHandler extends IoHandlerAdapter {
	//当一个客端端连结进入时
	public void sessionOpened(IoSession session) throws Exception {
		System.out.println("incomming client :"+session.getRemoteAddress()); session.write("我来啦........");
	}
    //当一个客户端关闭时
	public void sessionClosed(IoSession session) {
		System.out.println("one Clinet Disconnect !"); 
    }
	//当客户端发送的消息到达时:
	public void messageReceived(IoSession session, Object message)throws Exception {
		//我们己设定了服务器解析消息的规则是一行一行读取,这里就可转为 String:
		String s=(String)message;
		System.out.println("服务器发来的收到消息: "+s);
		//测试将消息回送给客户端
		session.write(s);
	} 
}
```

使用 Mina 直接传送对象
1、 public class Userinfo implements java.io.Serializable
2、 服务器， 客户端都设定以对象为单位

```JAVA
//设定这个过滤器将以对象为单位读取数据
ProtocolCodecFilter filter= new ProtocolCodecFilter(new ObjectSerializationCodecFactory());
chain.addLast("objectFilter",filter);
```

3、 接收对象

```JAVA
public void messageReceived(IoSession session, Object message) throws Exception {
	//我们己设定了服务器解析消息的规则一个Userinfo对象为单位传输:
	Userinfo us=(Userinfo)message;
}  
```

**案例：**

**Server**

```java
package com.vince.mina;

import org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.serialization.ObjectSerializationCodecFactory;
import org.apache.mina.filter.codec.textline.TextLineCodecFactory;
import org.apache.mina.transport.socket.SocketAcceptor;
import org.apache.mina.transport.socket.nio.NioSocketAcceptor;

import java.io.IOException;
import java.net.InetSocketAddress;

/**
 */
public class Server {

    public static void main(String[] args) {

        //创建一个非阻塞的Server端Socket NIO
        SocketAcceptor acceptor = new NioSocketAcceptor();
        DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();
        //设定一个过滤器，一行一行的读取数据（/r/n）
        //chain.addLast("myChin",new ProtocolCodecFilter(new TextLineCodecFactory()));
        //设定过滤器以对象为单位读取数据
        chain.addLast("objectFilter",new ProtocolCodecFilter(new ObjectSerializationCodecFactory()));
        //设置服务器端的消息处理器
        acceptor.setHandler(new MinaServerHandler());
        int port = 9999; //服务器的端口号
        try {
            //绑定端口，启动服务器(不会阻塞，立即返回)
            acceptor.bind(new InetSocketAddress(port));
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("Mina Server running, listener on : "+ port);
    }
}

```

**MinaServerHandler**

```java
package com.vince.mina;

import org.apache.mina.core.service.IoHandlerAdapter;
import org.apache.mina.core.session.IoSession;

/**
 * 服务器端的消息处理器
 */
public class MinaServerHandler extends IoHandlerAdapter {
    //一次会话被打开
    @Override
    public void sessionOpened(IoSession session) throws Exception {
        super.sessionOpened(session);
        System.out.println("welcome client "+session.getRemoteAddress());
    }
    //会话关闭
    @Override
    public void sessionClosed(IoSession session) throws Exception {
        super.sessionClosed(session);
        System.out.println("client closed");
    }

    //接收消息
    @Override
    public void messageReceived(IoSession session, Object message) throws Exception {
        super.messageReceived(session, message);
        //String msg = (String) message;//接收到的消息对象
        Message msg = (Message) message;

        System.out.println("收到客户端发来的消息："+msg);
        msg.setInfo("吃好吃的");
        //向客户端发送消息对象
        session.write(msg);
    }
}

```

**Client**

```java
package com.vince.mina;

import org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;
import org.apache.mina.core.future.ConnectFuture;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.serialization.ObjectSerializationCodecFactory;
import org.apache.mina.filter.codec.textline.TextLineCodecFactory;
import org.apache.mina.transport.socket.nio.NioSocketConnector;

import java.net.InetSocketAddress;
import java.util.Scanner;

/**
 */
public class Client {
    public static void main(String[] args) {

        //创建连接
        NioSocketConnector connector = new NioSocketConnector();
        DefaultIoFilterChainBuilder chain = connector.getFilterChain();
//        chain.addLast("myChin",new ProtocolCodecFilter(new TextLineCodecFactory()));
        //设定过滤器以对象为单位读取数据
        chain.addLast("objectFilter",new ProtocolCodecFilter(new ObjectSerializationCodecFactory()));

        connector.setHandler(new MinaClientHandler());
        connector.setConnectTimeoutMillis(10000);
        //连接服务器
        ConnectFuture cf = connector.connect(new InetSocketAddress("localhost",9999));
        cf.awaitUninterruptibly();//等待连接成功
        Scanner input = new Scanner(System.in);

        while(true) {
//            System.out.println("请输入:");
//            String info = input.nextLine();
//            //发送消息
//            cf.getSession().write(info);

            //以对象的方式传输数据
            Message msg = new Message();
            System.out.println("form:");
            msg.setFrom(input.nextLine());
            System.out.println("to:");
            msg.setTo(input.nextLine());
            System.out.println("info:");
            msg.setInfo(input.nextLine());
            msg.setType("send");

            cf.getSession().write(msg);
        }
        //等待服务器连接关闭，结束长连接
       // cf.getSession().getCloseFuture().awaitUninterruptibly();
       // connector.dispose();//关闭连接
    }
}

```

**MinaClientHandler**

```java
package com.vince.mina;

import org.apache.mina.core.service.IoHandlerAdapter;
import org.apache.mina.core.session.IoSession;

import javax.sound.midi.Soundbank;

/**
 */
public class MinaClientHandler extends IoHandlerAdapter {


    @Override
    public void sessionOpened(IoSession session) throws Exception {
        super.sessionOpened(session);
        System.out.println("sessionOpened");
    }

    @Override
    public void sessionClosed(IoSession session) throws Exception {
        super.sessionClosed(session);
        System.out.println("sessionClosed");
    }

    @Override
    public void messageReceived(IoSession session, Object message) throws Exception {
        super.messageReceived(session, message);
        //String msg = (String) message;
        Message msg = (Message)message;
        System.out.println(msg);
    }
}

```

**Message**

```java
package com.vince.mina;

import java.io.Serializable;

/**
 */
public class Message implements Serializable {

    private String from;
    private String to;
    private String type;
    private String info;

    public String getFrom() {
        return from;
    }

    public void setFrom(String from) {
        this.from = from;
    }

    public String getTo() {
        return to;
    }

    public void setTo(String to) {
        this.to = to;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getInfo() {
        return info;
    }

    public void setInfo(String info) {
        this.info = info;
    }

    @Override
    public String toString() {
        return "Message{" +
                "from='" + from + '\'' +
                ", to='" + to + '\'' +
                ", type='" + type + '\'' +
                ", info='" + info + '\'' +
                '}';
    }
}

```

