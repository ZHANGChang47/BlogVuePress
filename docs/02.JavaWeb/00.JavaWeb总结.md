---
title: JavaWeb总结
date: 2023-02-03 23:55:23
permalink: /pages/a105cd/
categories:
  - JavaWeb
tags:
  - 
---
# JavaWeb总结

## 1、基本概念

### 1.1、前言

web开发：

- web，网页的意思
- 静态web
  - html、css
  - 提供给所有人看的时候数据始终不会发生任何变化
- 动态web
  - 提供给所有人看的时候数据会发生变化，每个人在不同时间、不同的地点看到的信息各不相同
  - 几乎所有网站都是动态

在java中，动态web资源开发的技术统称为javaweb;

### 1.2、web应用程序

web应用程序指得是可以提供浏览器访问的程序

- a.html、b.html...多个web资源，这些web资源可以被外界访问，对外界提供服务
- 能访问到的任何一个页面或者资源，都存在于这个世界某一个角落的计算机上
- URL地址
- 这个统一的web资源会被放在同一个文件夹下，web应用程序——>Tomcat（服务器）
- 一个web应用由多个部分组成（静态web，动态web）
  - html、css、js
  - jsp、servlet
  - java程序
  - jar包
  - 配置文件（Properties）

web应用程序编写完毕后，若想提供给外界访问，需要一个服务器来统一管理

### 1.3、静态web

- \*.htm、\*.html这些都是网页的后缀，如果服务器一直存在这些东西，我们就可以直接进行读取

![image-20221226105814835](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226105814835.png)

- 静态web存在的缺点
  - web页面无法动态更新，所有用户看到的都是同一个界面
    - 轮播图，点击特效：伪动态，使用JavaScript来实现
  - 无法和数据库进行交互（数据无法持久化，用户无法交互）

### 1.4、动态web

页面会进行动态展示：“Web的页面展示效果因人而异”

![image-20221226111010402](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226111010402.png)

缺点：

- 假如服务器的动态资源出现了错误，需要重新编写“后台程序”，重新发布
  - 停机维护

优点：

- web页面可以动态更新，所有用户看到的不是同一个界面
- 可以与数据库进行交互（数据持久化：注册、用户信息...）

## 2、Tomcat服务器

web服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；

Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由[Apache](https://baike.baidu.com/item/Apache/6265?fromModule=lemma_inlink)、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web 应用服务器。

Tomcat 服务器是一个免费的开放源代码的[Web](https://baike.baidu.com/item/Web/150564?fromModule=lemma_inlink) 应用服务器，属于轻量级应用[服务器](https://baike.baidu.com/item/服务器/100571?fromModule=lemma_inlink)，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应[HTML](https://baike.baidu.com/item/HTML/97049?fromModule=lemma_inlink)（[标准通用标记语言](https://baike.baidu.com/item/标准通用标记语言/6805073?fromModule=lemma_inlink)下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。

诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和[IIS](https://baike.baidu.com/item/IIS/99720?fromModule=lemma_inlink)等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态[HTML](https://baike.baidu.com/item/HTML/97049?fromModule=lemma_inlink)的能力不如Apache服务器。Tomcat最新版本为10.0.23**。**

### 2.1、安装Tomcat

[Tomcat官网](https://tomcat.apache.org/)

![image-20221226115304407](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226115304407.png)

将压缩包下载到指定目录，并进行解压，解压后的文件夹中内容如下所示：

![image-20221226120640502](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226120640502.png)

### 2.2、启动关闭Tomcat

进入bin目录，windows环境下，双击运行startup.bat启动tomcat，在浏览器中输入localhost:8080即可访问，双击运行shutdown.bat即可关闭，或者在终端中使用ctrl+c也可关闭

![image-20221226120929519](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226120929519.png)

可能遇到的问题：

1. Java环境变量没有配置
2. 闪退问题：需要配置兼容性
3. 乱码问题：配置文件中设置

### 2.3、配置

![image-20221226121159149](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226121159149.png)

进入后可以配置启动的端口号

- tomcat的默认端口号为：8080

- mysql：3306

- http：80

- https：443

  ```xml
  <Connector port="8080" protocol="HTTP/1.1"
                 connectionTimeout="20000"
                 redirectPort="8443" />
  ```

可以配置主机的名称 

- 默认的主机名为：localhost->127.0.0.1
- 默认的网站应用存放位置为：webapps

```xml
<Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
```

**网站是如何访问的：**

1. 输入一个域名；回车

2. 检查本机的C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名的映射：

   1. 有：直接返回对应的ip地址，在这个地址中，有我们需要访问的web程序，可以直接访问

      ```txt
      127.0.0.1	www.zhangchang.com
      ```

   2. 没有：去DNS服务器找（全世界的域名都在这里管理14.215.177.39:443），找到的话就返回，找不到的话就报错

### 2.4、发布一个web网站

将自己写的网站，放到服务器（Tomcat）中指定的web应用文件夹下（webapps），就可以访问了

网站应该有的结构：

```java
--webapps	:Tomcat服务器的web目录
    -ROOT
    -zhangchang	:网站的目录名
        -WEB-INF
        	-classes	:java程序
            -lib	:web应用所依赖的jar包
            -web.xml	:网站配置文件
        -index.html	:默认的首页
        -static
            -css
            	-style.css
            -js
            -img
     -...
```

## 3、HTTP

### 3.1、什么是HTTP

超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在[TCP](https://baike.baidu.com/item/TCP/33012?fromModule=lemma_inlink)之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以[ASCII](https://baike.baidu.com/item/ASCII/309296?fromModule=lemma_inlink)形式给出；而消息内容则具有一个类似[MIME](https://baike.baidu.com/item/MIME/2900607?fromModule=lemma_inlink)的格式。这个简单模型是早期[Web](https://baike.baidu.com/item/Web/150564?fromModule=lemma_inlink)成功的有功之臣，因为它使开发和部署非常地直截了当。

- 文本：html、字符串......
- 超文本：图片、音乐、视频、定位、地图......

Https：安全的

- 端口号：443

### 3.2、HTTP请求

- 客户端——>发请求（Request）——>服务器

百度为例的请求行与消息头：

```java
Request URL(请求地址): https://www.baidu.com/
Request Method(请求方法): GET
Status Code(状态代码): 200 OK
Remote Address(远程地址): 110.242.68.3:443
Referrer Policy(引用者策略): unsafe-url
```

```java
Accept: text/html
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
Cache-Control: no-cache
Connection: keep-alive
```

#### 3.2.1、请求行

- 上述请求行中的请求方式：GET
- 请求方式：**GET、POST**、HEAD、DELETE、PUT......
  - GET：请求能够携带的参数比较少，有大小限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效
  - POST：请求能够携带的参数没有限制，没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但并不高效

#### 3.2.2、消息头

```java
Accept: 告诉浏览器，它所支持的数据类型
Accept-Encoding: 支持哪种编码格式：GBK、UTF-8、GB2312、ISO8859-1
Accept-Language: 告诉浏览器，它的语言环境
Cache-Control: 缓存控制
Connection: 告诉浏览器，请求完成是断开还是保持连接
HOST：主机...../.
```

### 3.3、HTTP响应

- 服务器——>响应——>客户端

以百度为例：

```java
Cache-Control:private	缓存控制
Connection: keep-alive	连接
Content-Encoding: gzip	编码
Content-Type: text/html; charset=utf-8	类型
```

#### 3.3.1、响应体

```java
Accept: 告诉浏览器，它所支持的数据类型
Accept-Encoding: 支持哪种编码格式：GBK、UTF-8、GB2312、ISO8859-1
Accept-Language: 告诉浏览器，它的语言环境
Cache-Control: 缓存控制
Connection: 告诉浏览器，请求完成是断开还是保持连接
HOST：主机...../.
Refresh：告诉客户端，多久刷新一次
Location：让网页重新定位
```

#### 3.3.2、响应状态码

- 200：请求响应成功（200）
- 3xx：请求重定向
  - 重定向：重新到新位置去
- 4xx：找不到资源（404）
  - 资源不存在
- 5xx：服务器代码错误（500、502:网关错误）

## 4、Maven

我们目前用来就是方便导入jar包的！

> Maven的核心思想：约定大于配置

- 有约束，不要去违反

Maven会规定好应该如何去写Java代码，必须要按照这个规范来

### 4.1、下载安装

[Maven官网](https://maven.apache.org/)

![image-20221226174727852](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226174727852.png)

下载完成后，解压即可；

### 4.2、配置环境变量

在环境变量中做如下配置：

- M2_HOME

  D:\Maven\apache-maven-3.8.3

  ![image-20221226175802158](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226175802158.png)

- Path

  ![image-20221226175842777](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226175842777.png)

测试maven是否安装成功：

```bash
mvn -version
```

![image-20221226175957870](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226175957870.png)

### 4.3、阿里云镜像

- 镜像：mirrors

  - 作用：加速我们的下载

- 国内建议使用阿里云的镜像

  ```xml
  <mirror>
  	<id>nexus-aliyun</id>
      <mirrorOf>central</mirrorOf>
      <name>Nexus aliyun</name>
      <url>http://maven.aliyun.com/nexus/content/groups/public</url>
  </mirror>
  ```

### 4.4、本地仓库

```xml
<localRepository>D:\Maven_StoreHouse</localRepository>
```

![image-20221226180328206](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226180328206.png)

### 4.5、在IDEA中创建Maven项目

1. 启动IDEA

2. 创建一个Maven Web项目，普通项目不需要勾选

   ![image-20221226182519486](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226182519486.png)

   填写Maven GAV

   ![image-20221226182703570](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226182703570.png)

   设置相关路径

   ![image-20221226182929726](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226182929726.png)

   IDEA中maven设置

   ![image-20221226202000852](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226202000852.png)

   到这里，Maven在IDEA中的配置和使用基本就ok了

### 4.6、在IDEA中使用Maven项目

在main文件夹下创建两个目录，分别为java以及resources，java作为源代码目录，resources作为资源目录，新版IDEA无需标记，可以直接创建。

webapp作为网页资源目录

![image-20221226203414946](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226203414946.png)

![image-20221226203226581](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226203226581.png)

### 4.7、在IDEA中配置Tomcat

打开IDEA的设置对话框，执行如下步骤：

File——>Settings——>Build,Execution,Deployment——>Application Servers——>点击+号——>选择Tomcat Server

此时会弹出Tomcat Server对话框，如下图所示，如果Tomcat已经配置好环境变量，此时IDEA会帮助自动识别。如果想更改其他的Tomcat版本，点击文件夹图标，选择需要的版本即可。

![image-20221226205450038](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226205450038.png)

点击右上方add configurations，然后选择本地的tomcat

![image-20221226203911157](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226203911157.png)

![image-20221226204047208](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226204047208.png)

![image-20221226205653917](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226205653917.png)

![image-20221226205743893](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226205743893.png)

![image-20221226210201259](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226210201259.png)

![image-20221226210503627](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226210503627.png)

![image-20221226210555987](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226210555987.png)

![image-20221226210749874](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221226210749874.png)

### 4.8、pom.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--Maven版本和头文件-->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <!--这里是刚刚配置的GAV-->
  <groupId>com.chang</groupId>
  <artifactId>javaweb-01-maven</artifactId>
  <version>1.0-SNAPSHOT</version>
  <!--项目的打包方式：
  jar：java应用
  war：javaWeb应用
  -->
  <packaging>war</packaging>

  <!--配置-->
  <properties>
    <!--项目的默认构建编码-->
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <!--编译版本-->
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>

  <!--项目依赖-->
  <dependencies>
    <!--具体依赖的jar包配置文件-->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <!--项目构建用的插件-->
  <!--在build中配置resources，来防止我们资源导出失败问题-->
  <build>
    <finalName>javaweb-01-maven</finalName>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.1.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.8.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.22.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.2.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
    <resources>
      <resource>
        <directory>src/main/resources</directory>
        <includes>
          <include>**/*.properties</include>
          <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
      </resource>
      <resource>
        <directory>src/main/java</directory>
        <includes>
          <include>**/*.properties</include>
          <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
      </resource>
    </resources>
  </build>
</project>
```

## 5、Servlet

### 5.1、Servlet简介

- Servlet就是sun公司开发动态web的一门技术
- Sun在这些API中提供一个接口叫做：Servlet，如果想开发一个Servlet程序，只需要完成两个小步骤：
  - 编写一个类，实现Servlet接口
  - 把开发好的java类部署到web服务器中

**把实现了Servlet接口的java程序叫做，Servlet**

### 5.2、HelloServlet

Servlet接口Sun公司有两个默认的实现类：HttpServlet、GenericServlet

1. 构建一个普通的Maven项目，删掉里面的src目录，以后就在这个项目里面建立Module

2. 在pom.xml中引入相关依赖

   ```xml
   	<dependencies>
           <dependency>
               <groupId>javax.servlet</groupId>
               <artifactId>javax.servlet-api</artifactId>
               <version>4.0.1</version>
               <scope>provided</scope>
           </dependency>
       </dependencies>
   ```

3. 构建子模块

   ![image-20221228095652721](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228095652721.png)

   ![image-20221228095753107](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228095753107.png)

   ![image-20221228100016742](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228100016742.png)

4. Maven环境优化

   - 修改web.xml为最新内容

   - 在servelet-01中的main目录下新建java以及resources目录

5. 编写一个servlet程序

   1. 在java目录中，创建com.chang.servlet.HelloServlet.java

      该类需要继承HttpServlet，并且重写doGet与doPost方法

      ![image-20221228102955334](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228102955334.png)

      ```java
      package com.chang.servlet;
      
      import javax.servlet.ServletException;
      import javax.servlet.http.HttpServlet;
      import javax.servlet.http.HttpServletRequest;
      import javax.servlet.http.HttpServletResponse;
      import java.io.IOException;
      
      public class HelloServlet extends HttpServlet {
      
          @Override
          protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
              super.doGet(req, resp);
          }
      
          @Override
          protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
              super.doPost(req, resp);
          }
      }
      ```

   2. 重写doGet与doPost方法，以及编写servlet的映射

      为什么需要映射：我们写的是java程序，但是要通过浏览器进行访问，而浏览器需要连接web服务器，所以需要在web服务中注册我们写的servlet，还需要给一个浏览器能够访问的路径

      ```java
      package com.chang.servlet;
      
      import javax.servlet.ServletException;
      import javax.servlet.ServletOutputStream;
      import javax.servlet.http.HttpServlet;
      import javax.servlet.http.HttpServletRequest;
      import javax.servlet.http.HttpServletResponse;
      import java.io.IOException;
      import java.io.PrintWriter;
      
      public class HelloServlet extends HttpServlet {
      
          //由于get和post只是请求实现的方式不同，可以相互调用，因为业务逻辑都一样
          @Override
          protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
              
              //输出流
              //ServletOutputStream outputStream = resp.getOutputStream();
              //响应流
              PrintWriter writer = resp.getWriter();
              writer.print("Hello,servlet");
          }
      
          @Override
          protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
              doGet(req, resp);
          }
      }
      ```

      pom.xml

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
               version="4.0">
      <!--注册servlet-->
          <servlet>
              <servlet-name>hello</servlet-name>
              <servlet-class>com.chang.servlet.HelloServlet</servlet-class>
          </servlet>
      <!--servlet的请求路径-->
          <servlet-mapping>
              <servlet-name>hello</servlet-name>
              <url-pattern>/hello</url-pattern>
          </servlet-mapping>
      </web-app>
      ```

   3. 配置tomcat

      配置项目发布的路径是/s1

      ![image-20221228104159243](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228104159243.png)

   4. 启动测试 

      ![image-20221228104413022](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228104413022.png)

### 5.3、Mapping问题

1. 一个Servlet可以指定一个映射路径

   ```xml
   	<servlet-mapping>
           <servlet-name>hello</servlet-name>
           <url-pattern>/hello</url-pattern>
       </servlet-mapping>
   ```

2. 一个Servlet可以指定多个映射路径

   ```xml
   	<servlet-mapping>
           <servlet-name>hello</servlet-name>
           <url-pattern>/hello</url-pattern>
       </servlet-mapping>
       <servlet-mapping>
           <servlet-name>hello</servlet-name>
           <url-pattern>/hell1</url-pattern>
       </servlet-mapping>
       <servlet-mapping>
           <servlet-name>hello</servlet-name>
           <url-pattern>/hell2</url-pattern>
       </servlet-mapping>
   ```

3. 一个Servlet可以指定通用映射路径

   ```xml
   	<!--*前面不能加项目映射路径-->
   	<servlet-mapping>
           <servlet-name>hello</servlet-name>
           <url-pattern>/hello/*</url-pattern>
       </servlet-mapping>
   ```

4. 指定一些前缀或者前缀

   ```xml
   	<servlet-mapping>
           <servlet-name>hello</servlet-name>
           <url-pattern>*.chang</url-pattern>
       </servlet-mapping>
   ```

5. 优先级问题

   - 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求

## 6、ServletContext对象

### 6.0、准备工作

在父目录下新建servlet-02子目录，创建java文件夹以及resources文件夹，以及在java文件夹下创建HelloServlet类，并设置映射。

然后修改tomcat的配置，将servlet-01的war包删去，添加servlet-02的war包

![image-20221228114805818](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228114805818.png)

![image-20221228114924864](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228114924864.png)

### 6.1、ServletContext

web容器在启动的时候，它会为每一个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；

#### 6.1.1、共享数据

> setAttribute、getAttribute

- 这个Servlet中保存的数据可以在另外一个Servlet中拿到

  ![image-20221228120414644](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228120414644.png)


- 创建一个HelloServlet.java，在其中使用context存放数据

```java
package com.chang.servlet;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

//        this.getInitParameter();    //获取初始化参数
//        this.getServletConfig();    //获取Servlet配置
//        this.getServletContext();   //获取Servlet上下文

        ServletContext context = this.getServletContext();

        String username="张畅";
        context.setAttribute("username",username);  //将一个数据保存在ServletContext中
    }
}
```

- 然后创建一个GetServlet.java，从context中获取数据，并设置相对应的编码

```java
package com.chang.servlet;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String username = (String) context.getAttribute("username");

        resp.setContentType("text/html;charset=utf-8");
        resp.getWriter().print("名字："+username);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

- 在web.xml配置相关路由

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.chang.servlet.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>getc</servlet-name>
        <servlet-class>com.chang.servlet.GetServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>getc</servlet-name>
        <url-pattern>/getc</url-pattern>
    </servlet-mapping>
</web-app>
```

- 首先调用/hello，然后调用getc，可以获取到存储的数据

![image-20221228161922209](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228161922209.png)

#### 6.1.2、获取初始化参数

> getInitParameter

在web.xml配置好初始化参数后，在.java文件中可以通过context获取

```xml
	<context-param>
        <param-name>url</param-name>
        <param-value>jdbc:mysql://localhost:3306/mybatis</param-value>
    </context-param>

    <servlet>
        <servlet-name>gp</servlet-name>
        <servlet-class>com.chang.servlet.ServletDemo03</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>gp</servlet-name>
        <url-pattern>/gp</url-pattern>
    </servlet-mapping>
```

```java
package com.chang.servlet;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class ServletDemo03 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String url = context.getInitParameter("url");
        resp.getWriter().print(url);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

![image-20221228163753773](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228163753773.png)

#### 6.1.3、请求转发与重定向的区别

- 请求转发：A需要C中的资源，A通过B向C中获取，B从C中获取后，B返回给A

![image-20221228165312867](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228165312867.png)

- 重定向：A希望通过B获取C中的资源，B将信息返回给A，B让A去重新向C发起请求

![image-20221228165434585](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228165434585.png)

相同点：

- 页面都会实现跳转

不同点：

- 请求转发的时候，url不会产生变化
- 重定向时候，url地址栏会发生变化

#### 6.1.4、请求转发

> 使用context的getRequestDispatcher以及forward实现转发

ServletDemo04

```java
package com.chang.servlet;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class ServletDemo04 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
//        RequestDispatcher requestDispatcher = context.getRequestDispatcher("/gp");  //转发的请求路径
//        requestDispatcher.forward(req,resp);    //调用forward实现请求转发
        context.getRequestDispatcher("/gp").forward(req,resp);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

```xml
	<servlet>
        <servlet-name>sd4</servlet-name>
        <servlet-class>com.chang.servlet.ServletDemo04</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>sd4</servlet-name>
        <url-pattern>/sd4</url-pattern>
    </servlet-mapping>
```

转发后获得的是/gp中的内容

![image-20221228164857537](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228164857537.png)

#### 6.1.5、读取资源文件

> getResourceAsStream

Properties

- 在java目录下新建的properties
- 在resources目录下新建的properties

都会被打包到同一个路径下：classes，我们俗称这个路径为classpath；

在resources目录下新建db.properties文件

```properties
username=root
password=123456
```

ServletProperties：

```java
package com.chang.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class ServletProperties extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        InputStream is = this.getServletContext().getResourceAsStream("/WEB-INF/classes/db.properties");

        Properties prop = new Properties();
        prop.load(is);

        String username = prop.getProperty("username");
        String password = prop.getProperty("password");

        resp.getWriter().print(username+":"+password);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}

```

web.xml

```xml
    <servlet>
        <servlet-name>sd5</servlet-name>
        <servlet-class>com.chang.servlet.ServletProperties</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>sd5</servlet-name>
        <url-pattern>/sd5</url-pattern>
    </servlet-mapping>
```

![image-20221228171817438](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221228171817438.png)

## 7、HttpServletResponse

响应

web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，一个代表响应的HttpServletResponse对象

### 7.1、简单分类

1. 负责向浏览器发送数据的方法

   ```java
   ServletOutputStream getOutputStream() throws IOException;
   
   PrintWriter getWriter() throws IOException;
   ```

2. 负责向浏览器发送响应头的方法

   ```java
       void setCharacterEncoding(String var1);
   
       void setContentLength(int var1);
   
       void setContentLengthLong(long var1);
   
       void setContentType(String var1);
   
       void setDateHeader(String var1, long var2);
   
       void addDateHeader(String var1, long var2);
   
       void setHeader(String var1, String var2);
   
       void addHeader(String var1, String var2);
   
       void setIntHeader(String var1, int var2);
   
       void addIntHeader(String var1, int var2);
   ```

3. 响应的状态码

   ```java
   	int SC_CONTINUE = 100;
       int SC_SWITCHING_PROTOCOLS = 101;
       int SC_OK = 200;
       int SC_CREATED = 201;
       int SC_ACCEPTED = 202;
       int SC_NON_AUTHORITATIVE_INFORMATION = 203;
       int SC_NO_CONTENT = 204;
       int SC_RESET_CONTENT = 205;
       int SC_PARTIAL_CONTENT = 206;
       int SC_MULTIPLE_CHOICES = 300;
       int SC_MOVED_PERMANENTLY = 301;
       int SC_MOVED_TEMPORARILY = 302;
       int SC_FOUND = 302;
       int SC_SEE_OTHER = 303;
       int SC_NOT_MODIFIED = 304;
       int SC_USE_PROXY = 305;
       int SC_TEMPORARY_REDIRECT = 307;
       int SC_BAD_REQUEST = 400;
       int SC_UNAUTHORIZED = 401;
       int SC_PAYMENT_REQUIRED = 402;
       int SC_FORBIDDEN = 403;
       int SC_NOT_FOUND = 404;
       int SC_METHOD_NOT_ALLOWED = 405;
       int SC_NOT_ACCEPTABLE = 406;
       int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
       int SC_REQUEST_TIMEOUT = 408;
       int SC_CONFLICT = 409;
       int SC_GONE = 410;
       int SC_LENGTH_REQUIRED = 411;
       int SC_PRECONDITION_FAILED = 412;
       int SC_REQUEST_ENTITY_TOO_LARGE = 413;
       int SC_REQUEST_URI_TOO_LONG = 414;
       int SC_UNSUPPORTED_MEDIA_TYPE = 415;
       int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
       int SC_EXPECTATION_FAILED = 417;
       int SC_INTERNAL_SERVER_ERROR = 500;
       int SC_NOT_IMPLEMENTED = 501;
       int SC_BAD_GATEWAY = 502;
       int SC_SERVICE_UNAVAILABLE = 503;
       int SC_GATEWAY_TIMEOUT = 504;
       int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
   ```

### 7.2、常见应用

#### 7.2.1、向浏览器输送消息

#### 7.2.2、下载文件

1. 要获取下载文件的路径
2. 下载的文件名是什么
3. 设置想办法让浏览器能够支持下载我们需要的东西
4. 获取下载文件的输入流
5. 创建缓冲区
6. 获取OutputStream对象
7. 将FileOutputStream流写入到buffer缓冲区
8. 使用OutputStream将缓冲区中的数据输出到客户端，使用OutputStream将缓冲区中的数据输出到客户端

```java
package com.chang.servlet;

import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.URLEncoder;

public class FileServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        1. 要获取下载文件的路径
        String realPath = "C:\\Users\\26484\\Desktop\\javaweb-02-servlet\\response\\src\\main\\resources\\1.png";
        System.out.println("要下载文件的路径为："+realPath);
//        2. 下载的文件名是什么
        //截取最后一个/后面的内容
        String fileName = realPath.substring(realPath.lastIndexOf("//") + 1);
//        3. 设置想办法让浏览器能够支持下载我们需要的东西
        resp.setHeader("Content-Disposition","attachment;filename="+ URLEncoder.encode(fileName,"UTF-8"));
//        4. 获取下载文件的输入流
        FileInputStream in = new FileInputStream(realPath);
//        5. 创建缓冲区
        int len = 0;
        byte[] buffer = new byte[1024];
//        6. 获取OutputStream对象
        ServletOutputStream out = resp.getOutputStream();
//        7. 将FileOutputStream流写入到buffer缓冲区，使用OutputStream将缓冲区中的数据输出到客户端
        while ((len=in.read(buffer))>0){
            out.write(buffer,0,len);
        }
        in.close();
        out.close();
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <servlet>
        <servlet-name>filedown</servlet-name>
        <servlet-class>com.chang.servlet.FileServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>filedown</servlet-name>
        <url-pattern>/down</url-pattern>
    </servlet-mapping>


</web-app>
```

#### 7.2.3、验证码功能

验证怎么来？

- 前端实现
- 后端实现，需要用到Java的图片类，生产一个图片

```java
package com.chang.servlet;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

public class ImageServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //如何让浏览器5秒刷新一次
        resp.setHeader("refresh","3");

        //在内存中创建一个图片（有了一个空白画布）
        BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_3BYTE_BGR);
        //得到图片（graphics相当于画画的笔）
        Graphics2D g = (Graphics2D)image.getGraphics();
        //设置图片的背景颜色与填充范围
        g.setColor(Color.white);
        g.fillRect(0,0,80,20);
        //给图片写数据
        g.setColor(Color.BLUE);
        g.setFont(new Font(null,Font.BOLD,20)); //设置字体
        g.drawString(makeNum(),10,20);

        //告诉浏览器，这个请求以图片的方式打开
        resp.setContentType("image/jpeg");
        //网站存在缓存，不让浏览器缓存
        resp.setDateHeader("expires",-1);
        resp.setHeader("Cache-Control","no-cache");
        resp.setHeader("Pragma","no-cache");
        //把图片写给浏览器
        ImageIO.write(image,"jpg",resp.getOutputStream());
    }

    //生成随机数
    private String makeNum(){
        Random random = new Random();
//        random.nextInt(999999); //6个9代表6位数
        String num=random.nextInt(999999)+"";
        StringBuffer sb = new StringBuffer();
        for(int i=0;i<6-num.length();i++){
            sb.append("0");
        }
        num=sb.toString()+num;
        return num;
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

```xml
	<servlet>
        <servlet-name>ImageServlet</servlet-name>
        <servlet-class>com.chang.servlet.ImageServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>ImageServlet</servlet-name>
        <url-pattern>/img</url-pattern>
    </servlet-mapping>
```

#### 7.2.4、重定向

一个web资源（B）收到客户端（A）请求，他（B）会通知客户端（A）去访问另外一个web资源（C），这个过程叫做重定向。

常见场景：

- 用户登录

```java
void sendRedirect(String varl) throws IOException;
```

```java
package com.chang.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class RedirectServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.sendRedirect("/r/img");    //重定向
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

```xml
	<servlet>
        <servlet-name>RedirectServlet</servlet-name>
        <servlet-class>com.chang.servlet.RedirectServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>RedirectServlet</servlet-name>
        <url-pattern>/red</url-pattern>
    </servlet-mapping>
```

## 8、HttpServletRequest

HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过HttpServletRequest的方法，获得客户端的所有信息

- 获取前端传递的参数，主要方法有两个

  ![image-20221229090503959](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221229090503959.png)

- 请求转发，这里的“/”代表当前的web应用/

  ```java
  req.getRequestDispatcher("/success").forward(req,resp);
  ```

## 9、Cookie

### 9.1、会话技术

  会话：一次会话中包含多次请求和响应

​				一次会话表示浏览器第一次给服务器发送请求，会话建立，直到有一方断开为止

功能：在一次会话的多次请求间共享数据

方式

- 客户端会话技术：Cookie
- 服务器端会话技术：Session

### 9.2、什么是Cookie

Cookie 是服务器通知客户端保存键值对的一种技术，客户端有了 Cookie 之后，每次请求都会发送给服务器

浏览器对单个 Cookie 有大小限制(4KB)，对同一个域名下的总cookie数量也有限制(20个)

作用

- Cookie一般用于存储少量的安全性较低的数据
- 在没有登陆的情况下，完成服务器对客户端的身份识别，如没有登录百度账号的前提下打开百度，设置搜索引擎搜索时不提示，以后打开浏览器访问百度时，不会再出现搜索提示框，原理：百度服务器将设置的Cookie信息保存到浏览器，下次访问百度时，百度服务器获取浏览器的Cookie，根据Cookie的值决定要不要显示提示框

**使用步骤**

1. 创建Cookie对象，参数中绑定数据(键值对)

```java
new Cookie(String name, String value)
```

2. 客户端向服务器发送请求后，服务器向客户端发送Cookie对象
   `response.addCookie(Cookie cookie)`

3. 客户端收到Cookie后，再次发送请求时，服务器获取从客户端发来的Cookie对象
   `Cookie[] request.getCookies()`

4. 服务器得到Cookie对象后，使用`getName()`与`getValue()`方法得到Cookie对象的数据

### 9.3、创建 Cookie

![image-20211115170838666](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211115170838666.png)

> 一次可以发送多个Cookie对象，使用response调用多次addCookie方法即可

```java
protected void createCookie(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    //1 创建Cookie对象
    Cookie cookie1 = new Cookie("key1", "value1");
    Cookie cookie2 = new Cookie("key2", "value2");

    //2 通知客户端保存Cookie
    response.addCookie(cookie1);
    response.addCookie(cookie2);
    response.getWriter().write("Cookie 创建成功");

    // 方案二：
    // 1、先查找到需要修改的Cookie对象
    // 2、调用setValue()方法赋于新的Cookie值。
    // 3、调用response.addCookie()通知客户端保存修改
}
```

### 9.4、获取Cookie

> 服务器获取客户端的Cookie只需要一行代码

```java
protected void getCookie(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    Cookie[] cookies = request.getCookies();

    for (Cookie cookie : cookies) {
        // getName方法返回Cookie的key（名）
        // getValue方法返回Cookie的value值
        response.getWriter().write("cookie[" + cookie.getName() + "=" + cookie.getValue() + "] <br/>");
    }

    Cookie iWantCookie = CookieUtils.findCookie("key1", cookies);

    // 如果不等于null，说明赋过值，也就是找到了需要的Cookie
    if (iWantCookie != null) {
        response.getWriter().write("找到了需要的Cookie");
    }
}
```

**查找指定名称的Cookie对象工具类**

```java
public class CookieUtils {
    /**
     * 查找指定名称的Cookie对象
     *
     * @param name
     * @param cookies
     * @return
     */
    public static Cookie findCookie(String name, Cookie[] cookies) {
        if (name == null || cookies == null || cookies.length == 0) {
            return null;
        }

        for (Cookie cookie : cookies) {
            if (name.equals(cookie.getName())) {
                return cookie;
            }
        }
        return null;
    }
}
```

### 9.5、修改cookie的值

cookie的value值不能包含符号 及 中文（tomcat8以后可以中文），除非使用BASE64编码

`public void setValue(String newValue)` 设置Cookie的值

```java
protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    /*
     * 无论以下哪种方案，cookie的value值都不能包含符号 及 中文，除非使用BASE64编码
     */
    // 方案一：
    // 1、先创建一个要修改的同名的Cookie对象，同时赋于新的Cookie值。
    //        Cookie cookie = new Cookie("key1", "newValue1");
    // 2、调用response.addCookie( Cookie ); 通知 客户端 保存修改
    //        resp.addCookie(cookie);
    //        resp.getWriter().write("key1的Cookie已经修改好");

    // 方案二：
    // 1、先查找到需要修改的Cookie对象
    Cookie cookie = CookieUtils.findCookie("key2", req.getCookies());
    if (cookie != null) {
        // 2、调用setValue()方法赋于新的Cookie值。
        cookie.setValue("newValue2");
        // 3、调用response.addCookie()通知客户端保存修改
        resp.addCookie(cookie);

        resp.getWriter().write("key2的Cookie已经修改好");
    }
}
```

### 9.6、浏览器查看cookie

![image-20211115173056434](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211115173056434.png)

### 9.7、cookie生命周期

cookie 的生命周期指的是如何管理 Cookie 什么时候被销毁（删除）

默认情况下，当浏览器关闭后，Cookie数据被销毁

持久化存储，使用Cookie对象的 `setMaxAge(int seconds)` 方法

`setMaxAge() `

- 正数：表示在指定的秒数后过期 
- 负数：表示浏览器一关，Cookie 就会被删除（默认值是-1） 
- 零：表示马上删除 Cookie

```java
protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie cookie = new Cookie("defaultLife", "defaultLife");
    cookie.setMaxAge(-1);
    resp.addCookie(cookie);
}

protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    // 先找到你要删除的Cookie对象
    Cookie cookie = CookieUtils.findCookie("key1", req.getCookies());

    if (cookie != null) {
        // 调用setMaxAge(0); 表示马上删除，都不需要等待浏览器关闭
        cookie.setMaxAge(0);
        resp.addCookie(cookie);
        resp.getWriter().write("key1的Cookie已经被删除");
    }
}

protected void life3600(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie cookie = new Cookie("life3600", "life3600");
    cookie.setMaxAge(60 * 60);
    resp.addCookie(cookie); // 设置Cookie一小时之后被删除。无效
    resp.getWriter().write("已经创建了一个存活一小时的Cookie");
}
```

### 9.8、Cookie的有效路径Path

Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 

path 属性是通过请求的地址来进行有效的过滤。 

CookieA path=/工程路径 

CookieB path=/工程路径/abc 

请求地址如下： 

http://ip:port/工程路径/a.html 				 CookieA 发送 	CookieB 不发送 

http://ip:port/工程路径/abc/a.html 		CookieA 发送 	CookieB 发送

#### 9.8.1、Cookie的共享问题

- 一个Tomcat服务器中，部署了多个web项目，这些web项目cookie的共享说明

默认情况cookie无法共享

使用Cookie对象的`setPath(String path)`方法设置cookie的获取范围

- 默认情况，参数是web工程路径，只有这个工程才可以访问到，其余工程无法访问
- 如果要共享，可以设置参数为“/” ( /被浏览器解析得到的地址为http://ip:port/ )

- 不同的Tomcat服务器间cookie的共享说明

使用Cookie对象的setDomain(String path)方法，参数设置为一级域名，则一级域名相同的不同服务器之间Cookie可共享

如：setDomain(“.baidu.com”)，则tieba.baidu.com与news.baidu.com等的cookie可共享

```java
protected void testPath(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    Cookie cookie = new Cookie("path1", "path1");
    // getContextPath() ===>>>>  得到工程路径
    cookie.setPath(req.getContextPath() + "/abc");
    resp.addCookie(cookie);
    resp.getWriter().write("创建了一个带有Path路径的Cookie");
}
```

###  9.9、Cookie 练习---免输入用户名登录

![image-20211115194100521](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211115194100521.png)

#### 9.9.1、login.jsp

```jsp
<form action="http://localhost:8080/13_cookie_session/loginServlet" method="get">
    用户名：<input type="text" name="username" value="${cookie.username.value}"> <br>
    密码：<input type="password" name="password"> <br>
    <input type="submit" value="登录">
</form>
```

#### 9.9.2、LoginServlet

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,
IOException {
    String username = req.getParameter("username");
    String password = req.getParameter("password");
    if ("wzg168".equals(username) && "123456".equals(password)) {
        //登录 成功
        Cookie cookie = new Cookie("username", username);
        cookie.setMaxAge(60 * 60 * 24 * 7);//当前 Cookie 一周内有效
        resp.addCookie(cookie);
        System.out.println("登录 成功");
    } else {
        // 登录 失败
        System.out.println("登录 失败");
    }
}
```

## 10、Session

1. Session 就一个接口（HttpSession）。 
2. Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 
3. 每个客户端都有自己的一个 Session 会话。 
4. Session 会话中，我们经常用来保存用户登录之后的信息。

### 10.1、如何创建 Session 和获取(id 号,是否为新)

如何创建和获取 Session。它们的 API 是一样的。 

`HttpSession session = request.getSession()`

request.getSession() 

​		第一次调用是：创建 Session 会话 

​		之后调用都是：获取前面创建好的 Session 会话对象。 

isNew(); 判断到底是不是刚创建出来的（新的） 

​		true 表示刚创建 

​		false 表示获取之前创建 

每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。 

getId() 得到 Session 的会话 id 值

```java
protected void createOrGetSession(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 创建和获取Session会话对象
    HttpSession session = request.getSession();

    // 判断 当前Session会话，是否是新创建出来的
    boolean isNew = session.isNew();

    // 获取Session会话的唯一标识 id
    String id = session.getId();
    response.getWriter().write("得到的session，它的id是：" + id + "<br/>");
    response.getWriter().write("这个Session是否是新创建的：" + isNew + " <br /> ");
}
```

### 10.2、Session 域数据的存取

**void setAttribute(String name, Object value)**
**Object getAttribute(String name)**
**void removeAttribute(String name)**

```java
protected void setAttribute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    request.getSession().setAttribute("key1", "value1");
    response.getWriter().write("已经往Session中保存了数据");
}

protected void getAttribute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    Object attribute = request.getSession().getAttribute("key1");
    response.getWriter().write("从Session中获取出key1的数据是：" + attribute);
}
```

### 10.3、 Session 生命周期

public void setMaxInactiveInterval(int interval) 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 

值为正数的时候，设定 Session 的超时时长。 

负数表示永不超时（极少使用） 

public int getMaxInactiveInterval()获取 Session 的超时时间 

5d6fpublic void invalidate() 让当前 Session 会话马上超时无效。

Session被销毁的方式

- 服务器关闭
- Session对象调用`invalidate()`

- Session默认失效时间：30分钟，可以到web.xml中修改配置文件修改默认失效时间

```xml
 <session-config>
     <session-timeout>30</session-timeout>
 </session-config>
```

**getMaxInactiveInterval()**
**setMaxInactiveInterval(int seconds)**

```java
/*
 * 如果希望你的web工程，默认的Session的超时时长为其他时长。
 * <session-config>
 *      <session-timeout>20</session-timeout>
 * </session-config>
 * 你可以在你自己的 web.xml 配置文件中做以上相同的配置，就可以修改你的 web 工程所有 Seession 的默认超时时长。
 */
protected void defaultLife(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 获取了Session的默认超时时长
    int maxInactiveInterval = request.getSession().getMaxInactiveInterval();
    response.getWriter().write("Session的默认超时时长为：" + maxInactiveInterval + " 秒");
}

protected void life3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 设置当前Session3秒后超时
    request.getSession().setMaxInactiveInterval(3);
    response.getWriter().write("当前Session已经设置为3秒后超时");
}

protected void deleteNow(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // 让Session会话马上超时
    request.getSession().invalidate();
    response.getWriter().write("Session已经设置为超时（无效）");
}
```

Session 超时的概念介绍：

![image-20211115202951887](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211115202951887.png)

### 10.4、浏览器和 Session 之间关联的技术内幕

Session 技术，底层其实是基于 Cookie 技术来实现的。

![image-20211115203148021](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211115203148021.png)

## 11、JavaBean

实体类

JavaBean有特定的写法

- 必须要有一个无参构造
- 属性必须私有化     
- 必须有对应的get与set方法

一般用来和数据库的字段进行映射	ORM：

ORM：对象映射关系

- 表——>类
- 字段——>属性
- 行记录——>对象

## 12、MVC三层架构

什么是MVC：Model、View、Controller		模型、视图、控制器

![image-20221229173853909](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221229173853909.png)

Model：

- 业务处理：业务逻辑（Service）
- 数据持久层：CRUD（Dao）

View

- 展示数据
- 提供链接发起Servlet请求（a、form、img...）

Controller

- 接收用户请求（req：请求参数、Session信息...）

- 交给业务层处理对应的代码

- 控制视图的跳转

  ```java
  登录——>接收用户的登录请求——>处理用户的请求（获取用户登录的参数、username、password）——>交给业务层处理登录业务（判断用户名是否正确：事务）——>Dao层查询用户名和密码是否正确——>数据库
  ```

## 13、Filter过滤器

### 13.1、Filter过滤器的介绍

1、Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器 

2、Filter 过滤器它是 JavaEE 的规范。也就是接口 

3、Filter 过滤器它的作用是：拦截请求，过滤响应。 

拦截请求常见的应用场景有：

1. 权限检查 
2. 日记操作 
3. 事务管理 
4. ……

***

### 13.2、Filter 的初体验

要求：在你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片、jsp 文件、等等）都必须是用户登录之后才允许访问。 

思考：根据之前我们学过内容。我们知道，用户登录之后都会把用户登录的信息保存到 Session 域中。所以要检查用户是否登录，可以判断 Session 中否包含有用户登录的信息即可！！！

```jsp
<%
Object user = session.getAttribute("user");
    // 如果等于 null，说明还没有登录
    if (user == null) {
        request.getRequestDispatcher("/login.jsp").forward(request,response);
        return;
    }
%>
```

#### 13.2.1、Filter 的工作流程图

![image-20211116192524416](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211116192524416.png)

#### 13.2.2、Filter过滤器的使用

1. 编写一个类实现Filter接口 **(导入的包为：javax.servlet.Filter)**

2. 实现三个方法

3. `doFilter()`实现过滤，此方法中的：filterChain.doFilter(servletRequest,servletResponse);只有执行此方法，才可以访问拦截路径中的资源，若未执行此方法则代表拦截

   `init()`

4. `destroy()`

5. web.xml中配置Filter的拦截路径，**拦截路径可以有多个**

#### 13.2.3、AdminFilter.java

```java
public class AdminFilter implements Filter {
    public AdminFilter() {
        System.out.println("这是1 Filter构造器方法 AdminFilter");
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("这是2 Filter init()方法 AdminFilter");
        
        // 获取 Filter 的名称 filter-name 的内容
        System.out.println("filter-name的值是：" + filterConfig.getFilterName());
        // 获取在 Filter 中配置的 init-param 初始化参数
        System.out.println("初始化参数 username 的值是：" + filterConfig
                           .getInitParameter("username"));
        System.out.println("初始化参数 url 的值是：" + filterConfig
                           .getInitParameter("url"));
        // 获取 ServletContext 对象
        System.out.println("ServletContext 的值是：" + filterConfig.getServletContext());
    }

    /**
     * 专门用于拦截请求 过滤响应，可以做权限检查
     */
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("这是2 Filter doFilter()方法 AdminFilter");

        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
        HttpSession session = httpServletRequest.getSession();

        Object user = session.getAttribute("user");

        if (user == null) {
            httpServletRequest.getRequestDispatcher("/login.jsp").forward(servletRequest, servletResponse);
            return;
        } else {
            // 让程序继续往下访问用户的目标资源，此句不能缺少
            filterChain.doFilter(servletRequest, servletResponse);
        }
    }

    @Override
    public void destroy() {
        System.out.println("这是2 Filter destroy()方法 AdminFilter");
    }
}
```

#### 13.2.4、web.xml

``` xml
<!-- filter标签用于配置一个Filter过滤器 -->
<filter>
  <!-- 别名 -->
  <filter-name>AdminFilter</filter-name>
  <!-- 全类名 -->
  <filter-class>com.atguigu.filter.AdminFilter</filter-class>
</filter>
<filter-mapping>
  <filter-name>AdminFilter</filter-name>
  <!-- 配置拦截路径 -->
  <!-- /          表示到映射到工程路径 http://ip:port/工程路径/ -->
  <!-- /admin/*   表示admin目录下的全部 -->
  <url-pattern>/admin/*</url-pattern>
</filter-mapping>
```

#### 13.2.5、login.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
这是登录页面 login.jsp
<form action="http://localhost:8080/filter/loginServlet" method="get">
    用户名：<input type="text" name="username"/> <br/>
    密  码：<input type="password" name="password"/> <br/>
    <input type="submit"/>
</form>
</body>
</html>
```

#### 13.2.6、LoginServlet.java

```java
public class LoginServlet  extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html; charset=UTF-8");

        String username = req.getParameter("username");
        String password = req.getParameter("password");

        if ("cess".equals(username) && "123123".equals(password)) {
            req.getSession().setAttribute("user", username);
            resp.getWriter().write("登录成功！");
        } else {
            req.getRequestDispatcher("login.jsp").forward(req, resp);
        }
    }
}
```

***

### 13.3、Filter过滤器的生命周期

Filter 的生命周期包含几个方法

1. 构造器方法
2. init 初始化方法

​			第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建）

3. doFilter 过滤方法

​			第 3 步，每次拦截到请求，就会执行

4. destroy 销毁

​			第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）

***

### 13.4、FilterConfig 类

FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 

Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。 

FilterConfig 类的作用是获取 filter 过滤器的配置内容 

1. 获取 Filter 的名称 filter-name 的内容 
2. 获取在 Filter 中配置的 init-param 初始化参数 
3. 获取 ServletContext 对象

```java
@Override
public void init(FilterConfig filterConfig) throws ServletException {
    System.out.println("2.Filter 的 init(FilterConfig filterConfig)初始化");
    // 1、获取 Filter 的名称 filter-name 的内容
    System.out.println("filter-name 的值是：" + filterConfig.getFilterName());
    // 2、获取在 web.xml 中配置的 init-param 初始化参数
    System.out.println("初始化参数 username 的值是：" + filterConfig.getInitParameter("username"));
    System.out.println("初始化参数 url 的值是：" + filterConfig.getInitParameter("url"));
    // 3、获取 ServletContext 对象
    System.out.println(filterConfig.getServletContext());
}
```

web.xml 配置

```xml
<!--filter 标签用于配置一个 Filter 过滤器-->
<filter>
    <!--给 filter 起一个别名-->
    <filter-name>AdminFilter</filter-name>
    <!--配置 filter 的全类名-->
    <filter-class>com.atguigu.filter.AdminFilter</filter-class>
    
    <init-param>
        <param-name>username</param-name>
        <param-value>root</param-value>
    </init-param>
    
    <init-param>
        <param-name>url</param-name>
        <param-value>jdbc:mysql://localhost3306/test</param-value>
    </init-param>
    
</filter>
```

### 13.5、FilterChain 过滤器链

Filter 过滤器 

Chain 链，链条 

FilterChain 就是过滤器链（多个过滤器如何一起工作）

![image-20211116201116886](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20211116201116886.png)

注意：

1. 上述两个Filter拦截的资源路径相同，代表一定会执行两个Filter过滤器的doFilter方法
2. 如果两个Filter拦截资源不同，且拦截资源符合Filter1，不符合Filter2，则会执行Filter1 的doFilter方法，且执行其中的chain.doFilter方法时，不会去执行Filter2的doFilter方法， 直接去访问资源，之后执行Filter1的后置代码(在chain.doFilter之后的均是后置代码)

3. 如果请求的资源不符合过滤器1和2的拦截路径，两个doFilter方法都不执行

4. 前置代码、chain.doFilter方法、后置代码都在doFilter方法中

***

### 13.6、Filter 的拦截路径

- 精确匹配 


```xml
<url-pattern>/target.jsp</url-pattern>
```

以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/target.jsp 

- 目录匹配 


```xml
<url-pattern>/admin/*</url-pattern>
```

以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/admin/* 

- 后缀名匹配 


```xml
<url-pattern>*.html</url-pattern>
```

以上配置的路径，表示请求地址必须以.html 结尾才会拦截到 

```xml
<url-pattern>*.do</url-pattern>
```

以上配置的路径，表示请求地址必须以.do 结尾才会拦截到 

```xml
<url-pattern>*.action</url-pattern>
```

以上配置的路径，表示请求地址必须以.action 结尾才会拦截到 

`Filter 过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在！！！`

## 14、Listener 监听器

### 14.1、Listener 监听器的介绍

1. Listener 监听器它是 JavaWeb 的三大组件之一。

   JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。 

2. Listener 它是 JavaEE 的规范，就是接口 

3. 监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。

### 14.2、ServletContextListener 监听器

ServletContextListener 监听器可以监听 ServletContext 对象的创建和销毁 (web 工程启动时创建，停止时销毁)，监听到创建和销毁之后都会调用 ServletContextListener 监听器的方法进行反馈：

```java
public interface ServletContextListener extends EventListener {
    //在ServletContext对象创建之后调用
    public void contextInitialized(ServletContextEvent sce);
    //在ServletContext对象销毁之后调用
    public void contextDestroyed(ServletContextEvent sce);
}
```

### 14.3、ServletContextListener 监听器的使用步骤

1. 编写一个类实现 ServletContextListener 接口
2. 重写两个方法

3. 在 web.xml 文件中配置监听器

代码演示 1：创建一个类

```java
public class ListenerTest implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象创建");
    }
    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象销毁");
    }
}
```

代码演示 2：在 web.xml 中配置

```xml
<listener>
    <!-- <listener-class>标签中写上述程序的全类名 -->
    <listener-class>com.qizegao.servlet.ListenerTest</listener-class>
</listener>
```

运行结果：
Tomcat 服务器启动之后控制台输出 ServletContext 对象创建
Tomcat 服务器停止之后控制台输出 ServletContext 对象销毁

**注意**

1. 查看翻译后的 Java 源文件的方法：启动 Tomcat 服务器访问到 JSP 页面之后在控制台输出的信息的前端找到 Using CATALINA_BASE 中的路径，在硬盘中打开此目录，点击 work --> Catalina --> localhost，找到对应的工程文件夹寻找即可
2. 访问 JSP 页面其实是在执行对应的翻译后的 Java 代码的_ jspService 方法：翻译后的 Java 类中没有 service 方法，而是重写了父类的_jspService 方法，这个方法会被父类的 service 方法调用

## 15、文件的上传与下载

文件的上传和下载，是非常常见的功能。很多的系统中，或者软件中都经常使用文件的上传和下载。 

比如：QQ头像，就使用了上传。 

邮箱中也有附件的上传和下载功能。 

OA系统中审批有附件材料的上传。

### 15.1、文件的上传介绍（重点）

1. 要有一个 form 标签，method=post 请求
2. form 标签的 encType 属性值必须为 multipart/form-data 值 
3. 在 form 标签中使用 input type=file 添加上传的文件 
4. 编写服务器代码（Servlet 程序）接收，处理上传的数据。

encType=multipart/form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的形式发送给服务器

#### 15.1.1、文件上传，HTTP协议的说明

![image-20211113223604269](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/MrdFQs1A5yLtEmS.png)

注意：谷歌浏览器中上传的文件的数据显示的是空行，但服务器可以接收到数据

#### 15.1.2、commons-fileupload.jar 常用 API 介绍说明

commons-fileupload.jar 需要依赖 commons-io.jar 这个包，所以两个包我们都要引入。 

第一步，就是需要导入两个 jar 包： (fileupload包依赖io包)

> - commons-fileupload-1.2.1.jar 
> - commons-io-1.4.jar

两个jar包中常用的类 (导入的jar包是commons的)

**ServletFileUpload类，用于解析上传的数据**

- ```java
  public static final boolean isMultipartContent(HttpServletRequest request)
  ```

  - 如果上传的数据是多段的形式，返回true，只有多段的数据才是文件上传的

- ```java
  public ServletFileUpload()
  ```

  - 空参构造器

- ```java
  public ServletFileUpload(FileItemFactory fileItemFactory)
  ```

  - 参数为工厂实现类的构造器

- ```java
  public List parseRequest(HttpServletRequest request)
  ```

  - 解析上传的数据，返回包含每一个表单项的List集合

**FileItem类，表示每一个表单项**

- ```java
  public boolean isFormField()
  ```

  - 如果当前表单项是普通表单项，返回true，如果上传的文件类型则返回false

- ```java
  public String getFieldName()
  ```

  - 获取当前表单项的name属性值

- ```java
  public String getString()
  ```

  - 获取当前表单项的value属性值，参数为”UTF-8”可解决乱码问题

- ```java
  public String getName()
  ```

  - 获取上传的文件名

- ```java
  public void write(File file)
  ```

  - 将上传的文件写到参数File所指向的硬盘位置

#### 15.1.3代码实现：

upload.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: DELL
  Date: 2021/11/13
  Time: 22:13
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<form action="http://localhost:8080/jsp/uploadServlet" method="post" enctype="multipart/form-data">
    用户名：<input type="text" name="username" ><br>
    头像：<input type="file" name="photo" ><br>
    <input type="submit" value="上传">
</form>
</body>
</html>

```

UploadServlet.java

```java
package com.chang.servlet;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileItemFactory;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.util.List;

public class UploadServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 先判断上传的数据是否多段数据（只有是多段的数据，才是文件上传的）
        if(ServletFileUpload.isMultipartContent(req)){
            // 创建FileItemFactory工厂实现类
            FileItemFactory fileItemFactory = new DiskFileItemFactory();
            // 创建用于解析上传数据的工具类ServletFileUpload类
            ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);
            try {
                // 解析上传的数据，得到每一个表单项FileItem
                List<FileItem> list = servletFileUpload.parseRequest(req);
                // 循环判断，每一个表单项，是普通类型，还是上传的文件
                for (FileItem fileItem : list) {
                    if (fileItem.isFormField()) {
                        // 普通表单项
                        System.out.println("表单项的name属性值：" + fileItem.getFieldName());
                        // 参数UTF-8.解决乱码问题
                        System.out.println("表单项的value属性值：" + fileItem.getString("UTF-8"));

                    } else {
                        // 上传的文件
                        System.out.println("表单项的name属性值：" + fileItem.getFieldName());
                        System.out.println("上传的文件名：" + fileItem.getName());
                        fileItem.write(new File("e:\\" + fileItem.getName()));
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    
    <servlet>
        <servlet-name>UploadServlet</servlet-name>
        <servlet-class>com.chang.servlet.UploadServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>UploadServlet</servlet-name>
        <url-pattern>/uploadServlet</url-pattern>
    </servlet-mapping>
</web-app>
```

### 15.2、文件的下载过程

![image-20221230101426244](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221230101426244.png)

- 获取要下载的文件名
- 获取要下载的文件类型

- 将获取的文件类型告诉客户端
- 告诉客户端收到的数据用于下载使用

- 获取要下载的文件并回传给客户端

#### 15.2.1、文件下载过程详解

1. 获取要下载的文件名：使用String定义要下载的文件名	
2. 获取要下载的文件类型：

​			通过ServletContext的`getMimeType()`参数是要下载的文件所在路径，返回值是String类型

3. 将获取的文件类型告诉客户端：

​			通过response的`setContentType()`参数是第二步的结果，无返回值

4. 告诉客户端收到的数据用于下载使用(没有此步则内容直接显示在页面上)：

​			通过response.`setHeader()`

​			参数是**"Content-Disposition", “attachment; fileName=xxx.xxx"**

​			注意：

​				Content-Disposition	响应头表示客户端收到的数据如何处理

​				attachment			表示附件，用于下载

​				filename				表示下载的文件名，可以与原文件名不同

5. 获取要下载的文件并回传给客户端：

​			回传给客户端通过导入的io包的IOUtils.`copy(InputStream input, OutputStream output)`

​			通过ServletContext的`getResourceAsStream()`参数是要下载的文件路径，得到输入流

​			通过response.`getOutputStream()`得到响应的输出流

#### 15.2.2、中文名下载文件的乱码问题

**原因**

response.setHeader(“Content-Disposition”, “attachment; fileName=中文名.jpg”);

如果下载的文件是中文名，会发现下载的文件无法正常显示汉字，原因是响应头中不能有汉字

**解决**

1. 当浏览器是IE浏览器或谷歌浏览器：

​				需要使用URLEncoder类先对中文名进行UTF-8编码，因为IE浏览器和谷歌浏览器收到含有 编码的字符串后会以UTF-8字符集进行解码显示

2. 当浏览器是火狐浏览器：使用BASE64编解码

​				BASE64编解码

#### 15.2.3代码实现：

DownLoad.java

```java
package com.chang.servlet;


import org.apache.commons.io.IOUtils;
import sun.misc.BASE64Encoder;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URLEncoder;

public class DownLoad extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1、获取要下载的文件名
        String downloadFileName = "2.png";
        //2、读取要下载的文件内容 (通过ServletContext对象可以读取)
        ServletContext servletContext = getServletContext();
        //3、获取要下载的文件类型
        String mimeType = servletContext.getMimeType("/file/" + downloadFileName);
        System.out.println("下载的文件类型：" + mimeType);
        //4、在回传前，通过响应头告诉客户端返回的数据类型
        resp.setContentType(mimeType);
        //5、还要告诉客户端收到的数据是用于下载使用（还是使用响应头）
        // Content-Disposition响应头，表示收到的数据怎么处理
        // attachment表示附件，表示下载使用
        // filename= 表示指定下载的文件名
        // url编码是把汉字转换成为%xx%xx的格式
        if (req.getHeader("User-Agent").contains("Firefox")) {
            // 如果是火狐浏览器使用Base64编码
            resp.setHeader("Content-Disposition", "attachment; filename==?UTF-8?B?" + new BASE64Encoder().encode("中国.jpg".getBytes("UTF-8")) + "?=");
        } else {
            // 如果不是火狐，是IE或谷歌，使用URL编码操作
            resp.setHeader("Content-Disposition", "attachment; filename=" + downloadFileName);
//            resp.setHeader("Content-Disposition", "attachment; filename=" + URLEncoder.encode("中国.jpg", "UTF-8"));
        }

        //只有后面三行代码可以实现在浏览器中获取请求的文件资源，因此需要前面的代码告知如何处理
        //斜杠被服务器解析表示地址为http://ip:port/工程名 映射 到代码的web目录
        InputStream resourceAsStream=servletContext.getResourceAsStream("/file/"+downloadFileName);
        //获取相应的输出流
        OutputStream outputStream= resp.getOutputStream();
        //使用commons-io这个包中的IOUtils实现读入与写出
        IOUtils.copy(resourceAsStream,outputStream);
    }
}

```

web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <servlet>
        <servlet-name>printHtml</servlet-name>
        <servlet-class>com.chang.servlet.PrintHtml</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>printHtml</servlet-name>
        <url-pattern>/printHtml</url-pattern>
    </servlet-mapping>
    
    <servlet>
        <servlet-name>UploadServlet</servlet-name>
        <servlet-class>com.chang.servlet.UploadServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>UploadServlet</servlet-name>
        <url-pattern>/uploadServlet</url-pattern>
    </servlet-mapping>
    
    <servlet>
        <servlet-name>download</servlet-name>
        <servlet-class>com.chang.servlet.DownLoad</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>download</servlet-name>
        <url-pattern>/download</url-pattern>
    </servlet-mapping>
</web-app>
```



  





