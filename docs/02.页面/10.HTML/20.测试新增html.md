---
title: 测试新增html
date: 2023-01-30 19:55:13
permalink: /pages/f45b1c/
categories:
  - 页面
  - HTML
tags:
  - 
---

# 标题1

你好

## 标题2

你好吗？


# 1、Java基础复习

## 1、Java常识

![image-20220925202327938](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20220925202327938.png)

![image-20220925210658844](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20220925210658844.png)

JavaSE：18~20

数据库：4

前端：7

JavaWeb：7

SSM框架：9

Linux：7

SpringBoot：8

SpringCloud：7

Hadoop：8 

***

JavaSE：标准版（桌面程序、控制台开发...）

JavaME：嵌入式开发（手机、小家电...）

JavaEE：企业级开发（web端、服务器开发...）

***

JDK：Java开发者工具

JRE：Java运行时环境

JVM：Java虚拟机

***

Java在cmd中运行 Hello.java

```bash
#首先进入对应文件夹，编译源代码，使用javac生成class文件 
javac Hello.java

#运行class文件
java Hello
```

***

![image-20220925220616278](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20220925220616278.png)

## 2、常用Doc

```bash
#切换盘符
D:

#查看当前目录下的文件
dir

#切换目录
cd
cd /d f:
cd /d E:\ide
cd ..

#清理屏幕
cls

#退出终端 
exit

#查看ip
ipconfig

#打开应用
calc
mspaint
notepad

#ping 命令
ping www.baidu.com

#创建目录
md test

#创建一个文件
cd>a.txt

#删除一个文件
del a.txt

#删除目录
rd test
```

## 3、Java基础知识

### 1、注释

单行注释：//

多行注释：/*   */

文本注释：/**

​							*@Description Hello

​							*@Description World

​							*/

​						[有趣的代码注释整理](https://blog.csdn.net/ydk888888/article/details/81563608)

### 2、标识符

Java中的类名、变量名以及方法名都被称为标识符

关键字不能做标识符

### 3、类型

基本数据类型：byte（1字节）、short（2）、int（4） 、long（8 | 30L）、float（4 | 10.2F）、

​								   double（8 |  3.1415926）、char（2）、boolean（1位）

引用数据类型：类、数组、接口

位（bit）：是计算机 `内部数据` 存储的最小单位，11101100是一个八位的二进制数

字节（byte）：是计算机中 `数据处理` 的基本单位，习惯上用大写B来表示

1B = 8bit

字符：是指计算机中使用的字母、数字、字和符号

### 4、数据类型扩展

JDK7新特性，数字之间可以使用下划线进行分割：int money = 10_0000_0000; 

当数据溢出int时，会出现负数

二进制：0b

十进制

八进制：0

十六进制：0x	0~9 A~F

```java
int i=10;		//10
int i2=010;		//8
int i3=0x10;	//16
```

***

浮点数存在舍入误差，接近但不等于

银行业务等最好使用**`BigDecimal`**这个数学工具类比较

***

字符char：A=65，a=97

转义字符：\t 制表符    \n换行

### 5、变量

要素包括变量名、变量类型、作用域

成员变量：

- 成员变量在类的范围里定义的的变量
- 成员变量有默认的初始值
- 未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同
- 被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同

局部变量

- 局部变量是在方法里定义的变量

- 局部变量是没有默认初始值

- 局部变量存储于栈内存中，作用范围结束，变量空间会自动释放

### 6、JavaDOC

JavaDoc命令用来生成自己API文档的

- @author	作者名
- @version	版本号
- @since		指明需要最早使用的jdk版本
- @param	 参数名
- @return	  返回值情况
- @throws	 异常抛出情况

```bash
javadoc -encoding UTF-8 -charset UTF-8 Doc.java
```

javadoc 参数 java文件

### 7、命令行传参

有时候希望运行一个程序时候再给它传消息，这要靠传递命令行参数给main()函数实现

```java
package com.chang;

public class Main {
    public static void main(String[] args) {
        for(int i=0;i<args.length;i++){
            System.out.println("args["+i+"]:"+args[i]);
        }
    }
}
```

```shell
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java\com\chang> javac Main.java
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java\com\chang> cd ../
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java\com> cd ../
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java> java com.chang.Main
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java> java com.chang.Main Hello World !
args[0]:Hello
args[1]:World
args[2]:!
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java>
```


### 8、可变参数

在JDK1.5开始，Java支持传递同类型的可变参数给一个方法

在方法的声明中，在指定参数**类型**后加一个省略号（...）

一个方法只能指定一个可变参数，它必须是方法的**最后一个参数**。任何普通的参数必须在它之前声明。

```java
public class Main {
    public static void main(String[] args) {
        //两种传参方法
        double res=getALL(10.5,new int[]{1,2,3});
        double res=getALL(10.5,1,2,3);
        System.out.println(res);
    }

    public static double getALL(double f,int... num){
        //输出可变参数的长度
        System.out.println(num.length);
        
        for(int i : num){
            //强制基本类型数据的类型转换  int ——> double
            f+=i;
        }
        
        return f;
    }
}
```

## 4、注解与反射

注解不是程序本身，可以对程序做出解释，可以被其他程序（比如：编译器等）读取

注解Annotation是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：

```java
@SuppressWarnings(value="unchecked")
```

### 1、元注解

元注解就是负责注解其他注解，Java中定义了4个标准的meta-annotation类型，它们被用来提供对其他的annotation类型进行说明

这些类型和它们所支持的类在Java.lang.annotation包中找到

- @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）
- @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE<CLASS<**RUNTIME**）
- @Document：说明该注解被包含在javadoc中
- @Inherited：说明子类可以继承父类中的该注解

### 2、自定义注解

使用@interface自定义注解，自动继承java.lang.annotation.Annotation接口

分析：

- @interface用来声明一个注解，格式：public @interface 注解名 {定义内容}
- 其中的每一个方法实际上声明了一个配置参数
- 方法的名称就是参数的名称
- 返回值类型就是参数的类型，返回值只能是基本类型Class、String、enum
- 可以通过default来声明参数的默认值
- 如果只有一个参数成员，一般参数名未value
- 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值 

```java
package com.chang.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

public class Test03 {
    //注解可以显示赋值，如果没有默认值，我们必须给注解赋值
//    @MyAnnotation2(name="zhangChang",schools = {"西安交大、西安电子"})
    @MyAnnotation2()
    public void test(){

    }

    @MyAnnotation3("niHao")
    public void test2(){

    }
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation2{
    //注解的参数：参数类型 + 参数名() default 默认值
    String name() default "";
    int age() default 0;
    int id() default -1;//如果默认值为-1，代表找不到、不存在

    String[] schools() default {"西安交大、西安电子"};
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation3{
    String value();
}
```

### 3、反射概述

Java.Reflection

动态语言是一类在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的改变，通俗点说就是在运行时代码可以根据某些条件改变自身的结构

主要的动态语言：Object-C、C#、JavaScript、PHP、Python等

静态语言与动态语言相对应，运行时结构不可变的语言就是静态语言。如Java、C、C++

Java不是动态语言，但Java可以被称为“准动态语言”。即java有一定的动态性。我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活

Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行 期间借助于Reflection API获取任何类的内部信息，并能直接操作任意对象的内部属性及方法

```java
Class c = Class.forName("java.lang.String")
```

加载完类后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称为反射。

正常方式：引入需要的“包类”名称——>通过new关键字实例化——>取得实例化对象

反射方式：实例化对象——>getClass()方法——>取得完整的“包类”名称

反射的优点：可以实现动态创建对象和编译，体现很大的灵活性。

反射的缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。

```java
java.lang.Class：代表一个类
java.lang.reflect.Method：代表类的方法
java.lang.reflect.Field：代表类的成员变量
java.lang.reflect.Constructor：代表类的构造器
```

### 4、获取Class类的实例

1. 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高

   ```java
   Class clazz = Person.class; 
   ```

2. 已知某个类的实例，调用该实例的getClass()方法获取class对象

   ```java
   Class clazz = person.getClass();
   ```

3. 已知一个类的全名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException

   ```java
   Class clazz = Class.forName("com.compue.Student");
   ```

4. 内置基本数据类型的包装类可以直接使用类名.type

5. 还可以利用ClassLoader

### 5、哪些类型可以有class对象

class：外部类、成员（成员内部类、静态内部类）、局部内部类、匿名内部类

interface：接口

[]：数组

enum：枚举

annotation：注解@interface

primitive type：基本数据类型

void

### 6、什么时候发生类的初始化

- 类的主动引用：
  - 当虚拟机启动，先初始化main方法所在的类
  - new一个类的对象
  - 调用类的静态成员（除了final常量）和静态方法
  - 使用java.lang.reflect包的方法对类进行反射调用
  - 当初始化一个类，如果父类没有被初始化，则先初始化它的父类
- 类的被动引用（不会发生类的初始化）：
  - 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化
  - 通过数组定义类引用，不会触发此类的初始化
  - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）

### 7、使用反射调用注解

```java
package com.chang.annotation;

import java.lang.annotation.*;
import java.lang.reflect.Field;

//练习反射操作注解
public class Test04 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
        Class<?> c1 = Class.forName("com.chang.annotation.Students");

        //通过反射获取注解
        Annotation[] annotations = c1.getAnnotations();
        for(Annotation annotation:annotations){
            System.out.println(annotation);
        }

        //获得注解的value的值
        TableStudents tableStudents = c1.getAnnotation(TableStudents.class);
        String value = tableStudents.value();
        System.out.println(value);

        //获得类指定的注解
        Field f = c1.getDeclaredField("name");
        FieldStudents fieldStudents = f.getAnnotation(FieldStudents.class);
        System.out.println(fieldStudents.columnName());
        System.out.println(fieldStudents.type());
        System.out.println(fieldStudents.length());
    }
}

//类名的注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface TableStudents{
    String value();
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface FieldStudents{
    String columnName();
    String type();
    int length();
}

@TableStudents("db_student")
class Students{
    @FieldStudents(columnName = "db_id",type = "int",length = 10)
    private int id;
    @FieldStudents(columnName = "db_age",type = "int",length = 10)
    private int age;
    @FieldStudents(columnName = "db_name",type = "varchar",length = 10)
    private String name;

    public Students() {
    }

    public Students(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Students{" +
                "id=" + id +
                ", age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}

/*
@com.chang.annotation.TableStudents(value=db_student)
db_student
db_name
varchar
10
*/
```

