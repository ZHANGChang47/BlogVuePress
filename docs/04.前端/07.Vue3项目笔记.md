---
title: Vue3项目笔记
date: 2023-02-03 23:27:27
permalink: /pages/35ef2b/
categories:
  - 前端
tags:
  - 
---
# Vue3项目笔记

## 1、Vite构建vue3项目

[开始 | Vite 官方中文文档 (vitejs.dev)](https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project)

### 1.1、项目构建

在项目中安装指定一个文件然后使用vite构建项目

```bash
# yarn
yarn create vite my-vue --template vue
```

![image-20221211225811945](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221211225811945.png)

### 1.2、依赖安装

然后进入my-vue这个目录安装相应依赖，可以看到my-vue下出现了一个node_modules文件夹

```bash
PS C:\Users\DELL\Desktop\backstage-app-Vue3> cd .\my-vue\
PS C:\Users\DELL\Desktop\backstage-app-Vue3\my-vue> yarn install
```

![image-20221211225958846](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221211225958846.png)

如果有格式上的报错，可以在vscode中的设置搜索eslint，然后关闭Vetur>Validation:Template

![image-20221211230708714](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221211230708714.png)

### 1.3、项目启动

使用如下命令启动：

```bash
yarn dev
```

![image-20221211231933377](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221211231933377.png)

## 2、element-plus引入

### 2.1、安装：

```bash
yarn add element-plus -S
```

### 2.2、完整引入

在main.js中引入element-plus：

```js
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

const app = createApp(App)

//完整引入element-plus
app.use(ElementPlus)
app.mount('#app')
```

### 2.3、按需引入

首先安装两个插件：

```bash
cnpm install -D unplugin-vue-components unplugin-auto-import
```

然后根据打包工具（Vite或者Webpack）选择不同的引入方式

在vit.config.js中导入插件

vit.config.js：

```js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'


// https://vitejs.dev/config/
export default defineConfig({
  //插件以数组形式存放
  plugins: [
    vue(),
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
})
```

相应的注释掉之前完整引入时main.js中的代码

main.js

```js
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
// import ElementPlus from 'element-plus'
// import 'element-plus/dist/index.css'

const app = createApp(App)

//完整引入element-plus
// app.use(ElementPlus)
app.mount('#app')
```

**上述为完整引入与按需引入，如需或者手动引入参考[Element Plus官网)](https://element-plus.gitee.io/zh-CN/guide/quickstart.html#按需导入)**

## 3、vue-router引入

### 3.1、安装

```bash
yarn add vue-router
```

### 3.2、创建目录

- 在src目录下创建router文件夹以及index.js配置文件
- 在src目录下创建views文件夹以及Main.vue作为主路由访问的组件，然后在views中创建home文件夹以及其中的home.vue作为子路由访问的组件

![image-20221211234754403](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221211234754403.png)

### 3.3、配置文件

#### 3.3.1、在router/index.js设置具体路由

router/index.js：

```js
//按需引入，createWebHashHistory使用路由的方式
import {createRouter, createWebHashHistory} from 'vue-router'

//定义routes作为路由的配置
const routes = [
    {
        path: '/',
        component:()=>import('../views/Main.vue'),
        children:[
            {
                path: '/',
                name: 'home',
                component:()=>import('../views/home/home.vue')
            }
        ]
    }
]

const router = createRouter({
    history:createWebHashHistory(),
    routes
})

export default router
```

#### 3.3.2、在main.js引入暴露的路由

main.js

```js
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import router from './router'
// import ElementPlus from 'element-plus'
// import 'element-plus/dist/index.css'

const app = createApp(App)
app.use(router)
//完整引入element-plus
// app.use(ElementPlus)
app.mount('#app')
```

#### 3.3.3、在App.vue中引入路由标签

\<router-view /\>

App.vue：

```vue
<script setup>
import HelloWorld from './components/HelloWorld.vue'
</script>

<template>
  <router-view />
</template>

<style scoped>
.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vue:hover {
  filter: drop-shadow(0 0 2em #42b883aa);
}
</style>
```

#### 3.3.4、在Main.vue中引入路由标签

Main.vue：

```vue
<template>
  <div>
    左侧菜单
  </div>
  <div>
    头部
  </div>
  <div>
    这个部分是变化的
    <router-view />
  </div>
</template>

<script>
export default {

}
</script>

<style>

</style>
```

#### 3.3.5、home.vue不需要路由标签

home.vue：

```vue
<template>
  <h1>我是home组件</h1>
</template>

<script>
export default {

}
</script>

<style>

</style>
```

![image-20221212000005563](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212000005563.png)

## 4、vue图标使用

### 4.1、container布局

首先修改Main.vue中的代码，完成基础的页面布局，并在其中引入CommonHeader.vue组件，该组件位于Components文件夹下：

Main.vue：

```vue
<template>
  <div class="common-layout">
    <el-container>
      <el-aside width="200px">Aside</el-aside>
      <el-container>
        <el-header>
          <common-header />
        </el-header>
        <el-main>
          <router-view />
        </el-main>
      </el-container>
    </el-container>
  </div>
</template>

<script>
import {defineComponent} from "vue";
import CommonHeader from "../components/CommonHeader.vue";
export default defineComponent({
  components:{
    CommonHeader
  }
});
</script>

<style>

</style>
```

### 4.2、引入安装图标

#### 4.2.1、安装

```bash
yarn add @element-plus/icons-vue@2.0.6
```

#### 4.2.2、注册

main.js

```js
import * as ElementPlusIconsVue from '@element-plus/icons-vue'

for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component)
}
```

![image-20221212160113339](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212160113339.png)

#### 4.2.3、使用

```html
<el-icon :size="40" >
	<Menu />
</el-icon>
```

CommonHeader.vue：

```vue
<template>
    <el-header>
        <div class="l-content">
            <!-- 图标的展示 -->
            <el-icon :size="40" >
                <Menu />
            </el-icon>
        </div>
        <div class="r-content">
            
        </div>
    </el-header> 
</template>
```

![image-20221212160720214](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212160720214.png)

#### 4.2.4、将图标在按钮中嵌套

CommonHeader.vue：

```vue
<template>
    <el-header>
        <div class="l-content">
            <!-- 图标的展示 -->
            <el-button size="small">
                <el-icon :size="20">
                    <Menu />
                </el-icon>
            </el-button>
        </div>
        <div class="r-content">

        </div>
    </el-header>
</template>
```

![image-20221212161126000](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212161126000.png)

## 5、header组件的下拉菜单

### 5.1、less安装

设置样式时用到了less

```bash
yarn add less@4.1.3 less-loader@11.0.0
```

### 5.2、下拉菜单

```html
			<el-dropdown>
                <span class="el-dropdown-link">
                    <img class="user" src="../assets/images/user.png" alt=""/>
                </span>
                <template #dropdown>
                <el-dropdown-menu>
                    <el-dropdown-item>个人中心</el-dropdown-item>
                    <el-dropdown-item>退出</el-dropdown-item>
                </el-dropdown-menu>
                </template>
            </el-dropdown>
```

### 5.3、CSS样式

```css
<style lang="less" scoped>
header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    width:100%;
}
.r-content {
    .user{
        width:40px;
        height:40px;
        border-radius: 50%;
    }
}
</style>
```

![image-20221212163320884](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212163320884.png)

## 6、静态资源的动态引入

将header中的静态图片以动态的方式添加

在script中定义getImgSrc方法，允许传入user参数，次参数指代图片的名字，使用es6提供的模板语法以及URL对象完成静态资源的动态导入。

在具体使用时，要指定传入图片的名字

CommonHeader.vue

```vue
<template>
    <el-header>
        <div class="l-content">
            <!-- 图标的展示 -->
            <el-button size="small">
                <el-icon :size="20">
                    <Menu />
                </el-icon>
            </el-button>
        </div>
        <div class="r-content">
            <el-dropdown>
                <span class="el-dropdown-link">
                    <img class="user" :src="getImgSrc('user')" alt=""/>
                </span>
                <template #dropdown>
                <el-dropdown-menu>
                    <el-dropdown-item>个人中心</el-dropdown-item>
                    <el-dropdown-item>退出</el-dropdown-item>
                </el-dropdown-menu>
                </template>
            </el-dropdown>
        </div>
    </el-header>
</template>

<script>
export default {
    //vue3中用到的变量都存放在setup()中
    setup(){
        //定义了获取图片的方法，``是Es6提供的动态模板写法
        //URL()构造函数返回一个新创建的URL对象，表示由一组参数定义的URL
        const getImgSrc = (user)=>{
            return new URL(`../assets/images/${user}.png`,import.meta.url).href
        };
        return{ 
            getImgSrc,
        }
    }
}
</script>

<style lang="less" scoped>
header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    width:100%;
}
.r-content {
    .user{
        width:40px;
        height:40px;
        border-radius: 50%;
    }
}
</style>
```

## 7、左侧菜单栏实现

在components文件夹中创建CommonAside.vue组件，然后在Main.vue中引入并替换掉之前的代码

Main.vue：

```vue
<template>
  <div class="common-layout">
    <el-container>
      <common-aside />
      <el-container>
        <el-header>
          <common-header />
        </el-header>
        <el-main>
          <router-view />
        </el-main>
      </el-container>
    </el-container>
  </div>
</template>

<script>
import {defineComponent} from "vue";
import CommonHeader from "../components/CommonHeader.vue";
import CommonAside from "../components/CommonAside.vue";
export default defineComponent({
  components:{
    CommonHeader,
    CommonAside,    
  }
});
</script>

<style>

</style>
```

### 7.1、动态引入图标

```html
<component class="icons" :is="item.icon"></component>
```

### 7.2、实现侧边栏

将要填充的数据根据是否有子菜单进行分类，与vue2一样，仍然使用filter函数

分完类的数据使用v-for进行循环遍历

CommonAside.vue：

```vue
<template>
    <el-aside width="200px">
        <el-menu class="el-menu-vertical-demo" background-color="#545c64" text-color="#fff" :collapse="false">
            <el-menu-item :index="item.path" v-for="item in noChildren()" :key="item.path">
                <!-- <el-icon><icon-menu /></el-icon> -->
                <!-- 动态引入icon -->
                <component class="icons" :is="item.icon"></component>
                <span>{{item.label}}</span>
            </el-menu-item>
            <el-sub-menu :index="item.label" v-for="item in hasChildren()" :key="item.path">
                <template #title>
                    <component class="icons" :is="item.icon"></component>
                    <span>{{item.label}}</span>
                </template>
                <el-menu-item-group>
                    <el-menu-item :index="subItem.path" v-for="(subItem,subIndex) in item.children" :key="subIndex">
                        <component class="icons" :is="subItem.icon"></component>
                        <span>{{subItem.label}}</span>
                    </el-menu-item>
                </el-menu-item-group>
            </el-sub-menu>
        </el-menu>

    </el-aside>
</template>

<script>
export default {
    setup() {
        const list = [
            {
                path: "/user",
                name: "user",
                label: "用户管理",
                icon: "user",
                url: "UserManage/UserManage",
            },
            {
                label: "其他",
                icon: "location",
                path: "/other",
                children: [
                    {
                        path: "/page1",
                        name: "page1",
                        label: "页面1",
                        icon: "setting",
                        url: "Other/PageOne",
                    },
                    {
                        path: "/page2",
                        name: "page2",
                        label: "页面2",
                        icon: "setting",
                        url: "Other/PageTwo",
                    },
                ],
            },
        ];

        const noChildren = () => {
            return list.filter((item) => !item.children);
        };

        const hasChildren = () => {
            return list.filter((item) => item.children);
        };

        return {
            noChildren,
            hasChildren,
        }
    }
}
</script>

<style lang="less" scoped>
.icons{
    width: 18px;
    height: 18px;
    margin-right: 10px;
}

</style>
```

## 8、样式修改

首先在assets文件夹下创建less文件夹，然后创建index.less文件，以及reset.less文件，用来设定一些基本的样式

在index.less中导入reset.less

### 8.1、index.less

```less
@import './reset.less';
```

### 8.2、reset.less

```less
html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
  box-sizing: border-box;
}

/* HTML5 display-role reset for older browsers */
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
menu,
nav,
section {
  display: block;
}

body {
  line-height: 1;
}

ol,
ul {
  list-style: none;
}

blockquote,
q {
  quotes: none;
}

blockquote:before,
blockquote:after,
q:before,
q:after {
  content: '';
  content: none;
}

a,
a:hover {
  color: inherit;
  text-decoration: none;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

html,
body {
  width: 100%;
  height: 100%;
  background-color: #f5f5f5;
  font-family: 'PingFangSC-Light', 'PingFang SC', 'STHeitiSC-Light', 'Helvetica-Light', 'Arial', 'sans-serif';
}

body {
  overflow: hidden;
}

// 公共样式
.fl {
  float: left;
}

.fr {
  float: right;

  .button-group-item {
    padding-left: 3px;
  }
}

//清除浮动
.clearfix {
  zoom: 1;

  &:after {
    display: block;
    clear: both;
    content: "";
    visibility: hidden;
    height: 0;
  }
}
```

在App.vue中设定高度为100%，**注意不能添加scoped！！！**

### 8.3、App.vue

```vue
<script setup>

</script>

<template>
  <router-view />
</template>

<style>
#app{
  height:100%;
}
</style>
```

然后在Main.vue中同样添加高度

### 8.4、Main.vue

```vue
<template>
  <div class="common-layout">
    <el-container >
      <common-aside />
      <el-container>
        <el-header>
          <common-header />
        </el-header>
        <el-main>
          <router-view />
        </el-main>
      </el-container>
    </el-container>
  </div>
</template>

<script>
import {defineComponent} from "vue";
import CommonHeader from "../components/CommonHeader.vue";
import CommonAside from "../components/CommonAside.vue";
export default defineComponent({
  components:{
    CommonHeader,
    CommonAside,    
  }
});
</script>

<style lang="less" scoped>

.common-layout{
  height: 100%;
  .el-container{
    height: 100%;
    .el-aside{
      height: 100%;
      background: #545c64;
    }
    .el-header{
      padding:0px;
    }
    .el-main{
      padding:0 20px;
    }
  }
}

</style>
```

在CommonHeader.vue中设定相应的样式属性

### 8.5、CommonHeader.vue

```vue
<template>
    <el-header>
        <div class="l-content">
            <!-- 图标的展示 -->
            <el-button size="small">
                <el-icon :size="20">
                    <Menu />
                </el-icon>
            </el-button>
            <h3>首页</h3>
        </div>
        <div class="r-content">
            <el-dropdown>
                <span class="el-dropdown-link">
                    <img class="user" :src="getImgSrc('user')" alt=""/>
                </span>
                <template #dropdown>
                <el-dropdown-menu>
                    <el-dropdown-item>个人中心</el-dropdown-item>
                    <el-dropdown-item>退出</el-dropdown-item>
                </el-dropdown-menu>
                </template>
            </el-dropdown>
        </div>
    </el-header>
</template>

<script>
export default {
    //vue3中用到的变量都存放在setup()中
    setup(){
        //定义了获取图片的方法，``是Es6提供的动态模板写法
        //URL()构造函数返回一个新创建的URL对象，表示由一组参数定义的URL
        const getImgSrc = (user)=>{
            return new URL(`../assets/images/${user}.png`,import.meta.url).href
        };
        return{ 
            getImgSrc,
        }
    }
}
</script>

<style lang="less" scoped>
.el-header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    width:100%;
    background:#333;
    padding: 0px;
}
.r-content {
    .user{
        width:40px;
        height:40px;
        border-radius: 50%;
        margin-right: 30px;
    }
}
.l-content {
  display: flex;
  align-items: center;
  .el-button {
    margin:0 20px;
  }
  h3 {
    color: #fff;
  }
}
</style>
```

CommonAside.vue中也需要做些修改，例如将边界上的线取消掉

### 8.5、CommonAside.vue

```vue
<template>
    <el-aside width="180px">
        <el-menu class="el-menu-vertical-demo" background-color="#545c64" text-color="#fff" :collapse="false">
            <el-menu-item :index="item.path" v-for="item in noChildren()" :key="item.path">
                <!-- <el-icon><icon-menu /></el-icon> -->
                <!-- 动态引入icon -->
                <component class="icons" :is="item.icon"></component>
                <span>{{item.label}}</span>
            </el-menu-item>
            <el-sub-menu :index="item.label" v-for="item in hasChildren()" :key="item.path">
                <template #title>
                    <component class="icons" :is="item.icon"></component>
                    <span>{{item.label}}</span>
                </template>
                <el-menu-item-group>
                    <el-menu-item :index="subItem.path" v-for="(subItem,subIndex) in item.children" :key="subIndex">
                        <component class="icons" :is="subItem.icon"></component>
                        <span>{{subItem.label}}</span>
                    </el-menu-item>
                </el-menu-item-group>
            </el-sub-menu>
        </el-menu>

    </el-aside>
</template>

<script>
export default {
    setup() {
        const list = [
            {
                path: "/user",
                name: "user",
                label: "用户管理",
                icon: "user",
                url: "UserManage/UserManage",
            },
            {
                label: "其他",
                icon: "location",
                path: "/other",
                children: [
                    {
                        path: "/page1",
                        name: "page1",
                        label: "页面1",
                        icon: "setting",
                        url: "Other/PageOne",
                    },
                    {
                        path: "/page2",
                        name: "page2",
                        label: "页面2",
                        icon: "setting",
                        url: "Other/PageTwo",
                    },
                ],
            },
        ];

        const noChildren = () => {
            return list.filter((item) => !item.children);
        };

        const hasChildren = () => {
            return list.filter((item) => item.children);
        };

        return {
            noChildren,
            hasChildren,
        }
    }
}
</script>

<style lang="less" scoped>
.icons{
    width: 18px;
    height: 18px;
    margin-right: 10px;
}
.el-menu{
    border-right: none;
    h3 {
        line-height: 48px;
        color: #fff;
        text-align: center;
    }
}
</style>
```

## 9、vuex在不同组件之间传递数据

使用vuex实现侧边栏折叠变化

### 9.1、安装

```bash
yarn add vuex@4.0.2
```

### 9.2、创建路径及引入

在src目录下创建store文件夹，并在此文件夹下创建index.js文件，其中state用来存放数据，mutations用来存放方法，payload代指传进来的参数

#### 9.2.1、index.js

```js
import { createStore } from 'vuex'

export default createStore({
    state: {
        isCollapse: true
    },
    mutations: {
        updateIsCollapse(state,payload){
            state.isCollapse = !state.isCollapse
        }
    }
})
```

然后在main.js中引入stroe，并且use使用

#### 9.2.2、main.js

```js
import store from './store/index.js'

app.use(store)
```

![image-20221212211334051](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212211334051.png)

### 9.3、静态获取store中的数据

```html
:collapse="!$store.state.isCollapse"

<el-aside :width="$store.state.isCollapse ? '180px' : '64px' ">
```

#### 9.3.1、CommonAside.vue

![image-20221212211509547](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212211509547.png)

补充：

#### 9.3.2、使用v-show，根据条件动态展示标题

![image-20221212214050953](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212214050953.png)

### 9.4、动态调用store中方法

首先在指定位置给定调用store方法的方法，例如：

CommonHeader.vue：

```html
<el-button size="small" plain @click="handleCollapse">
```

然后在下面的store中编写内容

- 从vuex导入useStore
- 使用useStore创建store对象
- 使用store的commit方法调用store中的同名方法

CommonHeader.vue：

```js
<script>
import { defineComponent } from "vue-demi";
import { useStore } from "vuex";
export default defineComponent({
    //vue3中用到的变量都存放在setup()中
    setup() {
        let store = useStore();
        //定义了获取图片的方法，``是Es6提供的动态模板写法
        //URL()构造函数返回一个新创建的URL对象，表示由一组参数定义的URL
        let getImgSrc = (user) => {
            return new URL(`../assets/images/${user}.png`, import.meta.url).href
        };
        let handleCollapse = () => {
            // 调用vuex中的mutations
            store.commit("updateIsCollapse");
        };
        return {
            getImgSrc,
            handleCollapse,
        }
    }
})
</script>
```

![image-20221212213154797](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212213154797.png)

## 10、vue-router路由跳转

为相应标签添加点击跳转路由的方法 @click="clickMenu(item)"

CommonAside.vue

![image-20221212220840760](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212220840760.png)

在script标签中补全方法，首先导入vue-router，然后使用userRouter创建router对象，使用router.push(对象)进行跳转

```js
<script>
import {useRouter} from 'vue-router';
export default {
    setup() {
        const list = [
            {
                path: "/user",
                name: "user",
                label: "用户管理",
                icon: "user",
                url: "UserManage/UserManage",
            },
            {
                label: "其他",
                icon: "location",
                path: "/other",
                children: [
                    {
                        path: "/page1",
                        name: "page1",
                        label: "页面1",
                        icon: "setting",
                        url: "Other/PageOne",
                    },
                    {
                        path: "/page2",
                        name: "page2",
                        label: "页面2",
                        icon: "setting",
                        url: "Other/PageTwo",
                    }
                ],
            },
        ];

        const router = useRouter();

        const noChildren = () => {
            return list.filter((item) => !item.children);
        };

        const hasChildren = () => {
            return list.filter((item) => item.children);
        };

        const clickMenu = (item) => {
            router.push({
                name:item.name,
            });
        };

        return {
            noChildren,
            hasChildren,
            clickMenu,
        }
    }
}
</script>
```

为使页面正常进行跳转，需要补全router中index.js设置的内容（需要注意的是其内容一定要与输入内容相对应），以及创建User.vue及其他组件

![image-20221212221332585](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221212221332585.png)

## 11、home组件左侧数据展示

首先对页面进行分栏处理，并且使用gutter指定分栏后左右列之间的间隔距离，其默认值为20

在这之中设置card样式、table样式，然后使用v-for对用到的数据进行循环遍历展示

### 11.1、home.vue

```vue
<template>
  <el-row class="home" :gutter="20">
    <!-- 使用gutter来指定分栏后左右列之间的间隔，其默认值为20 -->
    <!-- 分栏的总数应为24 -->
    <el-col :span="8" style="margin-top: 20px">
      <el-card shadow="hover">
        <!-- shadow="hover"鼠标放置时出现阴影 -->
        <div class="user">
          <img src="../../assets/images/user.png" alt="" />
          <div class="user-info">
            <p class="name">Admin</p>
            <p class="role">超级管理员</p>
          </div>
        </div>
        <div class="login-info">
          <p>上次登录时间:<span>2022-7-11</span></p>
          <p>上次登录的地点:<span>北京</span></p>
        </div>
      </el-card>
      <el-card shadow="hover" style="margin-top: 20px" height="450px">
        <el-table :data="tableData">
          <el-table-column v-for="(val, key) in tableLabel" :key="key" :prop="key" :label="val">
          </el-table-column>
        </el-table>
      </el-card>
    </el-col>

    <el-col :span="16" style="margin-top: 20px" class="right-num">
    </el-col>
  </el-row>
</template>

<script>
import { defineComponent } from "vue"
export default defineComponent({
  setup() {
    const tableData= [
          {
            name: 'oppo',
            todayBuy: 500,
            monthBuy: 3500,
            totalBuy: 22000
          },
          {
            name: 'vivo',
            todayBuy: 300,
            monthBuy: 2200,
            totalBuy: 24000
          },
          {
            name: '苹果',
            todayBuy: 800,
            monthBuy: 4500,
            totalBuy: 65000
          },
          {
            name: '小米',
            todayBuy: 1200,
            monthBuy: 6500,
            totalBuy: 45000
          },
          {
            name: '三星',
            todayBuy: 300,
            monthBuy: 2000,
            totalBuy: 34000
          },
          {
            name: '魅族',
            todayBuy: 350,
            monthBuy: 3000,
            totalBuy: 22000
          }
        ];

    const tableLabel = {
      name: "手机品牌",
      todayBuy: "今日购买",
      monthBuy: "本月购买",
      totalBuy: "总购买",
    };
  
    return {
      tableData,
      tableLabel,
    };
  }
})
</script>

<style lang="less" scoped>
.home {
  .user {
    display: flex;
    align-items: center;
    padding-bottom: 20px;
    border-bottom: 1px solid #ccc;
    margin-bottom: 20px;

    img {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      margin-right: 40px;
    }
  }

  .login-info {
    p {
      line-height: 30px;
      font-size: 14px;
      color: #999;

      span {
        color: #666;
        margin-left: 60px;
      }
    }
  }
}
</style>
```

## 12、本地/线上mock与axios请求

mock拦截本应传递到后端的Ajax请求，之后生成对应随机数据，模拟后端响应

### 12.1、安装

```bash
yarn add mockjs@1.1.0
```

```bash
yarn add axios@0.27.2
```

### 12.2、本地mock

#### 12.2.1、创建后端响应内容

在src目录下新建api文件夹，然后在api文件夹下新建mockData，用来模拟后端的响应内容，例如在其中新建home.js，模拟首页获取后端的table数据，在getHomeData()方法中返回一个状态码code(200)，以及具体的数据data

home.js

```js
export default {
    getHomeData: () => {
        return {
            code: 200,
            data: {
                tableData: [
                    {
                        name: 'oppo',
                        todayBuy: 500,
                        monthBuy: 3500,
                        totalBuy: 22000
                    },
                    {
                        name: 'vivo',
                        todayBuy: 300,
                        monthBuy: 2200,
                        totalBuy: 24000
                    },
                    {
                        name: '苹果',
                        todayBuy: 800,
                        monthBuy: 4500,
                        totalBuy: 65000
                    },
                    {
                        name: '小米',
                        todayBuy: 1200,
                        monthBuy: 6500,
                        totalBuy: 45000
                    },
                    {
                        name: '三星',
                        todayBuy: 300,
                        monthBuy: 2000,
                        totalBuy: 34000
                    },
                    {
                        name: '魅族',
                        todayBuy: 350,
                        monthBuy: 3000,
                        totalBuy: 22000
                    }
                ],
            }
        }
    }
}
```

#### 12.2.2、拦截前端请求调用mock函数

在api文件夹下创建mock.js文件，用来拦截前端发送的请求，并调用mockData中定义的方法

mock.js

```js
import Mock from 'mockjs'
import homeApi from './mockData/home'

Mock.mock('/home/getData',homeApi.getHomeData)
```

#### 12.2.3、使mock生效

在main.js中引入mock

main.js

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
// import ElementPlus from 'element-plus'
// import 'element-plus/dist/index.css'
import './assets/less/index.less'
import * as ElementPlusIconsVue from '@element-plus/icons-vue'
import store from './store/index.js'
import './api/mock.js'

const app = createApp(App)
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
    app.component(key, component)
}
app.use(router)
app.use(store)
//完整引入element-plus
// app.use(ElementPlus)
app.mount('#app')
```

#### 12.2.4、发送axios请求获取数据后填充

通过axios异步调用，发送get请求，将获取的数据对前面定义的数据进行赋值

关于如何赋值，vue3做出了些改动，首先需要导入ref，然后使用ref()对要赋值对象进行包裹，并用let指定，赋值时使用对象的value属性

获取首页的axios请求函数方法应该发在onMounted()中执行

home.vue

```js
<script>
//vue3接着ref进行赋值，并且使用对象的value属性接收数据
import { defineComponent,onMounted,ref } from "vue"
import axios from "axios"
export default defineComponent({
  setup() {
    // let tableData = [];
    let tableData = ref([]);
    const tableLabel = {
      name: "手机品牌",
      todayBuy: "今日购买",
      monthBuy: "本月购买",
      totalBuy: "总购买",
    };

    //异步调用
    const getTableList = async()=>{
      await axios.get("/home/getData").then((res)=>{
        // console.log(res)
        tableData.value = res.data.data.tableData
      })
    }

    onMounted(()=>{
      getTableList();
    })

    return {
      tableData,
      tableLabel,
    };
  }
})
</script>
```

### 12.3、线上mock

使用fastmock实现线上mock

fastmock官网地址：https://www.fastmock.site/#/

登录以后可以新建一个项目，项目的根路径给定为api

![image-20221213143009648](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213143009648.png)

然后新增一个接口，例如获取首页的table数据，使用get请求，并指定响应的路由

![image-20221213143139871](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213143139871.png)

```json
{
    "code": 200,
    "data": {
        "tableData" : [
            {
                name: 'oppo',
                todayBuy: 500,
                monthBuy: 3500,
                totalBuy: 22000
            },
            {
                name: 'vivo',
                todayBuy: 300,
                monthBuy: 2200,
                totalBuy: 24000
            },
            {
                name: '苹果',
                todayBuy: 800,
                monthBuy: 4500,
                totalBuy: 65000
            },
            {
                name: '小米',
                todayBuy: 1200,
                monthBuy: 6500,
                totalBuy: 45000
            },
            {
                name: '三星',
                todayBuy: 300,
                monthBuy: 2000,
                totalBuy: 34000
            },
            {
                name: '魅族',
                todayBuy: 350,
                monthBuy: 3000,
                totalBuy: 22000
            }            
        ]
    }   
}
```

点击页面中的预览接口，可以复制浏览器中的请求路径

![image-20221213143225508](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213143225508.png)

![image-20221213143327455](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213143327455.png)

将上述请求路径复制到前端项目中的axios请求，依然可以获取模拟数据

```js
	await 	axios.get("https://www.fastmock.site/mock/45ef50b19d73ecb925563a45960a1cac/api/home/getTableData").then((res)=>{
        // console.log(res)
        tableData.value = res.data.data.tableData
      })
```

![image-20221213143758009](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213143758009.png)

## 13、二次封装axios

> 无论是在请求之前还是在请求之后都有一些公共的部分需要处理，这就用到了axios的二次封装
>
> 以下步骤层层递进！！！

### 13.1、配置环境

在src目录下新建config文件夹，并在此文件夹下创建index.js文件，此文件用来指定项目的环境配置

src/config/index.js

```js
/**
 * 环境配置文件
 * 一般在企业级项目里面有三个环境
 * 开发环境
 * 测试环境
 * 线上环境
 */
// 当前的环境
const env = import.meta.env.MODE || 'prod'  //如果取不到默认为线上环境prod

const EnvConfig = {
  development: {
    baseApi: '/api',
    mockApi: 'https://www.fastmock.site/mock/45ef50b19d73ecb925563a45960a1cac/api',
  },
  test: {
    baseApi: '//test.future.com/api',
    mockApi: 'https://www.fastmock.site/mock/45ef50b19d73ecb925563a45960a1cac/api',
  },
  pro: {
    baseApi: '//future.com/api',
    mockApi: 'https://www.fastmock.site/mock/45ef50b19d73ecb925563a45960a1cac/api',
  },
}

export default {
  env,
  // mock的总开关,
  mock: false,
  ...EnvConfig[env]
}
```

### 13.2、axios二次封装

在api目录下新建request.js文件，该文件需要引入config中的配置文件，以及可以引入element-plus的错误提示信息

首先根据配置文件中的请求api创建一个service对象

service对象允许在请求前做些操作，也允许在请求后做些操作（比如数据的封装：res.data或者错误信息的抛出）

编写封装的核心函数request(options)，首先明确请求方法是什么，然后对mock处理（允许总开关关闭时仍然有但单个接口可以使用mock数据），再对线上环境进行处理（如果运行环境是线上，那么直接不允许使用mock）

最终将request进行暴露。

api/request.js

```js
import axios from 'axios'
import config from '../config'
import { ElMessage } from 'element-plus'  //错误提示

const NETWORK_ERROR = '网络请求异常,请稍后重试.....'

// 创建一个axios实例对象
const service = axios.create({
  baseURL: config.baseApi
})

// 在请求之前做一些事情
service.interceptors.request.use((req) => {
  // 可以自定义header
  // jwt-token认证的时候 
  return req
})

// 在请求之后做一些事情
service.interceptors.response.use((res) => {
  const { code, data, msg } = res.data
  // 根据后端 协商  视情况而定
  if (code == 200) {
    return data
  } else {
    // 网络请求错误
    ElMessage.error(msg || NETWORK_ERROR)
    return Promise.reject(msg || NETWORK_ERROR)
  }
})

// 封装的核心函数
function request(options) {
  // options对象:{
  //   methods: 'get',
  //   data:{

  //   },
  //   mock:false
  // }
  //获取请求方法，默认为get请求
  options.method = options.method || 'get'
  if (options.method.toLowerCase() == 'get') {
    options.params = options.data
  }
  // 对mock的处理
  let isMock = config.mock  //取自总开关的mock
  if (typeof options.mock !== 'undefined') {  //单个接口可以自定义mock开关
    isMock = options.mock
  }
  // 对线上环境做处理
  if (config.env == 'prod') {
    // 不给你用到mock的机会，避免t0级的错误
    service.defaults.baseURL = config.baseApi
  } else {
    service.defaults.baseURL = isMock ? config.mockApi : config.baseApi
  }

  return service(options)
}

export default request
```

### 13.3、项目api管理

在api目录下新建api.js，用来管理整个项目的api接口

首先引入axios二次封装的文件request.js，之后暴露相应的接口函数，在每个函数中使用request方法，其中含有url、method、data、mock等信息

api/api.js

```js
/**
 * 整个项目api的管理
 * 
 */
import request from "./request"
export default {
  // home组件 左侧表格数据获取
  getTableData(params) {
    return request({
      url: '/home/getTableData',
      method: 'get',
      data: params,
      mock: true
    })
  },

}
```

### 13.4、项目api配置

在main.js中引入刚刚写好的api.js文件，然后在全局环境中进行挂载，方便后面组件使用

```js
import api from './api/api'     //配置api,使用axios的二次封装获取数据

//全局挂载api
app.config.globalProperties.$api = api
```

![image-20221213161454682](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213161454682.png)

### 13.5、项目api调用

在组件中使用刚刚经过axios二次封装配置好的api

首先需要经过proxy才能使用，用到的getCurrentInstance()需要从vue中导入

```js
import { defineComponent,getCurrentInstance,onMounted,ref } from "vue"
```

```js
const { proxy } = getCurrentInstance();
```

然后在相应的函数中，通过proxy调用配置好的方法

```js
const getTableList = async()=>{
      //使用二次封装的axios请求fastmock
      let res = await proxy.$api.getTableData();
      // console.log(res);
      tableData.value = res.tableData;
}
```

![image-20221213165504901](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213165504901.png)

## 14、二次封装axios案例

实现home页面右上方数据展示

在home.vue中创建相应的位置编写样式代码，将所用数据存放在countData中并进行遍历，其中包括动态引入图标以及设置背景颜色

home.vue

```html
	  <div class="num">
        <el-card
          :body-style="{ display: 'flex', padding: 0 }"
          v-for="item in countData"
          :key="item.name"
        >
          <component class="icons" :is="item.icon" :style="{ background: item.color }"
          ></component>
          <div class="detail">
            <p class="num">￥{{ item.value }}</p>
            <p class="txt">{{ item.name }}</p>
          </div>
        </el-card>
      </div>
```

```css
.num {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    .el-card {
      width: 32%;
      margin-bottom: 20px;
    }
    .icons {
      width: 80px;
      height: 80px;
      font-size: 30px;
      text-align: center;
      line-height: 80px;
      color: #fff;
    }
    .detail {
      margin-left: 15px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      .num {
        font-size: 30px;
        margin-bottom: 10px;
      }
      .txt {
        font-size: 14px;
        text-align: center;
        color: #999;
      }
    }
  }
```

![image-20221213171548545](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213171548545.png)

然后在script中指定存放的数据countData，已经用来获取数据的方法，并在onMounted中进行调用，以及进行暴露导出countData

```js
let countData = ref([]);
```

```js
	// 获取首页count数据
    const getCountData = async () => {
      let res = await proxy.$api.getCountData();
      console.log(res);
      countData.value = res;
    };

    onMounted(()=>{
      getTableList();
      // 获取count数据
      getCountData();
    })

    return {
      tableData,
      tableLabel,
      countData,
    };
```

![image-20221213171834437](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213171834437.png)

![image-20221213171859833](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213171859833.png)

之后在api.js设置请求路由、请求方式、以及是否使用mock

api/api.js

```js
/**
 * 整个项目api的管理
 * 
 */
import request from "./request"
export default {
    // home组件 左侧表格数据获取
    getTableData(params) {
        return request({
            url: '/home/getTableData',
            method: 'get',
            data: params,
            mock: true
        })
    },
    getCountData() {
        return request({
            url: '/home/getCountData',
            method: 'get',
            mock: true
        })
    }
}
```

然后在fastmock中设置相对路由，以及用来返回的函数

![image-20221213172258269](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221213172258269.png)

```json
{
  "code":200,
  "data":[
                {
                name: "今日支付订单",
                value: 1200,
                icon: "Tickets",
                color: "#2ec7c9",
                },
                {
                name: "今日收藏订单",
                value: 210,
                icon: "StarFilled",
                color: "#ffb980",
                },
                {
                name: "今日未支付订单",
                value: 1219,
                icon: "Document",
                color: "#5ab1ef",
                },
                {
                name: "本月支付订单",
                value: 1234,
                icon: "Collection",
                color: "#2ec7c9",
                },
                {
                name: "本月收藏订单",
                value: 260,
                icon: "DocumentChecked",
                color: "#ffb980",
                },
                {
                name: "本月未支付订单",
                value: 1234,
                icon: "DocumentCopy",
                color: "#5ab1ef",
                },
            ]
}
```

## 15、echarts绘制图像

### 15.1、安装

```bash
yarn echarts @5.3.3
```

### 15.2、mock表格数据

在fastmock中新建接口orderData，路由为/home/getChartData，用来模拟echarts图表的数据

![image-20221215154711549](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221215154711549.png)

模拟的数据包括三部分，分别为折线图数据orderData、柱状图数据userData、饼状图数据videoData

```json
{
  "code":200,
  "data":{
    "orderData": {
      "date": ["20191001", "20191002", "20191003", "20191004", "20191005", "20191006", "20191007"],
      "data|7": [{
        "苹果": "@integer(1000, 5000)",
        "小米": "@integer(1000, 5000)",
        "华为": "@integer(1000, 5000)",
        "oppo": "@integer(1000, 5000)",
        "vivo": "@integer(1000, 5000)",
        "一加": "@integer(1000, 5000)",
      }]
    },
    "videoData": [{
        name: "小米",
        value: 2999
      },
      {
        name: "苹果",
        value: 5999
      },
      {
        name: "vivo",
        value: 1500
      },
      {
        name: "oppo",
        value: 1999
      },
      {
        name: "魅族",
        value: 2200
      },
      {
        name: "三星",
        value: 4500
      }
    ],
    "userData": [{
        date: "周一",
        new: 5,
        active: 200
      },
      {
        date: "周二",
        new: 10,
        active: 500
      },
      {
        date: "周三",
        new: 12,
        active: 550
      },
      {
        date: "周四",
        new: 60,
        active: 800
      },
      {
        date: "周五",
        new: 65,
        active: 550
      },
      {
        date: "周六",
        new: 53,
        active: 770
      },
      {
        date: "周日",
        new: 33,
        active: 170
      }
    ]
  }
}
```

### 15.3、绘制图表样式

> 注意：
>
> 1. 要给定ref，用来再script中定位到具体是哪个地方绘制图表
> 2. 要给定高度，否则script绘制完图表后无法展示

```html
	  <el-card style="height: 280px">
        <div ref="echart" style="height: 280px"></div>
      </el-card>
      <div class="graph">
        <el-card style="height: 260px">
          <div ref="userechart" style="height: 240px"></div>
        </el-card>
        <el-card style="height: 260px">
          <div ref="videoechart" style="height: 240px"></div>
        </el-card>
      </div>
```

![image-20221215155100461](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221215155100461.png)

给定css样式：

```css
.graph {
    margin-top: 20px;
    display: flex;
    justify-content: space-between;
    .el-card {
      width: 48%;
    }
  }
```

### 15.4、script填充图表数据

#### 15.4.1、导入echarts以及reactive

```js
import { defineComponent,getCurrentInstance,onMounted,ref,reactive } from "vue"

import * as echarts from "echarts";
```

- reactive用来定义一个对象类型的响应式数据（基本类型要用`ref`函数）
- 所以一般情况下，会用reactive将当前组件所需的属性都定义在一个对象中。

- 语法：`const 代理对象= reactive(源对象)`接收一个对象（或数组），返回一个代理对象（`Proxy`的实例对象，简称`proxy`对象）
- `reactive`定义的响应式数据是“深层次的”。
- 内部基于 ES6 的 `Proxy` 实现，通过代理对象操作源对象内部数据进行操作。

#### 15.4.2、设置好图像的格式以及预留出数据位置

```js
	// 关于echarts 表格的渲染部分
    let xOptions = reactive({
      // 图例文字颜色
      textStyle: {
        color: "#333",
      },
      grid: {
        left: "20%",
      },
      // 提示框
      tooltip: {
        trigger: "axis",
      },
      xAxis: {
        type: "category", // 类目轴
        data: [],
        axisLine: {
          lineStyle: {
            color: "#17b3a3",
          },
        },
        axisLabel: {
          interval: 0,
          color: "#333",
        },
      },
      yAxis: [
        {
          type: "value",
          axisLine: {
            lineStyle: {
              color: "#17b3a3",
            },
          },
        },
      ],
      color: ["#2ec7c9", "#b6a2de", "#5ab1ef", "#ffb980", "#d87a80", "#8d98b3"],
      series: [],
    });
    //饼状图的配置
    let pieOptions = reactive({
      tooltip: {
        trigger: "item",
      },
      color: [
        "#0f78f4",
        "#dd536b",
        "#9462e5",
        "#a6a6a6",
        "#e1bb22",
        "#39c362",
        "#3ed1cf",
      ],
      series: [],
    });
	//预留存放折线图数据
    let orderData = reactive({
      xData: [],
      series: [],
    });
	//预留存放柱状图数据
    let userData = reactive({
      xData: [],
      series: [],
    });
	//预留存放饼状图数据
    let videoData = reactive({
      series: [],
    });
```

#### 15.4.3、接收来自mock的模拟数据

接收来自mock的模拟数据，然后将它们处理成所需要的列表样式的数据，赋值完成后进行渲染

```js
	const getChartData = async () => {
      let result = await proxy.$api.getChartData();
      let res = result.orderData;
      let userRes = result.userData;
      let videoRes = result.videoData;
      orderData.xData = res.date;
      console.log(res.data)
      const keyArray = Object.keys(res.data[0]);
      const series = [];
      keyArray.forEach((key) => {
        series.push({
          name: key,
          data: res.data.map((item) => item[key]),
          type: "line",
        });
      });
      orderData.series = series;
      xOptions.xAxis.data = orderData.xData;
      xOptions.series = orderData.series;
      // 折线图图像进行渲染
      let hEcharts = echarts.init(proxy.$refs["echart"]);
      hEcharts.setOption(xOptions);

      // 柱状图进行渲染的过程
      userData.xData = userRes.map((item) => item.date);
      userData.series = [
        {
          name: "新增用户",
          data: userRes.map((item) => item.new),
          type: "bar",
        },
        {
          name: "活跃用户",
          data: userRes.map((item) => item.active),
          type: "bar",
        },
      ];
      xOptions.xAxis.data = userData.xData;
      xOptions.series = userData.series;
      //柱状图渲染
      let uEcharts = echarts.init(proxy.$refs["userechart"]);
      uEcharts.setOption(xOptions);

      //饼状图绘制
      videoData.series = [
        {
          data: videoRes,
          type: "pie",
        },
      ];
      pieOptions.series = videoData.series;
      let vEcharts = echarts.init(proxy.$refs["videoechart"]);
      vEcharts.setOption(pieOptions);
    };
```

#### 15.4.4、初次渲染数据时加载

```js
	onMounted(()=>{
      getTableList();
      // 获取count数据
      getCountData();
      // 获取echarts表格数据
      getChartData();
    })
```

## 16、面包屑组件实现

### 16.1、点击侧边栏更新store中的数据

CommonAside.vue

首先从vuex中引入useStore对象，使用useStore对象创建store

```js
import { useStore } from 'vuex';

		const store = useStore()
```

然后修改点击菜单函数clickMenu(item)，在实现路由组件跳转的同时，调用store中的方法更新当中的数据

```js
		const clickMenu = (item) => {
            router.push({
                name:item.name,
            });
            store.commit("selectMenu",item);
        };
```

### 16.2、增加store中的属性及方法

store/index.js

增加currentMenu属性，用来指定选中的对象是什么

增加selectMenu(state,val)方法用来接收CommonAside.vue中传递的变量

```js
import { createStore } from 'vuex'

export default createStore({
    state: {
        isCollapse: true,
        currentMenu:null
    },
    mutations: {
        updateIsCollapse(state,payload){
            state.isCollapse = !state.isCollapse
        },
        selectMenu(state,val){
            if(val.name == 'home'){
                state.currentMenu = null
            }else{
                state.currentMenu = val
            }
        }
    }
})
```

### 16.3、使用面包屑展示store中的数据

```html
			<el-breadcrumb separator="/" class="bread">
                <!-- 首页是一定存在的所以直接写死 -->
                <el-breadcrumb-item :to="{ path: '/' }">首页</el-breadcrumb-item>
                <el-breadcrumb-item :to="current.path" v-if="current">{{
                        current.label
                }}</el-breadcrumb-item>
            </el-breadcrumb>
```

```js
		//使用计算属性
        const current = computed(() => {
            return store.state.currentMenu;
        });
        return {
            getImgSrc,
            handleCollapse,
            current,
        }
```

## 17、tag组件实现

1. 首页的tag一开始就会存在，而且是不能进行删除的
2. 当点击左侧栏的时候,如果tag没有该菜单名称则新增，如果已经有了那么当前tag背景为蓝色。
3. 删除当前tag，如果是最后一个，那么路由调整到它前面那个标签并且背景变蓝，如果不是最后一个那么路由调整到它后面那个标签并且背景变蓝。
4. 还有我们注意这个tag不论路由如何切换都是会存在的，所以这个tag一定要存在我们之前定义的Main.vue中。
   ![面包屑的说明](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/%E9%9D%A2%E5%8C%85%E5%B1%91.jpg)

### 17.1、新建组件CommonTag.vue

使用el-tag建立tag组件

- :closable="tag.name !== 'home'"在不为home时有关闭按钮
- :disable-transitions="false" 禁用渐变动画
- :effect="$route.name === tag.name ? 'dark' : 'plain'" 选择背景颜色

然后给定点击页面跳转方法、页面关闭方法

在这个过程中会读取来自store的数据tabsList，里面存放的是使用的页面，使用router进行页面跳转（给定组件名字），使用route获取页面的数据（页面名字）

CommonTag.vue：

```vue
<template>
    <div class="tags">
        <el-tag :key="tag.name" 
        v-for="(tag, index) in tags" 
        :closable="tag.name !== 'home'"
        :disable-transitions="false" 
        :effect="$route.name === tag.name ? 'dark' : 'plain'" 
        @click="changeMenu(tag)"
        @close="handleClose(tag, index)">
            {{ tag.label }}
        </el-tag>
    </div>
</template>

<script>
import { useRouter,useRoute } from 'vue-router';
import { useStore } from 'vuex';
export default {
    setup() {
        const store = useStore();
        const router = useRouter();
        const route = useRoute();
        const tags = store.state.tabsList;
        const changeMenu = (item) => {
            router.push({ name: item.name });
        };
        const handleClose = (tag, index) => {
            let length = tags.length - 1;
            // 处理vuex中的tabslist
            store.commit("closeTab", tag);
            // 做第一个判断
            if (tag.name !== route.name) {
                return;
            }

            if (index === length) {
                router.push({
                    name: tags[index - 1].name,
                });
            } else {
                router.push({
                    name: tags[index].name,
                });
            }
        };
        return {
            tags,
            changeMenu,
            handleClose,
        };
    },
}
</script>

<style lang="less" scoped>
.tags {
    padding: 20px;
    width: 100%;

    .el-tag {
        margin-right: 15px;
        cursor: pointer;
    }
}
</style>
```

### 17.2、store中存放数据方法

在store中新增存储页面数据的列表

修改之前点击菜单的函数，将新增的菜单加入到页面数据列表中

当点击关闭页面函数时，将其从页面数据列表中删除

store/index.js

```js
import { createStore } from 'vuex'

export default createStore({
    state: {
        isCollapse: true,
        currentMenu: null,
        tabsList: [
            {
                path: '/',
                name: 'home',
                label: '首页',
                icon: 'home'
            }
        ],
    },
    mutations: {
        updateIsCollapse(state, payload) {
            state.isCollapse = !state.isCollapse
        },
        selectMenu(state, val) {
            if (val.name == 'home') {
                state.currentMenu = null
            } else {
                state.currentMenu = val
                let result = state.tabsList.findIndex(item => item.name === val.name)
                result == -1 ? state.tabsList.push(val) : ''
            }
        },
        closeTab(state, val) {
            let res = state.tabsList.findIndex(item => item.name === val.name)
            state.tabsList.splice(res, 1)
        },
    }
})
```

### 17.3、在Main.vue中引入Tag组件

![image-20221215210944097](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221215210944097.png)

![image-20221215182619692](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221215182619692.png)

## 18、User组件以及本地mock

> 由于涉及到数据的增删改查，先不使用fastmock，而是使用本地的mock

### 18.1、创建后台模拟数据

在mockData中创建user.js，用来对用户数据进行增删改查

api/mockData/user.js

```js
import Mock from 'mockjs'

// get请求从config.url获取参数，post从config.body中获取参数
function param2Obj(url) {
  const search = url.split('?')[1]
  if (!search) {
    return {}
  }
  return JSON.parse(
    '{"' +
    decodeURIComponent(search)
      .replace(/"/g, '\\"')
      .replace(/&/g, '","')
      .replace(/=/g, '":"') +
    '"}'
  )
}

let List = []
const count = 200

for (let i = 0; i < count; i++) {
  List.push(
    Mock.mock({
      id: Mock.Random.guid(),
      name: Mock.Random.cname(),
      addr: Mock.mock('@county(true)'),
      'age|18-60': 1,
      birth: Mock.Random.date(),
      sex: Mock.Random.integer(0, 1)
    })
  )
}

export default {
  /**
   * 获取列表
   * 要带参数 name, page, limt; name可以不填, page,limit有默认值。
   * @param name, page, limit
   * @return {{code: number, count: number, data: *[]}}
   */
  getUserList: config => {
    const { name, page = 1, limit = 20 } = param2Obj(config.url)
    const mockList = List.filter(user => {
      if (name && user.name.indexOf(name) === -1 && user.addr.indexOf(name) === -1) return false
      return true
    })
    const pageList = mockList.filter((item, index) => index < limit * page && index >= limit * (page - 1))
    return {
      code: 200,
      data: {
        list: pageList,
        count: mockList.length,
      }
    }
  },
  /**
   * 增加用户
   * @param name, addr, age, birth, sex
   * @return {{code: number, data: {message: string}}}
   */
  createUser: config => {
    const { name, addr, age, birth, sex } = JSON.parse(config.body)
    console.log(JSON.parse(config.body))
    List.unshift({
      id: Mock.Random.guid(),
      name: name,
      addr: addr,
      age: age,
      birth: birth,
      sex: sex
    })
    return {
      code: 200,
      data: {
        message: '添加成功'
      }
    }
  },
  /**
   * 删除用户
   * @param id
   * @return {*}
   */
  deleteUser: config => {
    const { id } = param2Obj(config.url)
    if (!id) {
      return {
        code: -999,
        message: '参数不正确'
      }
    } else {
      List = List.filter(u => u.id !== id)
      return {
        code: 200,
        message: '删除成功'
      }
    }
  },
  /**
   * 批量删除
   * @param config
   * @return {{code: number, data: {message: string}}}
   */
  batchremove: config => {
    let { ids } = param2Obj(config.url)
    ids = ids.split(',')
    List = List.filter(u => !ids.includes(u.id))
    return {
      code: 20000,
      data: {
        message: '批量删除成功'
      }
    }
  },
  /**
   * 修改用户
   * @param id, name, addr, age, birth, sex
   * @return {{code: number, data: {message: string}}}
   */
  updateUser: config => {
    const { id, name, addr, age, birth, sex } = JSON.parse(config.body)
    const sex_num = parseInt(sex)
    List.some(u => {
      if (u.id === id) {
        u.name = name
        u.addr = addr
        u.age = age
        u.birth = birth
        u.sex = sex_num
        return true
      }
    })
    return {
      code: 200,
      data: {
        message: '编辑成功'
      }
    }
  }
}
```

### 18.2、通过mock.js将模拟数据匹配url

api/mock.js

```js
import Mock from 'mockjs'
import homeApi from './mockData/home'
import userApi from './mockData/user'
//拦截请求
Mock.mock('/home/getData',homeApi.getHomeData)

// 本地获取user的数据
Mock.mock(/user\/getUser/, 'get', userApi.getUserList)
Mock.mock(/user\/add/, 'post', userApi.createUser)
Mock.mock(/user\/edit/, 'post', userApi.updateUser)
Mock.mock(/user\/delete/, 'get', userApi.deleteUser)
```

### 18.3、设定组件的api请求接口

注意其中的mock数据应该为false，否则将使用线上的fastmock（获取不到数据）

api/api.js：

```js
/**
 * 整个项目api的管理
 * 
 */
import request from "./request"
export default {
    // home组件 左侧表格数据获取
    getTableData(params) {
        return request({
            url: '/home/getTableData',
            method: 'get',
            data: params,
            mock: true
        })
    },
    getCountData() {
        return request({
            url: '/home/getCountData',
            method: 'get',
            mock: true
        })
    },
    getChartData() {
        return request({
            url: '/home/getChartData',
            method: 'get',
            mock: true
        })
    },
    getUserData(params) {
        return request({
            url: '/user/getUser',
            method: 'get',
            // 这个mock如果是true的话 用的就是线上fastmock的数据
            mock: false,
            data: params
            // data:{total: 0,page: 1,}
        })
    },
    addUser(params) {
        return request({
            url: '/user/add',
            method: 'post',
            // 这个mock如果是true的话 用的就是线上fastmock的数据
            mock: false,
            data: params
            // data:{total: 0,page: 1,}
        })
    },
    editUser(params) {
        return request({
            url: '/user/edit',
            method: 'post',
            // 这个mock如果是true的话 用的就是线上fastmock的数据
            mock: false,
            data: params
        })
    },
    deleteUser(params) {
        return request({
            url: '/user/delete',
            method: 'get',
            // 这个mock如果是true的话 用的就是线上fastmock的数据
            mock: false,
            data: params
        })
    },
}
```

### 18.4、使用el-table构建表单组件

el-table中存放的数据为于:data=“list”当中

然后针对el-table-column遍历每一列，列名位于tableLabel中

User.vue

```vue
<template>
  <div class="table">
    <el-table :data="list" style="width: 100%" height="500px">
      <el-table-column v-for="item in tableLabel" :key="item.prop" :label="item.label" :prop="item.prop"
        :width="item.width ? item.width : 125" />
      <el-table-column fixed="right" label="操作" min-width="180">
        <template #default="scope">
          <el-button size="small" @click="handleEdit(scope.row)">编辑</el-button>
          <el-button type="danger" size="small" @click="handleDelete(scope.row)">删除</el-button>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>

<script>
import { defineComponent, getCurrentInstance, onMounted,ref,reactive } from 'vue';
export default defineComponent({
  setup() {
    const { proxy } = getCurrentInstance();
    const list = ref([]);
    //表头的设定
    const tableLabel = reactive([
      {
        prop: "name",
        label: "姓名",
      },
      {
        prop: "age",
        label: "年龄",
      },
      {
        prop: "sexLabel",
        label: "性别",
      },
      {
        prop: "birth",
        label: "出生日期",
        width: 200,
      },
      {
        prop: "addr",
        label: "地址",
        width: 320,
      },
    ]);
    onMounted(() => {
      getUserData();
    });
    const getUserData = async () => {
      let res = await proxy.$api.getUserData();
      // console.log(res)
      list.value = res.list.map((item) => {
        item.sexLabel = item.sex === 0 ? "女" : "男";
        return item;
      });
    };
    return {
      list,
      tableLabel,
    };
  },
})
</script>

<style>

</style>
```

![image-20221215202356701](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221215202356701.png)

### 18.5、使用el-pagination构建分页组件

首先在table下使用el-pageination构建分页组件，:total代表总条数，@current-change=“changePage”表示点击页码切换的方法函数

User.vue

```vue
	<el-pagination
      small
      background
      layout="prev, pager, next"
      :total="config.total"
      @current-change="changePage"
      class="pager mt-4"
    />
```

在setup(){}中增加数据config，用来对分页内容进行设定

```js
	//分页设定：总条数、页码、名字
    const config = reactive({
      total: 0,
      page: 1,
      name: "",
    });
```

changePage页码切换方法，需要传入参数page，方法内重新调用数据获取方法getUserData(config)

```js
	const changePage = (page) => {
      // console.log(page);
      config.page = page;
      getUserData(config);
    };
```

相较于之前的getUserData()方法，现在需要传入config对象参数（使用config可以根据条件进行数据的获取），还要更新页码总数量total

```js
	const getUserData = async (config) => {
      let res = await proxy.$api.getUserData(config);
      // console.log(res)
      config.total = res.count;
      list.value = res.list.map((item) => {
        item.sexLabel = item.sex === 0 ? "女" : "男";
        return item;
      });
    };
```

此外，还需要更新onMounted

```js
	onMounted(() => {
      getUserData(config);
    });
```

更新分页组件的样式

```css
.table {
  position: relative;
  height: 520px;
  .pager {
    position: absolute;
    right: 0;
    bottom: -20px;
  }
}
```

### 18.6、使用el-form构建搜索的form表单

使用:model="formInline"进行数据的双向绑定

使用@click="handleSearch"将分页组件中所用的config.name与搜索的名字进行绑定，然后将config作为查询条件进行搜索

```vue
<div class="user-header">
    <el-button type="primary" @click="handleAdd">+新增</el-button>
    <el-form :inline="true" :model="formInline">
      <el-form-item label="请输入">
        <el-input v-model="formInline.keyword" placeholder="请输入用户名" />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="handleSearch">搜索</el-button>
      </el-form-item>
    </el-form>
  </div>
```

> 提前编写`新增按钮`

```js
	const formInline = reactive({
      keyword: "",
    });
    const handleSearch = () => {
      config.name = formInline.keyword;
      getUserData(config);
    };
    return {
      list,
      tableLabel,
      config,
      changePage,
      formInline,
      handleSearch,
    };
```

### 18.7、使用el-dialog与el-form构建弹窗表达

弹窗的开关通过dialogVisible来控制，因此可以针对它使用v-model进行双向绑定，弹窗的名字可以使用:title进行修改，

\<el-form>是表单组件

\<el-row>是表单中的一行

\<el-col :span="12">一行总共24列，占其中的12列

\<el-form-item>存放输入的具体内容

\<el-input>是输入框（输入内容默认是字符串，如果被输入的内容是数字，则双向绑定时使用v-model.number）

\<el-select>是下拉菜单，\<el-option>下拉菜单中的具体选项

\<el-date-picker>日期选择

@click="handleAdd"			 					 	新增内容的方法，已在上面提供

@click="handleEdit(scope.row)"			  编辑一行内容的方法，需要传入一行中的数据，已在上面提供

@click="handleDelete(scope.row)"		 删除一行内容的方法，需要传入一行中的数据，已在上面提供

@click="handleCancel"								 取消弹窗操作的方法

@click="onSubmit"										 确定弹窗内容的方法

```vue
<el-dialog v-model="dialogVisible" :title="action == 'add' ? '新增用户' : '编辑用户'" width="35%" :before-close="handleClose">
    <el-form :inline="true" :model="formUser" ref="userForm">
      <el-row>
        <el-col :span="12">
          <el-form-item label="姓名" prop="name" :rules="[{ required: true, message: '姓名是必填项' }]">
            <el-input v-model="formUser.name" placeholder="请输入姓名" />
          </el-form-item>
        </el-col>
        <el-col :span="12">
          <el-form-item label="年龄" prop="age" :rules="[
            { required: true, message: '年龄是必填项' },
            { type: 'number', message: '年龄必须是数字' },
          ]">
            <el-input v-model.number="formUser.age" placeholder="请输入年龄" />
          </el-form-item>
        </el-col>
      </el-row>
      <el-row>
        <el-col :span="12">
          <el-form-item label="性别" prop="sex" :rules="[{ required: true, message: '性别是必选项' }]">
            <el-select v-model="formUser.sex" placeholder="请选择">
              <el-option label="男" value="0" />
              <el-option label="女" value="1" />
            </el-select>
          </el-form-item>
        </el-col>
        <el-col :span="12">
          <el-form-item label="出生日期" prop="birth" :rules="[{ required: true, message: '出生日期是必选项' }]">
            <el-date-picker v-model="formUser.birth" type="date" label="出生日期" placeholder="请输入" style="width: 100%" />
          </el-form-item>
        </el-col>
      </el-row>
      <el-row>
        <el-form-item label="地址" prop="addr" :rules="[{ required: true, message: '地址是必填项' }]">
          <el-input v-model="formUser.addr" placeholder="请输入地址" />
        </el-form-item>
      </el-row>
      <el-row style="justify-content: flex-end">
        <el-form-item>
          <el-button type="primary" @click="handleCancel">取消</el-button>
          <el-button type="primary" @click="onSubmit">确定</el-button>
        </el-form-item>
      </el-row>
    </el-form>
  </el-dialog>
```

```js
	// 控制模态框的显示隐藏
    const dialogVisible = ref(false);
    //表单关闭前的操作
    const handleClose = (done) => {
      ElMessageBox.confirm("确定关闭吗?")
        .then(() => {
          proxy.$refs.userForm.resetFields();
          done();
        })
        .catch(() => {
          // catch error
        });
    };
    // 添加用户的form数据
    const formUser = reactive({
      name: "", // 添加用户的 用户名
      age: "",
      sex: "",
      birth: "",
      addr: "",
    });
    //格式转换的函数
    const timeFormat = (time) => {
      var time = new Date(time);
      var year = time.getFullYear();
      var month = time.getMonth() + 1;
      var date = time.getDate();
      function add(m) {
        return m < 10 ? "0" + m : m;
      }
      return year + "-" + add(month) + "-" + add(date);
    };
    // 区分编辑和新增
    const action = ref("add");
    // 新增用户
    const handleAdd = () => {
      action.value = "add";
      dialogVisible.value = true;
    };
    // 添加用户或者编辑用户
    const onSubmit = () => {
      //表单验证
      proxy.$refs.userForm.validate(async (valid) => {
        if (valid) {
          //验证通过后，分add与edit两种情况
          if (action.value == "add") {
            formUser.birth = timeFormat(formUser.birth);
            let res = await proxy.$api.addUser(formUser);
            if (res) {
              // console.log(proxy.$refs);
              dialogVisible.value = false;        //关闭模态框
              proxy.$refs.userForm.resetFields(); //清空表单
              getUserData(config);                //重新获取展示的数据
            }
          } else {
            // 编辑的接口
            formUser.sex == "男" ? (formUser.sex = 1) : (formUser.sex = 0);
            let res = await proxy.$api.editUser(formUser);
            if (res) {
              // console.log(proxy.$refs);
              dialogVisible.value = false;
              proxy.$refs.userForm.resetFields();
              getUserData(config);
            }
          }
        } else {
          ElMessage({
            showClose: true,
            message: "请输入正确的内容",
            type: "error",
          });
        }
      });
    };
    // 编辑用户
    const handleEdit = (row) => {
      action.value = "edit";
      dialogVisible.value = true;
      row.sex == 1 ? (row.sex = "男") : (row.sex = "女");
      //问题：点击编辑后取消，数据应该不见，而下一步点击新增时数据仍在
      //借助nextTick时间循环机制，异步操作assign有一个时间差
      proxy.$nextTick(() => {
        // 浅拷贝
        Object.assign(formUser, row);
      });
    };
    // 删除用户
    const handleDelete = (row) => {
      ElMessageBox.confirm("你确定删除吗?")
        .then(async () => {
          await proxy.$api.deleteUser({
            id: row.id,
          });

          ElMessage({
            showClose: true,
            message: "删除成功",
            type: "success",
          });
          getUserData(config);
        })
        .catch(() => {
          // catch error
        });
    };
    // 取消
    const handleCancel = () => {
      dialogVisible.value = false;
      proxy.$refs.userForm.resetFields();
    };
    return {
      list,
      tableLabel,
      config,
      changePage,
      formInline,
      handleSearch,
      dialogVisible,
      handleClose,
      formUser,
      action,
      handleAdd,
      onSubmit,
      handleEdit,
      handleDelete,
      handleCancel,
    };
```

## 19、权限管理登录页面

### 19.1、创建登录页面

在登录页面中使用el-form创建登录表单，其中双向绑定loginForm，以及编写点击登录方法login

在登录方法中，用到了vuex中的store传递数据，即将其中的菜单进行动态添加并展示

还用到了router，在登录保存数据完毕后进行页面的跳转。

Login.vue

```vue
<template>
    <el-form :model="loginForm" class="login-container">
      <h3>系统登录</h3>
      <el-form-item>
        <el-input
          type="input"
          placeholder="请输入账号"
          v-model="loginForm.username"
        >
        </el-input>
      </el-form-item>
      <el-form-item>
        <el-input
          type="password"
          placeholder="请输入密码"
          v-model="loginForm.password"
        >
        </el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="login"> 登录 </el-button>
      </el-form-item>
    </el-form>
  </template>
  <script>
  import { reactive } from "vue-demi";
  import { getCurrentInstance } from "vue-demi";
  import { useStore } from "vuex";
  import { useRouter } from "vue-router";
  export default {
    setup() {
      const loginForm = reactive({
        username: "admin",
        password: "admin",
      });
      const { proxy } = getCurrentInstance();
      const store = useStore();
      const router = useRouter();
      const login = async () => {
        const res = await proxy.$api.getMenu(loginForm);
        // console.log(res);
        store.commit("setMenu", res.menu);
        store.commit("addMenu", router);
        router.push({
          name: "home",
        });
      };
      return {
        loginForm,
        login,
      };
    },
  };
  </script>
  <style lang="less" scoped>
  .login-container {
    width: 350px;
    background-color: #fff;
    border: 1px solid #eaeaea;
    border-radius: 15px;
    padding: 35px 35px 15px 35px;
    box-shadow: 0 0 25px #cacaca;
    margin: 180px auto;
    h3 {
      text-align: center;
      margin-bottom: 20px;
      color: #505450;
    }
    :deep(.el-form-item__content) {
      justify-content: center;
    }
  }
  </style>
```

### 19.2、添加登录路由以及修改主页路由

将登录页面的路由添加至router/index.js中，并且由于主页的路由需要动态添加，可将childern中的路由全部注释掉

router/index.js

```js
//按需引入，createWebHashHistory使用路由的方式
import { createRouter, createWebHashHistory } from 'vue-router'

//定义routes作为路由的配置
const routes = [
  {
    path: '/',
    component: () => import('../views/Main.vue'),
    name: 'home1',
    redirect: '/home',
    children: []
    // children: [
    //   {
    //     path: '/home',
    //     name: 'home',
    //     component: () => import('../views/home/Home.vue')
    //   },
    //   {
    //     path: '/user',
    //     name: 'user',
    //     component: () => import('../views/User/User.vue')
    //   },
    //   {
    //     path: '/page1',
    //     name: 'page1',
    //     component: () => import('../views/Page1.vue')
    //   },
    //   {
    //     path: '/page2',
    //     name: 'page2',
    //     component: () => import('../views/Page2.vue')
    //   }
    // ],
  },
  {
    path: '/login',
    name: 'login',
    component: () => import('../views/Login.vue')
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

### 19.3、mock模拟数据

在api/mockData中新增premission.js，用来模拟点击登录按钮后，后端返回的数据，其中针对不同的用户名、密码会返回不同的页面

api/mockData/premission.js

```js
import Mock from 'mockjs'
export default {
  getMenu: config => {
    const { username, password } = JSON.parse(config.body)
    // 先判断用户是否存在
    // 判断账号和密码是否对应
    if (username === 'admin' && password === 'admin') {
      return {
        code: 200,
        data: {
          menu: [
            {
              path: '/home',
              name: 'home',
              label: '首页',
              icon: 'house',
              url: 'home/Home'
            },
            {
              path: '/mall',
              name: 'mall',
              label: '商品管理',
              icon: 'video-play',
              url: 'mall/index'
            },
            {
              path: '/user',
              name: 'user',
              label: '用户管理',
              icon: 'user',
              url: 'User/User'
            },
            {
              label: '其他',
              icon: 'location',
              children: [
                {
                  path: '/page1',
                  name: 'page1',
                  label: '页面1',
                  icon: 'setting',
                  url: 'Page1'
                },
                {
                  path: '/page2',
                  name: 'page2',
                  label: '页面2',
                  icon: 'setting',
                  url: 'Page2'
                }
              ]
            }
          ],
          token: Mock.Random.guid(),
          message: '获取成功'
        }
      }
    } else if (username === 'xiaoxiao' && password === 'xiaoxiao') {
      return {
        code: 200,
        data: {
          menu: [
            {
              path: '/',
              name: 'home',
              label: '首页',
              icon: 's-home',
              url: 'home/index'
            },
            {
              path: '/video',
              name: 'video',
              label: '商品管理',
              icon: 'video-play',
              url: 'mall/index'
            }
          ],
          token: Mock.Random.guid(),
          message: '获取成功'
        }
      }
    } else {
      return {
        code: -999,
        data: {
          message: '密码错误'
        }
      }
    }

  }
}
```

在mock.js中设置拦截路径，调用premission.js

api/mock.js：

```js
import Mock from 'mockjs'
import homeApi from './mockData/home'
import userApi from './mockData/user'
import permissionApi from './mockData/permission'
//拦截请求
Mock.mock('/home/getData',homeApi.getHomeData)

// 本地获取user的数据
Mock.mock(/user\/getUser/, 'get', userApi.getUserList)
Mock.mock(/user\/add/, 'post', userApi.createUser)
Mock.mock(/user\/edit/, 'post', userApi.updateUser)
Mock.mock(/user\/delete/, 'get', userApi.deleteUser)
Mock.mock(/permission\/getMenu/, 'post', permissionApi.getMenu)
```

在api.js中增加获取页面菜单的方法getMenu(params)

api/api.js

```js
	// 根据用户的用户名不同 返回不一样的菜单列表
    getMenu(params) {
        return request({
            url: '/permission/getMenu',
            method: 'post',
            // 这个mock如果是true的话 用的就是线上fastmock的数据
            mock: false,
            data: params
        })
    }
```

### 19.4、store增加方法

针对vuex，在store/index.js中增加属性menu，方法setMenu(state, val)、addMenu(state, router)

setMenu(state, val)用来保存menu数据

addMenu(state, router)用来动态添加路由

store/index.js：

```js
import { createStore } from 'vuex'
// import Cookie from 'js-cookie'
export default createStore({
  state: {
    isCollapse: true,
    currentMenu: null,
    tabsList: [
      {
        path: '/',
        name: 'home',
        label: '首页',
        icon: 'home'
      }
    ],
    menu: [],
  },
  mutations: {
    updateIsCollapse(state, payload) {
      // console.log(payload);
      state.isCollapse = !state.isCollapse
    },
    selectMenu(state, val) {
      // 判断
      // val.name == 'home' ? (state.currentMenu = null) : (state.currentMenu = val)

      if (val.name == 'home') {
        state.currentMenu = null
      } else {
        state.currentMenu = val
        let result = state.tabsList.findIndex(item => item.name === val.name)
        result == -1 ? state.tabsList.push(val) : ''
      }
    },
    closeTab(state, val) {
      let res = state.tabsList.findIndex(item => item.name === val.name)
      state.tabsList.splice(res, 1)
    },
    setMenu(state, val) {
      state.menu = val
      localStorage.setItem('menu', JSON.stringify(val))
    },
    addMenu(state, router) {
      if (!localStorage.getItem('menu')) {
        return
      }
      const menu = JSON.parse(localStorage.getItem('menu'))
      state.menu = menu

      const menuArray = []

      menu.forEach(item => {
        if (item.children) {
          item.children = item.children.map(item => {
            let url = `../views/${item.url}.vue`

            item.component = () => import(url)
            return item
          })
          menuArray.push(...item.children)
        } else {
          let url = `../views/${item.url}.vue`
          item.component = () => import(url)
          menuArray.push(item)
        }
      })

      menuArray.forEach(item => {
        router.addRoute('home1', item)
      })
    },

  }
})
```

### 19.5、main.js修改

为避免刷新页面后数据丢失，可以在main.js中先行调用addMenu(state, router)方法

main.js：

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
// import ElementPlus from 'element-plus'
// import 'element-plus/dist/index.css'
import './assets/less/index.less'
import * as ElementPlusIconsVue from '@element-plus/icons-vue'
import store from './store/index.js'
import './api/mock.js'          //启用mock,如果为在线mock，可以不用引入
import api from './api/api'     //配置api,使用axios的二次封装获取数据

const app = createApp(App)
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
    app.component(key, component)
}

//全局挂载api
app.config.globalProperties.$api = api

//防止刷新后数据丢失
store.commit("addMenu", router);

app.use(router)
app.use(store)
//完整引入element-plus
// app.use(ElementPlus)
app.mount('#app')
```

### 19.6、侧边栏数据修改

原来用来读取页面路由的list注释掉，使用从store中存放的menu进行替代生成asyncList对象，下面noChildren方法以及hasChildren方法中的list也要用asyncList替换掉

```vue
<template>
    <el-aside :width="$store.state.isCollapse ? '180px' : '64px' ">
        <el-menu class="el-menu-vertical-demo" background-color="#545c64" text-color="#fff" :collapse="!$store.state.isCollapse" :collapse-transition="false">    <!-- :collapse-transition="false"关闭动画 -->
            <h3 v-show="$store.state.isCollapse">后台管理系统</h3>
            <h3 v-show="!$store.state.isCollapse">后台</h3>
            <el-menu-item :index="item.path" v-for="item in noChildren()" :key="item.path" @click="clickMenu(item)">
                <!-- <el-icon><icon-menu /></el-icon> -->
                <!-- 动态引入icon -->
                <component class="icons" :is="item.icon"></component>
                <span>{{item.label}}</span>
            </el-menu-item>
            <el-sub-menu :index="item.label" v-for="item in hasChildren()" :key="item.path">
                <template #title>
                    <component class="icons" :is="item.icon"></component>
                    <span>{{item.label}}</span>
                </template>
                <el-menu-item-group>
                    <el-menu-item :index="subItem.path" v-for="(subItem,subIndex) in item.children" :key="subIndex" @click="clickMenu(subItem)">
                        <component class="icons" :is="subItem.icon"></component>
                        <span>{{subItem.label}}</span>
                    </el-menu-item>
                </el-menu-item-group>
            </el-sub-menu>
        </el-menu>
    </el-aside>
</template>

<script>
import {useRouter} from 'vue-router';
import { useStore } from 'vuex';
export default {
    setup() {
        const store = useStore()
        // const list = [
        //     {
        //         path: "/user",
        //         name: "user",
        //         label: "用户管理",
        //         icon: "user",
        //         url: "UserManage/UserManage",
        //     },
        //     {
        //         label: "其他",
        //         icon: "location",
        //         path: "/other",
        //         children: [
        //             {
        //                 path: "/page1",
        //                 name: "page1",
        //                 label: "页面1",
        //                 icon: "setting",
        //                 url: "Other/PageOne",
        //             },
        //             {
        //                 path: "/page2",
        //                 name: "page2",
        //                 label: "页面2",
        //                 icon: "setting",
        //                 url: "Other/PageTwo",
        //             }
        //         ],
        //     },
        // ];

        const router = useRouter();

        const asyncList = store.state.menu;

        const noChildren = () => {
            // return list.filter((item) => !item.children);
            return asyncList.filter((item) => !item.children);
        };

        const hasChildren = () => {
            // return list.filter((item) => item.children);
            return asyncList.filter((item) => item.children);
        };

        const clickMenu = (item) => {
            router.push({
                name:item.name,
            });
            store.commit("selectMenu",item);
        };

        return {
            noChildren,
            hasChildren,
            clickMenu,
        }
    }
}
</script>

<style lang="less" scoped>
.icons{
    width: 18px;
    height: 18px;
    margin-right: 10px;
}
.el-menu{
    border-right: none;
    h3 {
        line-height: 48px;
        color: #fff;
        text-align: center;
    }
}
</style>
```

## 20、页面跳转路由守卫

在刚刚完成的登录页面后，启动项目会直接进入/home路由，因此要设置路由守卫使得没有登录时进入登录/login路由。

路由守卫通过能否获得token来判断是否登录，而token存放在cookie中

如果登录成功，判断当前路由是否为正常路由，即能否通过filter过滤找到，如果找不到则跳转至/home首页

### 20.1、安装js-cookie

```bash
yarn add js-cookie@3.0.1
```

### 20.2、store中设置tooken属性、cookie方法

首先在store/index.js中导入刚才下载好的cookie，然后在state中补充tooken属性，以及在mutations中填写

setToken(state, val)、clearToken(state)、getToken(state)三种方法

store/index.js

```js
import { createStore } from 'vuex'
import Cookie from 'js-cookie'
export default createStore({
  state: {
    isCollapse: true,
    currentMenu: null,
    tabsList: [
      {
        path: '/',
        name: 'home',
        label: '首页',
        icon: 'home'
      }
    ],
    menu: [],
    token: ''
  },
  mutations: {
    updateIsCollapse(state, payload) {
      // console.log(payload);
      state.isCollapse = !state.isCollapse
    },
    selectMenu(state, val) {
      // 判断
      // val.name == 'home' ? (state.currentMenu = null) : (state.currentMenu = val)

      if (val.name == 'home') {
        state.currentMenu = null
      } else {
        state.currentMenu = val
        let result = state.tabsList.findIndex(item => item.name === val.name)
        result == -1 ? state.tabsList.push(val) : ''
      }
    },
    closeTab(state, val) {
      let res = state.tabsList.findIndex(item => item.name === val.name)
      state.tabsList.splice(res, 1)
    },
    setMenu(state, val) {
      state.menu = val
      localStorage.setItem('menu', JSON.stringify(val))
    },
    addMenu(state, router) {
      if (!localStorage.getItem('menu')) {
        return
      }
      const menu = JSON.parse(localStorage.getItem('menu'))
      state.menu = menu

      const menuArray = []

      menu.forEach(item => {
        if (item.children) {
          item.children = item.children.map(item => {
            let url = `../views/${item.url}.vue`

            item.component = () => import(url)
            return item
          })
          menuArray.push(...item.children)
        } else {
          let url = `../views/${item.url}.vue`
          item.component = () => import(url)
          menuArray.push(item)
        }
      })

      menuArray.forEach(item => {
        router.addRoute('home1', item)
      })
    },
    cleanMenu(state) {
      state.menu = []
      localStorage.removeItem('menu')
    },
    setToken(state, val) {
      state.token = val
      Cookie.set('token', val)
    },
    clearToken(state) {
      state.token = ''
      Cookie.remove('token')
    },
    getToken(state) {
      state.token = state.token || Cookie.get('token')
    }
  }
})
```

### 20.3、登录时保存token

在login.vue中增加保存cookie的方法，store.commit("setToken", res.token);

Login.vue：

```vue
<template>
  <el-form :model="loginForm" class="login-container">
    <h3>系统登录</h3>
    <el-form-item>
      <el-input
        type="input"
        placeholder="请输入账号"
        v-model="loginForm.username"
      >
      </el-input>
    </el-form-item>
    <el-form-item>
      <el-input
        type="password"
        placeholder="请输入密码"
        v-model="loginForm.password"
      >
      </el-input>
    </el-form-item>
    <el-form-item>
      <el-button type="primary" @click="login"> 登录 </el-button>
    </el-form-item>
  </el-form>
</template>
<script>
import { reactive } from "vue-demi";
import { getCurrentInstance } from "vue-demi";
import { useStore } from "vuex";
import { useRouter } from "vue-router";
export default {
  setup() {
    const loginForm = reactive({
      username: "admin",
      password: "admin",
    });
    const { proxy } = getCurrentInstance();
    const store = useStore();
    const router = useRouter();
    const login = async () => {
      const res = await proxy.$api.getMenu(loginForm);
      // console.log(res);
      store.commit("setMenu", res.menu);
      store.commit("addMenu", router);
      store.commit("setToken", res.token);
      router.push({
        name: "home",
      });
    };
    return {
      loginForm,
      login,
    };
  },
};
</script>
<style lang="less" scoped>
.login-container {
  width: 350px;
  background-color: #fff;
  border: 1px solid #eaeaea;
  border-radius: 15px;
  padding: 35px 35px 15px 35px;
  box-shadow: 0 0 25px #cacaca;
  margin: 180px auto;
  h3 {
    text-align: center;
    margin-bottom: 20px;
    color: #505450;
  }
  :deep(.el-form-item__content) {
    justify-content: center;
  }
}
</style>
```

### 20.4、main.js完成路由守卫

在main.js中使用beforeEach完成路由守卫的工作，先将token存放在state中，然后从state中取出token，如果不能取到token以及来源路径不是login，那么就跳转至login。

通过checkRouter(path)检查当前路径是否正常，能否通过filter匹配得到，如果不能那么就跳转至home

main.js：

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
// import ElementPlus from 'element-plus'
// import 'element-plus/dist/index.css'
import './assets/less/index.less'
import * as ElementPlusIconsVue from '@element-plus/icons-vue'
import store from './store/index.js'
import './api/mock.js'
import api from './api/api'
const app = createApp(App)
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component)
}
// app.use(ElementPlus)

//全局挂载api
app.config.globalProperties.$api = api
store.commit("addMenu", router);

function checkRouter(path) {
  let hasCheck = router.getRoutes().filter(route => route.path == path).length
  if (hasCheck) {
    return true
  } else {
    return false
  }
}

router.beforeEach((to, from, next) => {
  store.commit('getToken')
  const token = store.state.token
  if (!token && to.name !== 'login') {
    next({ name: 'login' })
  } else if (!checkRouter(to.path)) {
    next({ name: 'home' })
  } else {
    next()
  }
})
app.use(router).use(store)
app.mount('#app')
```

## 21、退出

在CommonHeader.vue组件中的退出标签中加入点击退出方法@click="handleLoginOut"

![image-20221216222004395](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221216222004395.png)

点击@click="handleLoginOut"，会调用store中的cleanMenu方法以及clearToken方法，清除掉保存在本地的数据，然后使用router跳转至登录页面

```js
		//退出后需要跳转至登录页面，以及清空保留的信息
        const router = useRouter();
        const handleLoginOut = () => {
            store.commit("cleanMenu");
            store.commit("clearToken");
            router.push({
                name: "login",
            });
        };
        return {
            getImgSrc,
            handleCollapse,
            current,
            handleLoginOut,
        }
```

在store/index.js中增加cleanMenu方法

```js
	cleanMenu(state) {
      state.menu = []
      localStorage.removeItem('menu')
    }
```

