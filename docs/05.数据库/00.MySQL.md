---
title: MySQL
date: 2023-02-03 23:21:41
permalink: /pages/1c8947/
categories:
  - 数据库
tags:
  - 
---
# MySQL

## 0、解决MySQL数据库无法连接问题

==以管理员权限打开cmd==

```bash
mysqld -install

net start mysql
```

## 1、初识数据库

### 1.1、什么是数据库

数据库（DB，DataBase）

概念：数据仓库，一个软件，安装在操作系统（windows、linux、mac、...）之上，SQL可存储大量的数据，500万

作用：存储数据、管理数据

### 1.2、数据库分类

关系型数据库：（SQL）

- MySQL、Oracle、Sql Server、DB2、SQLlite
- 通过表和表之前、列和列之间的关系进行数据存储，学员信息表、考勤表...

非关系型数据库：（NoSQL）Not Only

- Redies、MongDB
- 非关系型数据库，对象存储，通过对象的自身属性来决定

==DBMS（数据库管理系统）==

- 数据库的管理软件，科学有效的管理我们的数据。维护和获取数据
- MySQL，数据库管理系统

### 1.3、MySQL简介

MySQL是一个关系性数据库管理系统

前世：瑞典MySQL AB公司

今生：属于Oracle旗下产品

MySQL是最好的RDBMS（关系型数据库管理系统）应用软件之一

开源的数据库软件、体积小、速度快

[MySQL官网](https://www.mysql.com/)

### 1.4、使用Navicat创建数据库与表

![image-20221222203735788](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221222203735788.png)



![image-20221222204229939](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221222204229939.png)

### 1.5、数据库的列类型

#### 1.5.1、数值

- tinyint	               十分小的数据	              1个字节
- smallint                较小的数据                     2个字节
- mediumint           中等大小的数据             3个字节
- **int                         标准的整数                     4个字节            常用的int**
- bigint                    较大的数据                     8个字节
- float                      浮点数                             4个字节
- double                  浮点数                             8个字节（精度问题）
- decimal                字符串形式的浮点数     金融计算的时候，一般使用        decmial(5,2)

#### 1.5.2、字符串

- char                      字符串固大小                   0~255
- **varchar                 可变字符串                       0~65535             常用的变量    String**
- tinytext                 微型文本                           2^8^-1
- **text                        文本串                              2^16^-1                   保存大文本**

#### 1.5.3、枚举

- enum                 enum(‘男’,’女’)

#### 1.5.4、时间日期

java.util.Date

- date                     YYYY-MM-DD                        日期格式
- time                     HH:mm:ss                            时间格式

- **datetime             YYYY-MM-DD HH:mm:ss      最常用的时间格式**
- **timestamp           时间戳：1970.1.1到现在的毫秒数**
- year                      年份表示

#### 1.5.5、null

- 没有值，未知
- ==不要使用null进行计算，否则结果为null==

### 1.6、数据库的字段属性

#### 1.6.1、Unsigned

- 无符号的整数
- 声明了该列数据不能为负数

#### 1.6.2、zerofill

- 0填充
- 不足的位数，使用0来填充  00005

####  1.6.3、auto_increment

- 通常理解为自增，自动在上一条的记录基础上+1（默认是1）
- 通常用来设计唯一的主键（index），必须是整数类型
- 可以自定义设计主键自增的起始值和步长

#### 1.6.4、not null

- 非空
- 设置该属性后，如果不给赋值，就会报错
- Null 如果不填写值，默认就是null

#### 1.6.5、default

- 设置默认的值
- sex 默认是男，如果不指定该列的值，则会有默认的值

#### 1.6.6、comment

- 字段名称注释			comment '主键'

### 1.7、数据库引擎

mysql默认使用引擎INNODB，还有MYISAM（早些年使用）

|            | MYISAM | INNODB                |
| ---------- | ------ | --------------------- |
| 事务支持   | 不支持 | 支持                  |
| 数据行锁定 | 不支持 | 支持                  |
| 外键约束   | 不支持 | 支持                  |
| 全文索引   | 支持   | 不支持                |
| 表空间大小 | 较小   | 较大，约为MYISAM的2倍 |

常规使用操作：

- MYISAM	节约空间，速度快
- INNODB   安全性高，事务的处理，多表多用户操作

> 数据库在物理空间存放的位置

所有数据库文件都存放在data目录下，一个文件夹就对应一个数据库

本质还是文件的存储！

MySQL引擎在物理文件上的区别

- INNODB在数据表中只有一个*.ibd文件，以及上级目录下的ibdata1文件
- MYISAM对应文件
  - *.frm 	表结构的定义文件
  - *.MYD   数据文件（data）
  - *.MYI    索引文件（index）

## 2、MySQL常用命令

### 2.1、登录和退出数据库

1. 登录数据库  mysql -uroot -p
2. 显示时间  select now();
3. 退出数据库  exit;或quit;或ctrl+d

4. 数据库密码  mysql

### 2.2、数据库操作的SQL语句

1. 查看所有数据库  show databases;
2. 创建数据库  create database 数据库名 charset=utf8;
3. 使用数据库  use 数据库名;
4. 查看当前使用的数据库  select database();
5. 删除数据库  drop database if exists 数据库名;
6. 查看创建数据库的语句  show create database 数据库名;

### 2.3、表结构操作的SQL语句

1. 查看当前数据库中所有表  show tables;

2. 查看表的结构 describe students;

3. 创建表   

   > create table 表名(字段名称 数据类型 可选的约束条件,);

   if not exists                           如果不存在相同名称的表

   engine=innodb                     指定所用数据库引擎

   default charset=utf8mb4     指定字符集，当然根据数据库也可以使用utf8

   ```sql
   create table if not exists students(
       id int unsigned primary key auto_increment not null comment '主键',
       name varchar(20) not null comment '姓名',
       age tinyint unsigned default 0 comment '年龄',
       height decimal(5,2) comment '身高',
       gender enum('男','女') comment '性别'
   )engine=innodb default charset=utf8mb4;
   ```

4. 修改表 - 修改表名

   > alter table 表名 rename as 新表名 

   ```sql
   alter table students rename as student
   ```

5. 修改表 - 添加birthday字段

   > alter table 表名 add 列名 类型 约束;

   ```sql
   alter table students add birthday datetime;
   ```

6. 修改表 - 修改字段类型

   > alter table 表名 modify 列名 类型 约束;

   ```sql
   alter table students modify birthday date not null;
   ```

7. 修改表 - 修改字段名和字段类型

   > alter table 表名 change 原名 新名 类型及约束;

   ```sql
   alter table students change birthday birth datetime not null;
   ```

8. 修改表 - 删除birthday字段

   > alter table 表名 drop 列名;

   ```sql
   alter table students drop birthday;
   ```

9. 查看创表SQL语句

   > show create table 表名;

   ```sql
   show create table students;
   ```

10. 删除表

    > drop table 表名;

    ```sql
    drop table students
    ```

### 2.4、表数据操作的SQL语句

#### 2.4.1、查询数据

1. 查询所有列

   > select * from 表名;

   ```sql
   select * from students;
   ```

2. 查询指定列

   > select 列1,列2,… from 表名;

   ```sql
   select id,name, from students;  
   ```

3. 查询系统版本

   ```sql
   select version();	-- 查询系统版本（函数）
   ```

4. 查询数据计算

   ```sql
   select 100*3-1 as ‘计算结果’;		-- 用来计算 （表达式）
   ```

5. 查询自增步长

   ```sql
   select @@auto_increment_increment; 		-- 查询自增的步长（变量）
   ```

#### 2.4.2、添加数据

1. 全列插入：值的顺序与表结构字段的顺序完全一一对应（可以指定id，也可以使用id默认值）

   > insert into 表名 values(…);

   ```sql
   insert into students values(0,'xx',default,'男');
   ```

2. 部分列插入：值的顺序与给出的列的顺序相对应

   > insert into 表名(列1,…) value(值1,…);

   ```sql
   insert into students(name,age) values('王小二',15);
   ```

3. 全列多行插入

   > insert into 表名 values(…),(…),(…),…;

   ```sql
   insert into students values(0,'xx',1,1.5,'男'),(0,'cc',2,1.6,'女'),(0,'yy',3,1.7,'男');
   ```

4. 部分列多行插入：

   > insert into 表名(列1,…) value(值1,…),(值1,…),(值1,…)…;

   ```sql
   insert into students(name,age) values('王小二',15),('王小二',15),('王小二',15);
   ```

#### 2.4.3、修改数据

> update 表名 set 列1=值1，列2=值2… where 条件

```sql
update students set age=18, gender='女', where id=6;
```

#### 2.4.4、删除数据

不会影响自增

> delete from 表名 where 条件

```sql
delete from students where id=5；
```

#### 2.4.5、清空数据

自增清零

> truncate 表名

```sql
truncate students
```

### 2.5、as、distinct关键字、concat函数

#### 2.5.1、使用as给字段起别名

```sql
select id as 序号, name as 名字, gender as 性别 from students;
```

#### 2.5.2、使用as给表起别名  

1. 如果是单表查询，可以省略表名

   ```sql
   select id,name,gender from students;
   ```

2. 表名.字段名

   ```sql
   select students.id,students.name,students.gender from students;
   ```

3. 通过as给表起别名

   ```sql
   select s.id,s.name,s.gender from students as s;
   ```

#### 2.5.3、使用distinct去除重复数据行 

> select distinct 列1,… from 表名;

```sql
select distinct name,gender from students;
```

#### 2.5.4、使用concat函数来拼接字符串

```sql
select concet(‘姓名：’,name) as ‘新名字’ from students;
```

### 2.6、条件查询 where

**where语句支持的运算符有：比较运算符、逻辑运算符、范围查询、模糊查询、空判断**

> select * from 表名 where 条件;

```sql
select * from students where id=1;
```

#### 2.6.1、比价运算符  =  >  >=  <  <=  !=或<>

1. 查询编号大于3的学生

   ```sql
   select * from students where id>3;
   ```

2. 查询编号不大于4的学生

   ```sql
   select * from students where id<=4;
   ```

3. 查询姓名不是“张三”的学生

   ```sql
   select * from students where name != '张三';
   ```

4. 查询没有被删除的学生

   ```sql
   select * from students where is_delete=0;
   ```

#### 2.6.2、逻辑运算符  and or not

1. 查询编号大于3的女同学

   ```sql
   select * from students where id>3 and gender=0; 
   ```

2. 查询编号小于或没有被删除的同学

   ```sql
    select * from students where id<4 or is_delete=0;
   ```

3. 查询年龄不在10岁到15岁之间的学生

   ```sql
   select * from students where not (age >= 10 and age <=15);
   ```

#### 2.6.3、范围查询 between…and…与in

- **连续范围内查询  between…and…**
- **非连续范围查询  in**

1. 查询编号为3至8的学生

   ```sql
   select * from students where id between 3 and 8;
   ```

2. 查询编号为3，5，7的学生

   ```sql
   select * from students where id in (3,5,7);
   ```

3. 查询编号不为3，5，7的学生

   ```sql
   select * from students where id not in (3,5,7);
   ```

4. 查询编号不是3至8的男生

   ```sql
   select * from students where (not id between 3 and 8) and gender='男';
   ```

#### 2.6.4、模糊查询 like

- **like是模糊查询的关键字**
- **%表示任意多个任意关键字**
- **_表示一个任意一个字符**

1. 查询姓黄的学生 

   ```sql
   select * from students where name like '黄%';
   ```

2. 查询姓黄并且‘名’只有一个字的学生

   ```sql
   select * from students where name like '黄_';
   ```

3. 查询姓黄或叫靖的学生

   ```sql
   select * from students where name like '黄%' or name like '%靖';
   ```

#### 2.6.5、空判断查询 is null

- **判断为空  is null**
- **判断非空  is not null**

1. 查询没有填写身高的同学

   ```sql
    select * from students where height is null;
   ```

### 2.7、排序查询语法 order by

> select * from 表名 order by 列1 asc | desc [,列2 asc | desc,…]

- **先按着列1排序，再按列2 排序**
- **asc从小到大排序，即升序**
- **desc从大到小排序，即降序**
- **默认按照列值从小到大排列（即asc排序）**

1. 查询未删除男生信息，按学号降序：

   ```sql
   select * from students where gender=1 and is_delete=0 order by id desc;
   ```

2. 显示所有的学生信息，先按照年龄从大到小排序，当年龄相同时，按照身高从高到低排序 

   ```sql
   select * from students order by age desc,height desc;
   ```

### 2.8、分页查询 limit

> select * from 表名 limit start,count

- **limit是分页查询关键字**
- **start表示开始行索引，默认是0**
- **count表示查询条数**

1. 查询前三行男生信息

   ```sql
   select * from students where gender=1 limit 0,3;
   ```

2. **分页查询案列  limit (n-1)*m,m**

   已知每页显示m条数据，求第n页显示的数据

   提示：关键是求每页的开始行索引

   查询学生表，获取第n页数据的sql语句

   ```sql
   select * from students limit (n-1)*m,m
   ```

### 2.9、聚合函数

又称组函数，通常对表中的数据进行统计与计算，一般结合分组（group by）来使用，用于统计和计算分组数据。

常用的聚合函数：

1. count(col)：表示求指定列的总行数

   ```sql
   select count(*) from students;
   ```

2. max(col)：表示求指定列的最大值 

   ```sql
   select max(id) from students where gender = '女';
   ```

3. min(col)：表示求指定列的最小值

   ```sql
   select min(id) from students where is_delete = 0;
   ```

4. sum(col)：表示求指定列的和

   ```sql
   select sum(height) from students where gender='男';
   ```

5. avg(col)：表示求指定列的平均值

   ```sql
   select avg(height) from students where gender = '男'；
   ```

   如果要包含空值

   ```sql
   select avg(ifnull(height,0)) from students where gender = 1;
   ```

### 2.10、分组函数 group by

> group by 列名 [having 条件表达式] [with rollup]

**having 可以对分组后的数据进行筛选过滤**

1. 根据gender字段来分组

   ```sql
   select gender from students group by gender
   ```

2. 根据name和gender字段进行分组

   ```sql
   select name,gender from students group by name,gender;
   ```

3. 根据gender字段进行分组，查询每个分组的姓名信息 

   ```sql
   select gender,group_concat(name) from students group by gender;
   ```

4. 统计不同性别的平均年龄

   ```sql
   select gender,avg(age) from students group by gender;
   ```

5. 统计不同性别的人数

   ```sql
   select gender,count(*) from students group by gender;
   ```

6. 根据gender字段进行分组，统计分组条数大于2

   ```sql
   select gender,count(*) from students group by gender having count(* )>2;
   ```

7. 根据gender字段进行分组，汇总总人数

   ```sql
   select gender,sum(gender) from students group by gender;
   ```

8. 根据gender字段进行分组，汇总所有人年龄

   ```sql
   select gender,sum(age) from students group by gender;
   ```

### 2.11、连接函数 join

#### 2.11.1、内连接查询 inner join

查询两个表中符合条件的公共数据

> select 字段 from 表1 inner join 表2 on 表1.字段1 = 表2.字段2

1. 使用内连接查询学生表与班级表

   ```sql
   select * from students inner join classes on students.c_id = classes.id
   ```

2. 使用内连接查询学生表中的名字与班级表中的名字

   ```sql
    select s.name,c.name from students s inner join classes c on s.c_id = c.id
   ```

#### 2.11.2、左连接查询 left join

以左表为主要根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充

> select 字段 from 表1 left join 表2 on 表1.字段1 = 表2.字段2

#### 2.11.3、右连接查询 right join

以右表为主要根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充

> select 字段 from 表1 right join 表2 on 表1.字段1 = 表2.字段2

#### 2.11.4、自连接查询 inner join

左表跟右表是同一个表，根据连接查询条件查询两个表中的数据

例子可以参考上下级菜单放在一个表中

```sql
select c.id,c.title,c.pid,p.title from areas c inner join areas p on c.pid = p.id where p.title = '河北省';
```

### 2.12、子查询

子查询：嵌入到主查询中，辅助主查询，要么充当条件，要么充当数据源，并且是可以独立存在的一条完整select语句

1. 查询大于平均年龄的学生

   ```sql
   select * from students where age > (select avg(age) from studnents);
   ```

2. 查询学生在班的所有班级名字

   ```sql
   select name from classes where  id in (select cls_id from students where cls_id is not null);
   ```

3. 查询年龄最大，身高最高的学生

   ```sql
   select * from students where (age,height) = (select max(age),max(height) from students);
   ```

### 2.13、外键 foreign key

#### 2.13.1、创建表时创建外键

创建两个表格，一个名为class，另一个名为student

```sql
create table classes(
id int not null primary key,
name varchar(30)
);
```

```sql
create table student(
sid int not null primary key,
sname varchar(30),
cid int not null,
constraint fk_cid foreign key(cid) references classes(id)
);
```

这里声明外键的语法为：

> constraint 外键名 foreign key(要作为外键字段名) references 主表名(主表中关联的字段)

外键名是在这里给外键新命的名字，用来标记外键。

外键所在的表称为“从表”，主键所在的表称为主表。

#### 2.13.2、对已存在字段添加外键约束

也可以给已经存在的表格添加外键。

```sql
alter table student add constraint fk_cid foreigh key(cid) references class(id)
```

语法：

> alter table 从表名 add constraint 外键名 foreign key(cid) references 主表名(主表中关联字段名)

#### 2.13.3、删除外键约束

删除外键约束是指删除某字段的外键属性，而不是删除该字段。

```sql
alter table student drop foreign key fk_cid;
```

语法：

> alter table 从表 drop foreign key 外键名;

删除外键是根据创建外键时命名的外键名，不是外键所在的字段名。

外键关联主键后，主键所在的主表将不能被删除。从表依然可以被删除。

### 2.14、“常用”函数

“常用”函数并不常用，了解即可

#### 2.14.1、数学运算函数

1. select abs(-8)	-- 绝对值

2. select ceiling(9.4)	-- 向上取整

3. select floor(9.4)	-- 向下取整

4. select rand()	-- 返回一个[0,1)之间的随机数

5. select sign(10)	-- 判断一个数的符号，传入正数返回1，传入负数返回-1，传入0返回0

#### 2.14.2、字符串函数

1. select char_length(‘我本江湖浪荡人’)	-- 字符串长度

2. select concat(‘’你,‘好’,‘啊’)	--拼接字符串

3. select insert(‘我爱编程’,1,2,‘超级喜欢’)		--插入，从某个位置开始替换某个长度

4. select lower(‘Shujuan’)	-- 小写字母

5. selcet upper(‘Shujuan’)	-- 大写字母

6. select instr(‘Shujuan’,‘j’)		-- 返回第一次出现的子串索引

7. select replace(‘坚持就能成功’,‘坚持’,‘努力’)		-- 替换出现的指定字符串

8. select substr(‘坚持就能成功’,2,4)		-- 返回指定的子字符串（源字符串，截取的位置，截取的长度）

9. select reverse(‘吗好你’)		-- 反转字符串


#### 2.14.3、时间和日期函数

1. select current_date()	-- 获取当前日期

2. select current()	-- 获取当期的日期

3. select now()	-- 获取当前的时间

4. select localtime()		-- 获取本地时间

5. select sysdate()		-- 获取系统时间

6. select year(now())

7. select month(now())

8. select day(now())

9. select hour(now())

10. select minute(now())

11. select second(now())


#### 2.14.4、系统函数

1. select system_user()		-- 获取用户

2. select user()		-- 获取用户

3. select version()		-- 获取版本信息


### 2.15、数据库级别的MD5加密

MD5的特点在于增强了算法的复杂度并且具有不可逆性

MD5破解网站的原理：背后是一个字典

使用MD5()函数针对密码加密，例如：

插入：

```sql
insert into testmd5 values(4,‘xiaoming’,MD5(‘123456’))
```

更新：

```sql
update testmd5 set pwd=MD5(pwd)	-- 加密全部密码
```

如何校验：将用户传递进来的密码，进行md5加密，然后比对加密后的值

```sql
select * from testmd5 where name=‘xiaoming’ and pwd=MD5(‘123456’)
```

### 2.16、特殊操作

#### 2.16.1、将查询结果插入到good_cates表中

```sql
insert into good_cates(name) select cate_name from goods group by cate_name;
```

#### 2.16.2、连表查询后修改内容

```sql
update goods g inner join goods_cates gs on g.cate_name = gs.name set g.cate_name = gs.id;
```

#### 2.16.3、查询浮点数

```sql
select number from students where cast(age as char)='2.1';
```

## 3、事务

### 3.1、什么是事务

> 要么同时成功，要么同时失败

将一组SQL放在一个批次中一起执行

事务的原则：

1. 原子性（Atomicity）：要么都成功，要么都失败
2. 一致性（Consistency）：事务前后的数据完整性要保持一致
3. 持久性（Durability）：事务一旦提交则不可逆，被持久化到数据库中
4. 隔离性（Lsolation）：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的数据所干扰，事务之间要相互隔离

容易发生的问题：

1. 脏读：指一个事务读取了另外一个事务未提交的数据
2. 不可重复度：在一个事务内读取表中的某一行数据，多次读取的结果不同（不一定是错误，只是某些场合不对）
3. 幻读：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致

### 3.2、mysql默认开启事务

mysql是默认开启事务自动提交的

```sql
set autocommit = 0;	-- 关闭自动事务提交
```

```sql
set autocommit = 1;	-- 开启自动事务提及（默认是开启的）
```

### 3.3、mysql手动提交事务

```sql
-- 手动处理事务
set autocommit = 0; 	-- 关闭自动事务提交

-- 事务开启
start transaction;	-- 标记一个事务的开始，从这个之后的sql都在同一个事务内

insert xx;
insert xx;

-- 提交：持久化（成功）
commit;
-- 回滚：回到原来的样子（失败）
rollback;

-- 事务结束
set autocommit = 1;	-- 开启自动事务提交

-- 以下了解
savepoint 保存点名称;	-- 设置一个事务的保存点
rollback to savepoint 保存点名称;	-- 回滚到保存点
release savepoint 保存点名称;	-- 撤销保存点
```

测试事务实现转账

创建数据库shop以及表account

```sql
-- 转账
-- 创建数据库
create database shop charset=utf8;

-- 使用数据库
use shop

-- 创建数据表
create table account(
	id int(3) not null auto_increment,
	name varchar(30) not null,
	money decimal(9,2) not null,
    primary key (id)
)engine=innodb default charset = utf8;

-- 向表中添加数据
insert into account(name,money) values('A',2000.00),('B',10000.00);

-- 模拟转账：事务
set autocommit = 0; 	-- 关闭自动事务提交
start transaction;		-- 手动开启一个事务（一组事务）
update account set money=money-500 where name = 'A';	-- 修改A中的数据，A减少500
update account set money=money+500 where name = 'B';	-- 修改B中的数据，B增加500
commit;  -- 提交事务，一旦提交成功，就被持久化了

rollback;	-- 回滚

set autocommit = 1; 	-- 开启自动事务提交
```

## 4、索引

> MySQL官方对索引的定义是：`索引是`帮助MySQL高效获取数据的`数据结构`

参考wen'zhnag[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

### 4.1、索引分类

> 在一个表中，主键索引只能有一个，唯一索引可以有多个

- 主键索引（primary key）
  - 唯一的标识，主键不可重复，只能有一个列作为主键
- 唯一索引（unique key）
  - 避免重复的列出现，唯一索引可以重复，多个列都可以标识为唯一索引
- 常规索引（key/index）
  - 默认的，通过index/key关键字来设置
- 全文索引（fulltext）
  - 在特定的数据库引擎下才可以使用，MyISAM支持；Innodb在5.6版本后支持但只支持英文，5.7版本后支持中文
  - 快速定位到数据

### 4.2、索引使用

1. 在创建表的时候给字段增加索引
2. 创建表完毕后，增加索引

```sql
-- 显示所有的索引信息
show index from account;

-- 增加一个全文索引：索引名（列名）
alter table account add fulltext index name (name);

show index from account;

-- 创建名：id_表名_字段名
-- 创建索引：create index 索引名 on 表(字段);
create index id_app_user_name on app_user(name);

-- explain 分析sql执行的状况
explain select * from account;		--非全文索引

explain select * from account where match(name) against('B');	-- 全文索引
```

### 4.3、测试索引

#### 4.3.1、创建数据表app_user

```sql
create table app_user(
	id bigint(20) unsigned not null auto_increment,
	name varchar(50) default ' ' comment '用户昵称',
	email varchar(50) not null comment '用户邮箱',
	phone varchar(20) default ' ' comment '手机号',
	gender tinyint(4) unsigned default '0' comment '性别（0：男；1：女）',
	password varchar(100) not null comment '密码',
	age tinyint(4) default '0' comment '年龄',
	create_time datetime default current_timestamp,
	update_time timestamp not null default current_timestamp on update current_timestamp,
	primary key (id)
)engine=innodb default charset=utf8 comment='app用户表';
```

#### 4.3.2、插入数据100万条数据

```sql
-- 插入100万数据

-- 这个关键字是修改sql语句结束执行符号
delimiter $$	-- 写函数之前必须要写，标志
set global log_bin_trust_function_creators=true;
create function mock_data()
returns int
begin
	declare num int default 1000000;
	declare i int default 0;
	while i < num do
		-- 插入语句
		insert into app_user(name,email,phone,gender,password,age) values(concat('用户',i),'24736743@qq.com',concat('18',floor(rand()*999999999)),floor(rand()*2),uuid(),floor(rand()*100));
		set i=i+1;
	end while;
	return i;
end;

select mock_data();	-- 执行此函数 生成一百万条数据
```

#### 4.3.3、创建索引并查询

```sql
-- 耗时较久
select * from app_user where name='用户999999';

-- 创建名：id_表名_字段名
-- 创建索引：create index 索引名 on 表(字段);
create index id_app_user_name on app_user(name);

-- 再次执行耗时很少
select * from app_user where name='用户999999';
-- 可以看到查询行数为1
explain select * from app_user where name='用户999999';
```

### 4.4、索引原则

> 索引在小数据量的时候用处不大，但在大数据量的时候，区别十分明显~

- 索引并不是越多越好
- 不要对进程变动数据加索引
- 小数据量的表不需要加索引
- 索引一般加在常用来查询的字段上

## 5、权限管理和备份

> 可以使用可视化软件进行操作

> SQL命令操作

用户表：mysql.user

本质：对这张表进行增删改查

```sql
-- 创建用户 create user 用户名 identified by '123456';
create user chang identified by '123456';
```

```sql
-- 修改密码（修改当前用户密码）
alter user 'chang'@'%' identified by '654321';

-- 修改密码（修改指定用户的密码）
alter user 'root'@'localhost' identified by '162534';
```

```sql
-- 重命名
rename user 'chang'@'localhost' to 'chang2'@'localhost';
```

```sql
-- 授权
grant all privileges on *.* to 'root'@'localhost';
```

```sql
-- 查询权限
show grants for root@localhost;
```

```sql
-- 撤销权限
-- remove 哪些权限，在哪个库撤销，给谁撤销
remove all privileges on *.* from chang2@loaclhost;
```

```sql
-- 删除用户
drop user chang2@localhost;
```

## 6、数据库备份

为什么要备份：

- 保证重要的数据不丢失
- 数据转移

MySQL数据库备份的方式

- 直接拷贝物理文件

- 在可视化工具中手动导出

- 使用命令行导出，mysqldump 命令行使用

  ```bash
  #导出一张表
  #mysqldump -h主机 -u用户名 -p密码 数据库名 表名 > 物理位置/文件名
  mysqldump -hlocalhost -uroot -pmysql shop account > D:/account.sql
  
  #导出多张表
  #mysqldump -h主机 -u用户名 -p密码 数据库名 表1 表2 表3 > 物理位置/文件名
  
  #导出数据库
  #mysqldump -h主机 -u用户名 -p密码 数据库名 > 物理位置/文件名
  
  #重新导入进MySQL数据库
  #首先进入指定数据库中，再使用：source .sql文件
  source D:/account.sql
  #简单写法是：mysql -u用户名 -p密码 库名 < 备份文件 
  ```

## 7、规范数据库设计

### 7.1、为什么需要设计

当数据库比较复杂的时候就需要设计了

糟糕的数据库设计：

- 数据冗余，浪费空间
- 数据库插入和删除都会麻烦、异常【屏蔽使用物理外键】

良好的数据库设计

- 节省内存空间
- 保证数据库的完整性
- 方便我们开发系统

软件开发中，关于数据库的设计

- 分析需求：分析业务和需求，处理的数据库的需求
- 概要设计：设计关系图E-R图

设计数据库的步骤：（个人博客）

- 收集信息，分析需求
  - 用户表（用户登录信息、用户的个人信息、写博客、创建分类）
  - 分类表（文章分类，谁创建的）
  - 文章表（文章的信息）
  - 友链表（友链信息）
  - 自定义表（系统信息，某个关键的字，或者一些主字段）key:value
- 标识实体（把需求落实到每个字段）
- 标识实体之间的关系
  - 写博客：user->blog
  - 创建分类：user->category
  - 关注：user->user
  - 友链：links
  - 评论：user->user->blog

### 7.2、三大数据范式

**为什么需要数据范式：**

- 信息重复
- 更新异常
- 插入异常
  - 无法正常显示信息
- 删除异常
  - 丢失有效的信息

> 三大范式

**第一范式（1NF）**

原子性：保证每一列不可再分（无重复的列）

**第二范式（2NF）**

满足第一范式的前提下，每张表的属性完全依赖于主键（消除部分子函数依赖）

**第三范式（3NF）**

满足前面两个范式的前提下，确保数据表中的每一列数据都和主键直接相关，而不能间接相关，即属性不依赖于其他非主属性（消除传递依赖） 

**规范性和性能问题**

关联查询的表不能够超过三张表

- 考虑商业化的需求和目标，（成本，用户体验！）数据库的性能更加重要
- 在解决问题得同时，需要适当的考虑以下规范性
- 故意给某些表增加一些冗余的字段。（从多表查询中变单表查询）
- 故意增加一些计算列（从大数据量降低为小数据量的查询；索引）

## 8、JDBC（重点）

### 8.1、数据库驱动

程序需要通过数据库驱动和数据库打交道

### 8.2、JDBC

SUN公司为了简化开发人员的（对数据库的统一）操作，提供了一个（Java操作数据库的规范），俗称JDBC

这些规范的实现由具体的厂商去做

对于开发人员来说，我们只需要掌握JDBC接口操作即可

需要的包：

- java.sql
- javax.sql
- 还需要数据库的驱动包

### 8.3、第一个JDBC项目

#### 8.3.1、创建数据库表单

```sql
CREATE DATABASE `jdbcStudy` CHARACTER SET utf8 COLLATE utf8_general_ci;

USE `jdbcStudy`;

CREATE TABLE `users`(
 `id` INT PRIMARY KEY,
 `NAME` VARCHAR(40),
 `PASSWORD` VARCHAR(40),
 `email` VARCHAR(60),
 `birthday` DATE
);

INSERT INTO `users`(`id`,`NAME`,`PASSWORD`,`email`,`birthday`)
VALUES(1,'zhangsan','123456','zs@sina.com','1980-12-04'),
(2,'lisi','123456','lisi@sina.com','1981-12-04'),
(3,'wangwu','123456','wangwu@sina.com','1979-12-04');
```

#### 8.3.2、创建一个普通项目

![image-20221225002731960](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221225002731960.png)

#### 8.3.3、导入数据库驱动

在主目录下新建lib目录，并将mysql驱动jar包拷贝粘贴到该目录下

由于本地的mysql数据库为8.0.19版本，故导入的驱动为mysql-connector-java-8.0.19.jar

**之后需要对lib文件夹右键并“Add as Library”，此时才算导入到项目的库中**

![image-20221225003857271](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221225003857271.png)

![image-20221225004043887](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221225004043887.png)

#### 8.3.4、编写测试代码

步骤总结：

1. 加载驱动（JDBC5.0以后可以不需要加载驱动）

2. 设定连接的url、username、password

   ```java
   // mysql -- 3306
   // 协议 ://主机地址：端口号/数据库名？参数1&参数2&参数3
   
   // oracle -- 1521
   // jdbc:oracle:thin:@localhost:1521:sid
   ```

3. 使用DriverManager连接数据库，获取数据库对象connection

   ```java
   //数据库设置自动提交
   connection.setAutoCommit();
   
   //事务提交
   connection.commit();
   
   //事务回滚
   connection.rollback();
   ```

4. 使用connection数据库对象创建sql语句执行对象statement

   jdbc的statement对象用于向数据库发送sql语句，想完成对数据库的增删改查，只需要对这个对象向数据库发送增删改查语句即可。

   statement对象的executeUpdate方法，用于向数据库发送增、删、改的sql语句，executeUpdate执行完成后，将会返回一个整数（即增删改语句导致了数据库内几行数据发生了变化）。

   Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的ResultSet对象。

   ```java
   //查询操作返回ResultSet
   statement.executeQuery();
   
   //更新、插入、删除都是用这个，返回一个受影响的行数
   statement.executeUpdate();
   
   //执行任何SQL
   statement.execute();
   
   //将一批命令提交到数据库执行，并且所有命令都执行成功后，返回一个更新计数的数组
   statement.executeLargeBatch();
   ```

5. 使用statement语句执行对象执行相关语句，并获取结果对象resultSet

   ```java
   //在不知道类型的情况下使用
   resultSet.getObject();
   
   //如果知道列的类型就使用指定的类型
   resultSet.getString();
   resultSet.getInt();
   resultSet.getFloat();
   resultSet.getDate();
   ...
       
   //遍历：指针
   resultSet.beforeFirst();	//移动到最前面
   resultSet.afterLast();		//移动到最后面
   resultSet.next();			//移动到下一个数据
   resultSet.previous();		//移动到前一行
   resultSet.absolute(row);	//移动到指定的某一行
   ```

6. 从下到上，依次关闭连接

   ```java
   resultSet.close();
   statement.close();
   connection.close();
   ```

7. 完整代码

```java
package com.chang.lesson01;

import java.sql.*;

//我的第一个jdbc程序
public class jdbcFirstDemo {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //1、加载驱动
        //固定写法，使用反射加载驱动，mysql8.0以上需要在“mysql.”后面加上“cj.”
        //JDBC5.0以后可以不需要加载驱动
        //Class.forName("com.mysql.cj.jdbc.Driver");

        //2、用户信息和url
        //支持中文编码并设置为utf8:useUnicode=true&characterEncoding=utf8
        //mysql版本高于jdbc时&useSSL=true会报错，需要改为false
        //如果报错显示时区问题，在url后面加&serverTimezone=GMT%2B8
        String url="jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=GMT%2B8";
        String username="root";
        String password="mysql";

        //3、连接成功，返回数据对象
        //connection代表数据库对象
        Connection connection = DriverManager.getConnection(url, username, password);

        //4、执行sql的对象 statement
        Statement statement = connection.createStatement();

        //5、执行sql的对象执行sql，可能存在结果，查看返回结果
        String sql="select * from users;";
        ResultSet resultSet = statement.executeQuery(sql);  //返回结果集，以链表形式存放，结果集中封装了我们全部的查询出来的结果

        while(resultSet.next()){
            System.out.println("id="+resultSet.getObject("id"));
            System.out.println("name="+resultSet.getObject("NAME"));
            System.out.println("pwd="+resultSet.getObject("PASSWORD"));
            System.out.println("email="+resultSet.getObject("email"));
            System.out.println("birthday="+resultSet.getObject("birthday"));
            System.out.println("---------------");
        }

        //6、关闭数据库连接
        resultSet.close();
        statement.close();
        connection.close();
    }
}
```

#### 8.3.5、使用工具类解耦

首先在src目录下创建db.properties配置类文件

```properties
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=GMT%2B8
username=root
password=mysql
```

![image-20221225145736873](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221225145736873.png)

然后创建一个工具包utils，在该包下创建工具类jdbcUtils.java

在该工具类中通过反射获取配置文件中的各项信息，并给定建立连接以及释放资源的两个函数

```java
package com.chang.lesson02.utils;

import java.io.IOException;
import java.io.InputStream;
import java.sql.*;
import java.util.Properties;

//创建读取配置文件的工具类
public class jdbcUtils {

    private static String driver=null;
    private static String url=null;
    private static String username=null;
    private static String password=null;

    static {
        try{
            //通过类获取反射对象，然后获取反射对象的类加载器，调用类加载器的获取资源的方法。
            InputStream in = jdbcUtils.class.getClassLoader().getResourceAsStream("db.properties");
            //创建配置对象（map子接口Properties类）
            Properties properties = new Properties();
            properties.load(in);
            driver=properties.getProperty("driver");
            url=properties.getProperty("url");
            username=properties.getProperty("username");
            password=properties.getProperty("password");
            //驱动只需要加载一次
            //Class.forName(driver);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    //获取连接
    public static Connection getConnection() throws SQLException {
        Connection connection = DriverManager.getConnection(url, username, password);
        return connection;
    }
    //释放资源
    public static void release(Connection conn, Statement st, ResultSet rs){
        if(rs!=null){
            try{
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(st!=null){
            try{
                st.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(conn!=null){
            try{
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

在业务代码中使用建立建立的函数创建数据库对象，并使用该对象创建statement对象

```java
package com.chang.lesson02;

import com.chang.lesson02.utils.jdbcUtils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class TestInsert {
    public static void main(String[] args) {
        Connection conn=null;
        Statement st=null;
        ResultSet rs=null;

        try {
            conn = jdbcUtils.getConnection();   //获取数据库连接
            st = conn.createStatement();        //获取sql语句执行对象
            String sql="insert into users(id,NAME,PASSWORD,email,birthday) values(4,'zhaoliu','123456','zha\n" +
                    "oliu@sina.com','2022-12-25');";
            int i = st.executeUpdate(sql);
            if(i>0){
                System.out.println("插入成功！");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            jdbcUtils.release(conn,st,rs);
        }

    }
}
```

#### 8.3.6、PreparedStatement对象

PreparedStatement可以防止sql注入，并且效率更高

防止sql注入的本质是把传递进来的参数当作字符，假设其中存在转义字符，比如说 ‘ 会被直接转义

特点是：先使用占位符给定用执行的sql语句，将该sql语句作为参数传入PreparedStatement中，然后再进行赋值操作，之后运行

具体增删改查的使用参考以下代码：

```java
package com.chang.lesson03;

import com.chang.lesson02.utils.jdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Date;

public class TestInsert {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement st = null;

        try {
            conn = jdbcUtils.getConnection();
            //区别

            //使用？占位符代替参数
            String sql="insert into users(id,NAME,PASSWORD,email,birthday) values(?,?,?,?,?)";
            st=conn.prepareStatement(sql); //预编译sql，先写sql，然后不换行

            //手动给参数赋值
            st.setInt(1,5);
            st.setString(2,"liqi");
            st.setString(3,"123456");
            st.setString(4,"liqi@sina.com");
            //注意点：sql.Date   数据库     java.sql.Date()
            //      util.Date   java     new Date().getTime()获取时间戳
            st.setDate(5,new java.sql.Date(new Date().getTime()));

            //执行
            int i = st.executeUpdate();
            if(i>0){
                System.out.println("插入成功！");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            jdbcUtils.release(conn,st,null);
        }
    }
}
```

```sql
package com.chang.lesson03;

import com.chang.lesson02.utils.jdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TestDelete {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement st = null;

        try {
            conn = jdbcUtils.getConnection();
            //区别

            //使用？占位符代替参数
            String sql="delete from users where id = ?";
            st=conn.prepareStatement(sql); //预编译sql，先写sql，然后不换行

            //手动给参数赋值
            st.setInt(1,5);

            //执行
            int i = st.executeUpdate();
            if(i>0){
                System.out.println("删除成功！");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            jdbcUtils.release(conn,st,null);
        }
    }
}

```

```sql
package com.chang.lesson03;

import com.chang.lesson02.utils.jdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TestUpdate {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement st = null;

        try {
            conn = jdbcUtils.getConnection();
            //区别

            //使用？占位符代替参数
            String sql="update users set name = ? , email = ? where id = ?";
            st=conn.prepareStatement(sql); //预编译sql，先写sql，然后不换行

            //手动给参数赋值
            st.setString(1,"liuqi");
            st.setString(2,"liuqi@sina.com");
            st.setInt(3,5);

            //执行
            int i = st.executeUpdate();
            if(i>0){
                System.out.println("更新成功！");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            jdbcUtils.release(conn,st,null);
        }
    }
}
```

```sql
package com.chang.lesson03;

import com.chang.lesson02.utils.jdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class TestSelect {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement st = null;
        ResultSet rs= null;
        try {
            conn = jdbcUtils.getConnection();
            //区别

            //使用？占位符代替参数
            String sql="select * from users where id = ?";

            st=conn.prepareStatement(sql); //预编译sql，先写sql，然后不换行

            //手动给参数赋值
            st.setInt(1,5);

            //执行
            rs = st.executeQuery();
            if(rs.next()){
                System.out.println(rs.getString("NAME"));
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            jdbcUtils.release(conn,st,rs);
        }
    }
}
```

#### 8.3.7、操作事务

要么都成功，要么都失败

> ACID原则

```java
//关闭数据库的自动提交，并自动开启事务
conn.setAutoCommit(false);
```

```java
//业务完毕提交事务
conn.commit();
```

```java
//如果失败则回滚事务
conn.rollback();    
```

具体代码如所示：

捕获到1/0这个错误，进行回滚

```java
package com.chang.lesson04;

import com.chang.lesson02.utils.jdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class TestTransaction1 {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement st = null;
        ResultSet rs = null;

        try {
            conn = jdbcUtils.getConnection();

            //关闭数据库的自动提交，并自动开启事务
            conn.setAutoCommit(false);

            //编写相关sql语句
            String sql1 = "update users set name = 'zhangsan' where name = '张三'";
            st = conn.prepareStatement(sql1);
            st.executeUpdate();

            int x=1/0;

            String sql2 = "update users set name = 'lisi' where name = '李四' and password='12345'";
            st = conn.prepareStatement(sql2);
            st.executeUpdate();

            //业务完毕提交事务
            conn.commit();
            conn.setAutoCommit(true);
            System.out.println("事务操作成功");
        } catch (Exception e) {
            try {
                System.out.println("事务执行失败");
                conn.rollback();    //如果失败则回滚事务
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
            e.printStackTrace();
        } finally {
            jdbcUtils.release(conn,st,rs);
        }
    }
}
```

#### 8.3.8、数据库连接池

数据库连接——执行完毕——释放

连接——释放	是非常浪费资源的操作

**池化技术：准备一些预先的资源，过来就连接预先准备好的**

最小连接数：10

最大连接数：15

等待超时：100ms

编写连接池，实现一个接口 DataSource

> 开源数据库连接池

- DBCP
- C3P0
- Druid（阿里巴巴产品）

使用这些数据库连接池之后，我们在项目中就不需要编写连接数据库的代码了

#### 8.3.9、DBCP

首先添加两个包commons-dbcp-1.4.jar与commons-pool-1.6.jar

![image-20221225181618206](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221225181618206.png)

然后在src目录下创建dbcpconfig.properties配置文件：

```properties
#连接设置 这里的名字是dbcp数据源中定义好的，不可修改
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=GMT%2B8
username=root
password=mysql

#<!-- 初始化连接 -->
initialSize=10

#最大连接数量
maxActive=50

#<!-- 最大空闲连接 -->
maxIdle=20

#<!-- 最小空闲连接 -->
minIdle=5

#<!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 -->
maxWait=60000
#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：【属性名=property;】
#注意："user" 与 "password" 两个属性会被明确地传递，因此这里不需要包含他们。
connectionProperties=useUnicode=true;characterEncoding=UTF8

#指定由连接池所创建的连接的自动提交（auto-commit）状态。
defaultAutoCommit=true

#driver default 指定由连接池所创建的连接的只读（read-only）状态。
#如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix）
defaultReadOnly=

#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。
#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE
defaultTransactionIsolation=READ_UNCOMMITTED
```

在lesson05文件夹中创建utils工具包，并创建jdbcUtils_dbcp.java文件，创建数据库连接以及释放资源

jdbcUtils_dbcp.java:

```java
package com.chang.lesson05.utils;

import com.chang.lesson02.utils.jdbcUtils;
import org.apache.commons.dbcp.BasicDataSourceFactory;

import javax.sql.DataSource;
import java.io.IOException;
import java.io.InputStream;
import java.sql.*;
import java.util.Properties;

public class jdbcUtils_dbcp {

    //提高作用域
    private static DataSource dataSource = null;

    static {
        try{
            //通过类获取反射对象，然后获取反射对象的类加载器，调用类加载器的获取资源的方法。
            InputStream in = jdbcUtils.class.getClassLoader().getResourceAsStream("dbcpconfig.properties");
            //创建配置对象（map子接口Properties类）
            Properties properties = new Properties();
            properties.load(in);

            //创建数据源 工厂模式->创建
            dataSource = BasicDataSourceFactory.createDataSource(properties);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    //获取连接
    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();  //从数据源中获取连接
    }
    //释放资源
    public static void release(Connection conn, Statement st, ResultSet rs){
        if(rs!=null){
            try{
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(st!=null){
            try{
                st.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(conn!=null){
            try{
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

编写测试代码TestDBCP

```java
package com.chang.lesson05;

import com.chang.lesson05.utils.jdbcUtils_dbcp;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Date;

public class TestDBCP {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement st = null;

        try {
            conn = jdbcUtils_dbcp.getConnection();
            //区别

            //使用？占位符代替参数
            String sql="insert into users(id,NAME,PASSWORD,email,birthday) values(?,?,?,?,?)";
            st=conn.prepareStatement(sql); //预编译sql，先写sql，然后不换行

            //手动给参数赋值
            st.setInt(1,6);
            st.setString(2,"chenjiu");
            st.setString(3,"123456");
            st.setString(4,"chenjiu@sina.com");
            //注意点：sql.Date   数据库     java.sql.Date()
            //      util.Date   java     new Date().getTime()获取时间戳
            st.setDate(5,new java.sql.Date(new Date().getTime()));

            //执行
            int i = st.executeUpdate();
            if(i>0){
                System.out.println("插入成功！");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            jdbcUtils_dbcp.release(conn,st,null);
        }
    }
}
```

#### 8.3.10、C3P0

首先添加两个包c3p0-0.9.5.5.jar与mchange-commons-java-0.2.19.jar，并在src目录下创建c3p0-config.xml文件作为数据库连接池的配置文件

![image-20221225222023219](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20221225222023219.png)

c3p0-config.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
    <!--
c3p0的缺省（默认）配置
如果在代码中"ComboPooledDataSource ds=new ComboPooledDataSource();"这样写就表示使用的是c3p0的缺省（默认）-->
    <default-config>
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;uesSSL=true&amp;serverTimezone=UTC&amp;serverTimezone=GMT%2B8</property>
        <property name="user">root</property>
        <property name="password">mysql</property>

        <property name="acquireIncrement">5</property>
        <property name="initialPoolSize">10</property>
        <property name="minPoolSize">5</property>
        <property name="maxPoolSize">20</property>
    </default-config>
</c3p0-config>
```

创建工具类jdbcUtils_c3p0，所作的修改只是创建数据源发生了变化，更加简单

```java
package com.chang.lesson05.utils;

import com.chang.lesson02.utils.jdbcUtils;
import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.commons.dbcp.BasicDataSourceFactory;

import javax.sql.DataSource;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class jdbcUtils_c3p0 {
    //提高作用域
    private static DataSource dataSource = null;

    static {
        try{
            //创建数据源 工厂模式->创建
            dataSource = new ComboPooledDataSource("MySQL");    //配置文件写法
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //获取连接
    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();  //从数据源中获取连接
    }
    //释放资源
    public static void release(Connection conn, Statement st, ResultSet rs){
        if(rs!=null){
            try{
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(st!=null){
            try{
                st.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        if(conn!=null){
            try{
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

使用工具类进行测试

TestC3P0.java

```java
package com.chang.lesson05;

import com.chang.lesson05.utils.jdbcUtils_c3p0;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Date;

public class TestC3P0 {
    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement st = null;

        try {
            conn = jdbcUtils_c3p0.getConnection();
            //区别

            //使用？占位符代替参数
            String sql="insert into users(id,NAME,PASSWORD,email,birthday) values(?,?,?,?,?)";
            st=conn.prepareStatement(sql); //预编译sql，先写sql，然后不换行

            //手动给参数赋值
            st.setInt(1,7);
            st.setString(2,"menshi");
            st.setString(3,"123456");
            st.setString(4,"menshi@sina.com");
            //注意点：sql.Date   数据库     java.sql.Date()
            //      util.Date   java     new Date().getTime()获取时间戳
            st.setDate(5,new java.sql.Date(new Date().getTime()));

            //执行
            int i = st.executeUpdate();
            if(i>0){
                System.out.println("插入成功！");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            jdbcUtils_c3p0.release(conn,st,null);
        }
    }
}
```

> 结论

无论使用什么样的数据源，本质还是一样的，DataSource接口不改变，方法就不会改变。

