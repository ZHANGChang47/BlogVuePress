---
title: Java基础总结
date: 2023-01-30 20:07:35
permalink: /pages/969e0f/
categories:
  - Java基础
tags:
  - 
---
# 1、Java基础复习

## 1、Java常识

![image-20220925202327938](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20220925202327938.png)

![image-20220925210658844](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20220925210658844.png)

JavaSE：18~20

数据库：4

前端：7

JavaWeb：7

SSM框架：9

Linux：7

SpringBoot：8

SpringCloud：7

Hadoop：8 

***

JavaSE：标准版（桌面程序、控制台开发...）

JavaME：嵌入式开发（手机、小家电...）

JavaEE：企业级开发（web端、服务器开发...）

***

JDK：Java开发者工具

JRE：Java运行时环境

JVM：Java虚拟机

***

Java在cmd中运行 Hello.java

```bash
#首先进入对应文件夹，编译源代码，使用javac生成class文件 
javac Hello.java

#运行class文件
java Hello
```

***

![image-20220925220616278](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20220925220616278.png)

## 2、常用Doc

```bash
#切换盘符
D:

#查看当前目录下的文件
dir

#切换目录
cd
cd /d f:
cd /d E:\ide
cd ..

#清理屏幕
cls

#退出终端 
exit

#查看ip
ipconfig

#打开应用
calc
mspaint
notepad

#ping 命令
ping www.baidu.com

#创建目录
md test

#创建一个文件
cd>a.txt

#删除一个文件
del a.txt

#删除目录
rd test
```

## 3、Java基础知识

### 1、注释

单行注释：//

多行注释：/*   */

文本注释：/**

​							*@Description Hello

​							*@Description World

​							*/

​						[有趣的代码注释整理](https://blog.csdn.net/ydk888888/article/details/81563608)

### 2、标识符

Java中的类名、变量名以及方法名都被称为标识符

关键字不能做标识符

### 3、类型

基本数据类型：byte（1字节）、short（2）、int（4） 、long（8 | 30L）、float（4 | 10.2F）、

​								   double（8 |  3.1415926）、char（2）、boolean（1位）

引用数据类型：类、数组、接口

位（bit）：是计算机 `内部数据` 存储的最小单位，11101100是一个八位的二进制数

字节（byte）：是计算机中 `数据处理` 的基本单位，习惯上用大写B来表示

1B = 8bit

字符：是指计算机中使用的字母、数字、字和符号

### 4、数据类型扩展

JDK7新特性，数字之间可以使用下划线进行分割：int money = 10_0000_0000; 

当数据溢出int时，会出现负数

二进制：0b

十进制

八进制：0

十六进制：0x	0~9 A~F

```java
int i=10;		//10
int i2=010;		//8
int i3=0x10;	//16
```

***

浮点数存在舍入误差，接近但不等于

银行业务等最好使用**`BigDecimal`**这个数学工具类比较

***

字符char：A=65，a=97

转义字符：\t 制表符    \n换行

### 5、变量

要素包括变量名、变量类型、作用域

成员变量：

- 成员变量在类的范围里定义的的变量
- 成员变量有默认的初始值
- 未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同
- 被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同

局部变量

- 局部变量是在方法里定义的变量

- 局部变量是没有默认初始值

- 局部变量存储于栈内存中，作用范围结束，变量空间会自动释放

### 6、JavaDOC

JavaDoc命令用来生成自己API文档的

- @author	作者名
- @version	版本号
- @since		指明需要最早使用的jdk版本
- @param	 参数名
- @return	  返回值情况
- @throws	 异常抛出情况

```bash
javadoc -encoding UTF-8 -charset UTF-8 Doc.java
```

javadoc 参数 java文件

### 7、命令行传参

有时候希望运行一个程序时候再给它传消息，这要靠传递命令行参数给main()函数实现

```java
package com.chang;

public class Main {
    public static void main(String[] args) {
        for(int i=0;i<args.length;i++){
            System.out.println("args["+i+"]:"+args[i]);
        }
    }
}
```

```shell
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java\com\chang> javac Main.java
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java\com\chang> cd ../
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java\com> cd ../
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java> java com.chang.Main
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java> java com.chang.Main Hello World !
args[0]:Hello
args[1]:World
args[2]:!
PS C:\Users\DELL\OneDrive\Knowledge\0.JZOffer\src\main\java>
```

### 8、可变参数

在JDK1.5开始，Java支持传递同类型的可变参数给一个方法

在方法的声明中，在指定参数**类型**后加一个省略号（...）

一个方法只能指定一个可变参数，它必须是方法的**最后一个参数**。任何普通的参数必须在它之前声明。

```java
public class Main {
    public static void main(String[] args) {
        //两种传参方法
        double res=getALL(10.5,new int[]{1,2,3});
        double res=getALL(10.5,1,2,3);
        System.out.println(res);
    }

    public static double getALL(double f,int... num){
        //输出可变参数的长度
        System.out.println(num.length);
        
        for(int i : num){
            //强制基本类型数据的类型转换  int ——> double
            f+=i;
        }
        
        return f;
    }
}
```

## 4、注解与反射

注解不是程序本身，可以对程序做出解释，可以被其他程序（比如：编译器等）读取

注解Annotation是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：

```java
@SuppressWarnings(value="unchecked")
```

### 1、元注解

元注解就是负责注解其他注解，Java中定义了4个标准的meta-annotation类型，它们被用来提供对其他的annotation类型进行说明

这些类型和它们所支持的类在Java.lang.annotation包中找到

- @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）
- @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE<CLASS<**RUNTIME**）
- @Document：说明该注解被包含在javadoc中
- @Inherited：说明子类可以继承父类中的该注解

### 2、自定义注解

使用@interface自定义注解，自动继承java.lang.annotation.Annotation接口

分析：

- @interface用来声明一个注解，格式：public @interface 注解名 {定义内容}
- 其中的每一个方法实际上声明了一个配置参数
- 方法的名称就是参数的名称
- 返回值类型就是参数的类型，返回值只能是基本类型Class、String、enum
- 可以通过default来声明参数的默认值
- 如果只有一个参数成员，一般参数名未value
- 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值 

```java
package com.chang.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

public class Test03 {
    //注解可以显示赋值，如果没有默认值，我们必须给注解赋值
//    @MyAnnotation2(name="zhangChang",schools = {"西安交大、西安电子"})
    @MyAnnotation2()
    public void test(){

    }

    @MyAnnotation3("niHao")
    public void test2(){

    }
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation2{
    //注解的参数：参数类型 + 参数名() default 默认值
    String name() default "";
    int age() default 0;
    int id() default -1;//如果默认值为-1，代表找不到、不存在

    String[] schools() default {"西安交大、西安电子"};
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation3{
    String value();
}
```

### 3、反射概述

Java.Reflection

动态语言是一类在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的改变，通俗点说就是在运行时代码可以根据某些条件改变自身的结构

主要的动态语言：Object-C、C#、JavaScript、PHP、Python等

静态语言与动态语言相对应，运行时结构不可变的语言就是静态语言。如Java、C、C++

Java不是动态语言，但Java可以被称为“准动态语言”。即java有一定的动态性。我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活

Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行 期间借助于Reflection API获取任何类的内部信息，并能直接操作任意对象的内部属性及方法

```java
Class c = Class.forName("java.lang.String")
```

加载完类后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称为反射。

正常方式：引入需要的“包类”名称——>通过new关键字实例化——>取得实例化对象

反射方式：实例化对象——>getClass()方法——>取得完整的“包类”名称

反射的优点：可以实现动态创建对象和编译，体现很大的灵活性。

反射的缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。

```java
java.lang.Class：代表一个类
java.lang.reflect.Method：代表类的方法
java.lang.reflect.Field：代表类的成员变量
java.lang.reflect.Constructor：代表类的构造器
```

### 4、获取Class类的实例

1. 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高

   ```java
   Class clazz = Person.class; 
   ```

2. 已知某个类的实例，调用该实例的getClass()方法获取class对象

   ```java
   Class clazz = person.getClass();
   ```

3. 已知一个类的全名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException

   ```java
   Class clazz = Class.forName("com.compue.Student");
   ```

4. 内置基本数据类型的包装类可以直接使用类名.type

5. 还可以利用ClassLoader

### 5、哪些类型可以有class对象

class：外部类、成员（成员内部类、静态内部类）、局部内部类、匿名内部类

interface：接口

[]：数组

enum：枚举

annotation：注解@interface

primitive type：基本数据类型

void

### 6、什么时候发生类的初始化

- 类的主动引用：
  - 当虚拟机启动，先初始化main方法所在的类
  - new一个类的对象
  - 调用类的静态成员（除了final常量）和静态方法
  - 使用java.lang.reflect包的方法对类进行反射调用
  - 当初始化一个类，如果父类没有被初始化，则先初始化它的父类
- 类的被动引用（不会发生类的初始化）：
  - 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化
  - 通过数组定义类引用，不会触发此类的初始化
  - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）

### 7、使用反射调用注解

```java
package com.chang.annotation;

import java.lang.annotation.*;
import java.lang.reflect.Field;

//练习反射操作注解
public class Test04 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
        Class<?> c1 = Class.forName("com.chang.annotation.Students");

        //通过反射获取注解
        Annotation[] annotations = c1.getAnnotations();
        for(Annotation annotation:annotations){
            System.out.println(annotation);
        }

        //获得注解的value的值
        TableStudents tableStudents = c1.getAnnotation(TableStudents.class);
        String value = tableStudents.value();
        System.out.println(value);

        //获得类指定的注解
        Field f = c1.getDeclaredField("name");
        FieldStudents fieldStudents = f.getAnnotation(FieldStudents.class);
        System.out.println(fieldStudents.columnName());
        System.out.println(fieldStudents.type());
        System.out.println(fieldStudents.length());
    }
}

//类名的注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface TableStudents{
    String value();
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface FieldStudents{
    String columnName();
    String type();
    int length();
}

@TableStudents("db_student")
class Students{
    @FieldStudents(columnName = "db_id",type = "int",length = 10)
    private int id;
    @FieldStudents(columnName = "db_age",type = "int",length = 10)
    private int age;
    @FieldStudents(columnName = "db_name",type = "varchar",length = 10)
    private String name;

    public Students() {
    }

    public Students(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Students{" +
                "id=" + id +
                ", age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}

/*
@com.chang.annotation.TableStudents(value=db_student)
db_student
db_name
varchar
10
*/
```

## 5、多线程编程

### 1、继承Thread类

- 自定义线程类继承**Thread**类
- 重写**run()**方法，编写线程执行体
- 创建线程对象，调用**start()**方法启动线程

```java
package com.chang.Thread;

//创建线程方式一：继承Thread类，重写run()方法，调用start()开启线程

//线程开启并不一定立即执行，由CPU调度

public class TestThread1 extends Thread{

    @Override
    public void run() {
        //run方法线程体
        for(int i=0;i<20;i++){
            System.out.println("我在看代码。。。"+i);
        }
    }

    public static void main(String[] args) {
        TestThread1 testThread1 = new TestThread1();
        testThread1.start();

        //main主线程
        for(int i=0;i<20;i++){
            System.out.println("我在学习多线程。。。"+i);
        }
    }
}
```

### 2、实现Runable接口

- 定义MyRunable类实现Runable接口
- 实现Run()方法，编写线程执行体
- 创建实现类对象以及代理类对象，调用start()方法

```java
package com.chang.Thread;

public class TestThread2 implements Runnable{
    @Override
    public void run() {
        for(int i=0;i<20;i++){
            System.out.println("我在看代码。。。"+i);
        }
    }

    public static void main(String[] args) {
        //创建Runable接口的实现类对象
        TestThread2 testThread2 = new TestThread2();
        //创建线程对象，通过线程对象来开启我们的线程，代理
        Thread thread = new Thread(testThread2);
        thread.start();

        for(int i=0;i < 20;i++){
            System.out.println("我在学习多线程。。。"+i);
        }
    }
}
```

### 3、初识并发问题

```java
package com.chang.Thread;

//多个线程同时操作一个对象
//买火车票
//发现问题，多个线程操作同一个资源的情况下，线程不安全，数据紊乱
public class TestThread3 implements Runnable{

    //票数
    private int ticketNums=10;

    @Override
    public void run() {
        while (true){
            if(ticketNums<=0){
                break;
            }
            //模拟延时
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"-->拿到了第"+ticketNums--+"张票");
        }
    }

    public static void main(String[] args) {
        TestThread3 testThread3 = new TestThread3();

        //开启三个线程
        new Thread(testThread3,"小明").start();
        new Thread(testThread3,"小红").start();
        new Thread(testThread3,"黄牛党").start();
    }
}
```

龟兔赛跑问题

```java
package com.chang.Thread;

//模拟龟兔赛跑
public class Race implements Runnable{
    //胜利者，使用static确保只有一个
    private static String winner;

    @Override
    public void run() {
        for(int i=1;i<=100;i++){
            //模拟兔子睡觉休息
            if(Thread.currentThread().getName().equals("兔子") && i%15==0){
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //判断比赛是否结束
            boolean flag = gameOver(i);
            //如果比赛结束就停止程序
            if(flag){
                break;
            }
            System.out.println(Thread.currentThread().getName()+"——>跑了"+i+"步");
        }
    }

    //判断是否完成比赛
    private boolean gameOver(int steps){
        if(winner!=null){
            return true;
        }
        if(steps>=100){
            winner=Thread.currentThread().getName();
            System.out.println("Winner is "+ winner);
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        //定义一条赛道
        Race race= new Race();

        //定义龟兔
        new Thread(race,"乌龟").start();
        new Thread(race,"兔子").start();
    }

}
```

### 4、实现Callable接口

- 实现Callable接口，需要返回值类型
- 重写Call方法，需要抛出异常
- 创建目标对象
- 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);
- 提交执行：Future\<Boolean\> result1 = ser.submit(t1);
- 获取结果：boolean r1 = result1.get();
- 关闭服务：ser.shutdownNow();

### 5、lambda表达式

函数式接口是Lambda关键所在

函数式接口定义：

任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口

```java
public interface Runable{
    public abstract void run();
}
```

对于函数式接口，我们可以通过lambda表达式来创建该接口的对象

### 6、静态代理对象

```java
package com.chang.Thread;

//静态代理模式总结：
    //真实对象和代理对象都要实现某一个共有接口
    //代理对象要代理真实角色
//好处：
    //代理对象可以做很多真实对象做不了的事情
    //真实对象专注做自己的事情
public class StaticProxy {
    public static void main(String[] args) {
        WeddingCompany weddingCompany = new WeddingCompany(new You());
        weddingCompany.HappyMarry();
    }
}

interface Marry{
    void HappyMarry();
}

class You implements Marry{
    @Override
    public void HappyMarry() {
        System.out.println("张先生作为新郎来到婚礼现场");
    }
}

class WeddingCompany implements Marry{
    //被代理的对象、真实目标角色，通过构造器传进来
    private Marry target;

    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void HappyMarry() {
        before();
        this.target.HappyMarry();   //这就是真实对象
        after();
    }

    public void after() {
        System.out.println("婚礼结束，收拾会场");
    }

    public void before() {
        System.out.println("婚礼开始，主持现场");
    }
}
```

### 7、线程停止

```java
package com.chang.Thread;

//测试stop
//1、建议线程正常停止——>利用次数，不建议死循环
//2、建议使用标志位——>设置一个标志位
//3、不要使用stop或者destroy等过时或者JDK不建议使用的方法
public class ThreadStop implements Runnable{

    //设置一个私有的标志位
    private boolean flag=true;

    @Override
    public void run() {
        int i=0;
        while (flag){
            System.out.println("run...Thread"+i++);
        }
    }

    private void stop(){
        this.flag=false;
    }

    public static void main(String[] args) {
        ThreadStop threadStop = new ThreadStop();
        new Thread(threadStop).start();

        for (int i = 0; i < 100; i++) {
            System.out.println("main"+i);
            if(i==90){
                //调用stop方法切换标志位，让线程停止
                threadStop.stop();
                System.out.println("线程停止了");
            }
        }
    }
} 
```

### 8、线程同步

```java
package com.chang.Thread;

public class UnsafeBuyTicket {
    public static void main(String[] args) {
        BuyTicket station = new BuyTicket();

        new Thread(station,"小明").start();
        new Thread(station,"小红").start();
        new Thread(station,"黄牛").start();

    }
}

class BuyTicket implements Runnable{

    //票
    private int ticketNums = 1000;
    private boolean flag=true;//外部停止方式

    @Override
    public void run() {
        //买票
        while (flag){
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    private synchronized void buy() throws InterruptedException {
        //判断是否有票
        if(ticketNums<=0){
            flag=false;
            return;
        }
        Thread.sleep(100);
        //买票
        System.out.println(Thread.currentThread().getName()+"拿到"+ticketNums--);
    }
}
```

也可以使用synchronized同步代码块

synchronized默认锁的是this

锁的对象就是变化的量，需要增删改查的对象

```java
new Thread(()->{
	synchroniaed(list){
        list.add(Thread.currentThread().getName()); 
    }   
}).start();
```

### 9、Lock锁

```java
package com.chang.Thread;

import java.util.concurrent.locks.ReentrantLock;

public class TestLock {
    public static void main(String[] args) {
        TestLock2 testLock2 = new TestLock2();

        new Thread(testLock2).start();
        new Thread(testLock2).start();
        new Thread(testLock2).start();
    }
}

class TestLock2 implements Runnable{

    int ticketNums=10;

    //定义锁
    private final ReentrantLock lock = new ReentrantLock();


    @Override
    public void run() {
        while (true){
            try{
                lock.lock();//加锁
                if(ticketNums>0){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(ticketNums--);
                }else {
                    break;
                }
            }finally {
                lock.unlock();//解锁
            }
        }
    }
}
```

### 10、生产者消费者模型

#### 利用缓冲区解决：管程法

```java
package com.chang.Thread;

//测试：生产者消费者模型——>利用缓冲区解决：管程法
public class TestPC {
    public static void main(String[] args) {
        SynContainer container = new SynContainer();
        Producer producer = new Producer(container);
        producer.start();
        Consumer consumer = new Consumer(container);
        consumer.start();
    }
}

//生产者
class Producer extends Thread{
    SynContainer container;

    public Producer(SynContainer container){
        this.container=container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            container.push(new Chicken(i));
            System.out.println("生产了"+i+"只鸡");
        }
    }
}

//消费者
class Consumer extends Thread{
    SynContainer container;

    public Consumer(SynContainer container){
        this.container=container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("消费了——>"+container.pop().id+"只鸡");
        }
    }
}

//产品
class Chicken{
    int id;//产品编号

    public Chicken(int id){
        this.id=id;
    }
}

//缓冲区
class SynContainer{
    //需要一个容器大小
    Chicken[] chickens = new Chicken[10];

    //容器计数器
    int count = 0;

    //需要生产者放入产品
    public synchronized void push(Chicken chicken){
        //如果容器满了要等待消费者消费
        if(count==chickens.length){
            //通知消费者消费，生产者等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //如果没有满则放入
        chickens[count]=chicken;
        count++;
        //可以通知消费者消费了
        this.notifyAll();
    }

    //需要消费者取走产品
    public synchronized Chicken pop(){
        //判读能否消费
        if(count==0){
            //等待生产者生产，消费者等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //如果可以消费；
        count--;
        Chicken chicken = chickens[count];
        //吃完了，通知生产者生产
        this.notifyAll();

        return chicken;
    }
}
```

#### 信号灯法，标志位解决

```java
package com.chang.Thread;

//测试生产者消费者模型2-->信号灯法，标志位解决
public class TestPC2 {
    public static void main(String[] args) {
        TV tv = new TV();
        new Player(tv).start();
        new Watcher(tv).start();
    }
}

//生产者——>演员
class Player extends Thread{
    TV tv;
    public Player(TV tv){
        this.tv=tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if(i%2==0){
                this.tv.play("快乐大本营播放中");
            }else {
                this.tv.play("广告");
            }
        }
    }
}

//消费者——>观众
class Watcher extends Thread{
    TV tv;
    public Watcher(TV tv){
        this.tv=tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            tv.watch();
        }
    }
}

//产品——>节目
class TV{
    //演员表演，观众等待 T
    //演员等待，观众观看 F
    String voice;   //表演的节目
    boolean flag = true;

    //表演
    public synchronized void play(String voice){
        if(!flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("演员表演："+voice);
        //通知观众观看
        this.notifyAll();
        this.voice=voice;
        this.flag=!this.flag;
    }

    //观看
    public synchronized void watch(){
        if(flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("观看了："+voice);
        //通知演员表演
        this.notifyAll();
        this.flag=!this.flag;
    }
}
```

### 11、线程池

```java
package com.chang.Thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

//测试线程池
public class TestPool {
    public static void main(String[] args) {
//        MyThread myThread = new MyThread();
//        new Thread(myThread).start();

        //1、创建服务，创建线程池
        //newFixedThreadPool 参数为：线程池的大小
        ExecutorService service = Executors.newFixedThreadPool(10);

        //执行
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());

        //2、关闭链接
        service.shutdown();
    }
}

class MyThread implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

## 6、集合框架

### 1、集合概念

对象的容器，实现了对对象常用的操作

**和数组的区别**

1. 数组长度固定，集合长度不固定
2. 数组可以存储基本类型和引用类型，集合只能存储引用类型

**位置**

java.util.*;

### 2、Collection体系

![img](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/1998506-20200830225616629-1434055405.png)

1、Collection父对象

特点：代表一组任意类型的对象，无序、无下标、不能重复。

创建集合 `Collection collection = new ArrayList();`

**常用方法**

```java
boolean add(Object obj)	//添加一个对象

boolean addAll(Collection c)	//将一个集合中的所有对象添加到此集合中

boolean remove(Object o)	//在此集合中移除o对象
    
void clear()	//清空此集合中的所有对象
    
boolean contains(Object o)	//检查此集合中是否包含o对象
    
boolean equals(Object o)	//比较此集合是否域指定对象相等
    
boolean isEmpty()	//判断此集合是否为空
    
int size()	//返回此集合中的元素个数
    
Object[] toArray()	//将此集合转换成数组
```

```java
package com.chang.Collections;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.ListIterator;

public class Demo1 {
    public static void main(String[] args) {
        //创建集合
        Collection collection = new ArrayList();
        collection.add("苹果");
        collection.add("西瓜");
        collection.add("香蕉");
        System.out.println("元素个数："+collection.size());
        System.out.println(collection);
        //删除元素
        collection.remove("香蕉");
//        collection.clear();
        System.out.println(collection);
        //遍历集合
        System.out.println("遍历方式1：lambda表达式");
        collection.forEach(o -> System.out.println(o));
        System.out.println("遍历方式2：增强for循环");
        for (Object o : collection) {
            System.out.println(o);
        }
        System.out.println("遍历方式3：迭代器");
        Iterator it = collection.iterator();
        while (it.hasNext()){
            String object = (String)it.next();  //强转
            System.out.println(object);
            //可以使用it.remove();移除元素
            //collection.remove();不能用collection其他方法，会报并发修改错误
        }
        //判断是否包含某元素以及集合是否为空
        System.out.println(collection.contains("西瓜"));
        System.out.println(collection.isEmpty());
    }
}
```

### 3、List子接口

特点：有序、有下标、元素可以重复

方法：

```java
void add(int index,Object o)	//在index位置插入对象o
    
boolean addAll(int index,Collection c)	//将一个集合中的元素添加到此集合中的index位置
    
Object get(int index)	//返回集合中指定位置的元素
    
int indexOf(Object o)	//获取o在集合中的位置
    
List sublist(int fromIndex,int toIndex)	//返回fromIndex和toIndex之间的集合元素，左闭右开
```

常用方法：

1. 添加元素 `list.add( );` 会对基本类型进行自动装箱

2. 删除元素 可以用索引 `list.remove(0)`

   当删除数字与索引矛盾时 对数字强转

   `list.remove((Object) 10)` 或 `list.remove(new Integer(10))`

3. 遍历

   1. 使用for遍历

      ```java
      for(int i = 0; i < lise.size(); i++){
        sout(list.get(i)); 
      }
      ```

   2. 使用增强for

      `for(Object list: collection){ }`

   3. 使用迭代器

      ```java
      Iterator it = collection.iterator();
      while(it.hasNext()){
        String object = (String)it.next(); //强转
        // 可以使用it.remove(); 进行移除元素
        // collection.remove(); 不能用collection其他方法 会报并发修改异常
      }
      ```

   4. 使用列表迭代器 💡（注意和迭代器区别）

      ```java
      ListIterator li = list.listIterator();
      while(li.hasNext()){
        System.out.println(li.nextIndex() + ":" + li.next()); //从前往后遍历
      }
      
      while(li.hasPrevious()){
        System.out.println(li.previousIndex() + ":" + li.previous()); //从后往前遍历
      }
      ```

4. 获取 `list.indexOf( );`

5. 返回子集合 `sublist(x, y);` 左闭右开

   `List subList = list.subList(1, 3);` 返回索引 1、2

#### List实现类

- ArrayList 【重点】
  - 数组结构实现，必须要连续空间，查询快、增删慢
  - jdk1.2版本，运行效率块、线程不安全
- Vector
  - 数组结构实现，查询快、增删慢
  - jdk1.0版本，运行
- LinkedList
  - 双向链表结构实现，无需连续空间，增删快，查询慢

### 4、ArrayList

创建集合 `ArrayList arrayList = new ArrayList<>();`

1. 添加元素 `arrayList.add();`

2. 删除元素 `arrayList.remove(new Student("name", 10));`

   这里重写了 equals(this == obj) 方法

   ```java
   public boolean equals(Object obj){
     //1 判断是不是同一个对象
     if(this == obj){
       return true;
     }
     //2 判断是否为空
     if(obj == null){
       return false;
     }
     //3 判断是否是Student类型
     if(obj instanceof Student){
       Student s = (Student)obj;
       //4 比较属性
       if(this.name.equals(s.getName()) && this.age == s.getAge()){
         return true;
       }
     }
     //5 不满足条件返回false
     return false;
   }
   ```

3. 遍历元素【重点】

   1. 使用迭代器

      ```java
      Iterator it = arrayList.iterator();
      while(it.hasNext()){
        Student s = (Student)it.next(); //强转
      }
      ```

   2. 列表迭代器

      ```java
      ListIterator li = arrayList.listIterator();
      while(li.hasNext()){
        Student s = (Student)li.next(); //从前往后遍历
      }
      
      while(li.hasPrevious()){
        Student s = (Student)li.previous();//从后往前遍历
      }
      ```

4. 判断

   `arrayList.contains();` 和 `arrayList.isEmpty();`

5. 查找

   `arrayList.indexof();`

**原码分析**

```java
DEFAULT_CAPACITY = 10; //默认容量
//注意：如果没有向集合中添加任何元素时，容量0，添加一个后，容量为10
//每次扩容是原来的1.5倍
elementData存放元素的数组
size 实际元素个数
```

### 5、Vector

创建集合 `Vector vector = new Vector<>();`

增加、删除、判断同上

遍历中枚举器遍历

```java
Enumeration en = vector.elements();
while(en.hasMoreElements()){
  String o = (String)en.nextElement();
  System.out.println(o);
}
```

### 6、LinkedList

创建链表集合`LinkedList li = new LinkedList<>();`

常用方法与List一致

### 7、泛型

- 本质是参数化类型，把类型作为参数传递
- 常见形式有泛型类、泛型接口、泛型方法
- 语法 T成为类型占位符，表示一种引用类型，可以写多个逗号隔开
- 好处 1. 提高代码重用性 2. 防止类型转换异常，提高代码安全性

**泛型类**

```java
// 写一个泛型类
public class MyGeneric<T>{
  //使用泛型T
  //1 创建变量
  T t;
  //2 泛型作为方法的参数
  public void show(T t){
    System.out.println(t);
  }
  //3 泛型作为方法的返回值
  public T getT(){
    return t;
  }
}
```

```java
// 使用泛型类
public class TestGeneric{
  public static void main(String[] args){
    //使用泛型类创建对象
    // 注意： 1. 泛型只能使用引用类型
    //			 2. 不用泛型类型对象之间不能相互赋值
    MyGeneric<String> myGeneric = new MyGeneric<String>();
    myGeneric.t = "hello";
    myGeneric.show("hello world!");
    String string = myGeneric.getT();
    
    MyGeneric<Integer> myGeneric2 = new MyGeneric<Integer>();
    myGeneric2.t = 100;
    myGeneric2.show(200);
    Integer integer = myGeneric2.getT();
  }
}
```

**泛型接口**

语法：接口名

注意：不能泛型静态常量

**泛型方法**

语法： 返回值类型

```java
public class MyGenericMethod{
  //泛型方法
  public <T> T show(T t){
    System.out.println("泛型方法" + t);
    return t;
  }
}

//调用
MyGenericMethod myGenericMethod = new MyGenericMethod();
myGenericMethod.show("字符串");// 自动类型为字符串
myGenericMethod.show(200);// integer类型
myGenericMethod.show(3.14);// double类型
```

**泛型集合**

概念：参数化类型、类型安全的集合，强制集合元素的类型必须一致

特点：

- 编译时即可检查，而非运行时抛出异常
- 访问时，不必类型转换（拆箱）
- 不同泛型之间应用不能相互赋值，泛型不存在多态

### 8、Set集合

特点：无序、无下标、元素不可重复

方法：全部继承自Collection中的方法

增、删、遍历、判断与collection一致

### 9、HashSet

存储结构：哈希表（数组+链表+红黑树）

存储过程（重复依据）

1. 根据hashCode计算保存的位置，如果位置为空，直接保存，若不为空，进行第二步
2. 再执行equals方法，如果equals为true，则认为是重复，否则形成链表

特点

- 基于HashCode计算元素存放位置
  - 利用31这个质数，减少散列冲突
    - 31提高执行效率 `31 * i = (i << 5) - i` 转为移位操作
  - 当存入元素的哈希码相同时，会调用equals进行确认，如果结果为true，则拒绝后者存入

新建集合 `HashSet<String> hashSet = new HashSet<String>();`

添加元素 `hashSet.add( );`

删除元素 `hashSet.remove( );`

遍历操作

  1. 增强for `for( type type : hashSet)`

  2. 迭代器 `Iterator<String> it = hashSet.iterator( );`

判断 `hashSet.contains( );` `hashSet.isEmpty();`

### 10、TreeSet

特点

- 基于排列顺序实现元素不重复
- 实现SortedSet接口，对集合元素自动排序
- 元素对象的类型必须实现Comparable接口，指定排序规则
- 通过CompareTo方法确定是否为重复元素

存储结构：红黑树

创建集合 `TreeSet<String> treeSet = new TreeSet<>()`

添加元素 `treeSet.add();`

删除元素 `treeSet.remove();`

遍历 1. 增强for 2. 迭代器

判断 `treeSet.contains();`

补充：TreeSet集合的使用

Comparator 实现定制比较（比较器）

Comparable 可比较的 

`使用TreeSet保存数据，元素必须要实现Comparable接口，compareTo()方法返回值为0，认为是重复元素`

```java
package com.chang.Collections;

import java.util.*;

public class Demo2 {
    public static void main(String[] args) {
        Student s1 = new Student("xyz",20);
        Student s2 = new Student("hello",22);
        Student s3 = new Student("zhangSan", 25);
       
        TreeSet<Student> treeSet = new TreeSet<>();
        treeSet.add(s1);
        treeSet.add(s2);
        treeSet.add(s3);
        System.out.println(treeSet);	//[Student{name='hello', age=22}, Student{name='xyz', age=20}, Student{name='zhangSan', age=25}]
    }
}

class Student implements Comparable<Student> {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    //先按姓名比，再按年龄比
    @Override
    public int compareTo(Student o) {
        int n1=this.getName().compareTo(o.getName());
        int n2=this.age-o.getAge();
        return n1==0?n2:n1;
    }
}
```

```java
package com.chang.Collections;

import java.util.Comparator;
import java.util.TreeSet;

public class Demo3 {
    public static void main(String[] args) {
        //创建集合
        TreeSet<Student> persons = new TreeSet<>(new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                int n1=o1.getAge()-o2.getAge();
                int n2=o1.getName().compareTo(o2.getName());
                return n1==0?n1:n2;
            }
        });

        Student s1 = new Student("xyz",22);
        Student s2 = new Student("hello",20);
        Student s3 = new Student("zhangSan", 25);

        persons.add(s1);
        persons.add(s2);
        persons.add(s3);

        System.out.println(persons);
    }
}

class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

#### 使用TreeSet实现按字符串长度排序

```java
package com.chang.Collections;

import java.util.Comparator;
import java.util.TreeSet;

//使用TreeSet实现按字符串长度排序
//helloWorld zhong li beijing xian zhang
public class Demo4 {
    public static void main(String[] args) {
        TreeSet<String> treeSet = new TreeSet<>(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                int n1=o1.length()-o2.length();
                int n2=o1.compareTo(o2);
                return n1==0?n2:n1;
            }
        });

        treeSet.add("helloWorld");
        treeSet.add("zhong");
        treeSet.add("li");
        treeSet.add("beijing");
        treeSet.add("xian");
        treeSet.add("zhang");

        System.out.println(treeSet);
    }
}
```

### 11、Map体系

Map接口的特点

```java
1. 用于存储任意键值对（key - value）
2. 键：无序、无下标、不允许重复（唯一）
3. 值：无序、无下标、允许重复
```

方法：

```java
1. V put(K key, V value) 将对象存到集合中，关联键值
2. Object get(Object key) 根据键获得对应的值
3. Set<K> 返回所有的Key
4. Collection<V> values() 返回包含所有值的Collection集合
5. Set<Map.Entry<K, V>> 键值匹配的Set集合
```

**Map接口的使用**

```java
//创建Map集合
Map<String, String> map = new HashMap<>();
// 1. 添加元素
map.put("cn", "中国");
map.put("uk", "英国");
map.put("cn", "zhongguo"); // 会替换第一个 
// 2. 删除
map.remove("uk");
// 3. 遍历
// 3.1 使用KeySet()
//Set<String> keyset = map.keySet(); // 所有Key的set集合
for(String key : map.keyset){
  System.out.println(key + "---" + map.get(key));
}
// 3.2 使用entrySet()
//Set<Map.Entry<String, String>> entries = map.entrySet();
for(Map.Entry<String, String> entry : map.entries){
  System.out.println(entry.getKey() + "---" + entry.getValue();
}
```

### 12、HashMap

存储结构：哈希表（数组+链表+红黑树）

使用key可使hashcode和equals作为重复

增、删、遍历、判断与上述一致

原码分析总结：

1. HashMap刚创建时，table是null，节省空间，当添加第一个元素时，table容量调整为16
2. 当元素个数大于阈值（16*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数
3. jdk1.8 当每个链表长度 >8 ，并且数组元素个数 ≥64时，会调整成红黑树，目的是提高效率
4. jdk1.8 当链表长度 <6 时 调整成链表
5. jdk1.8 以前，链表时头插入，之后为尾插入

### 13、Hashtable

线程安全，运行效率慢；不允许null作为key或是value

### 14、Properties

hashtable的子类，要求key和value都是string，通常用于配置文件的读取

### 15、TreeMap

实现了SortedMap接口（是map的子接口），可以对key自动排序

```java
package com.chang.Collections;

import java.util.Comparator;
import java.util.TreeMap;

public class Demo5 {
    public static void main(String[] args) {
        TreeMap<String,String> treeMap=new TreeMap<>(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                int n1=o1.compareTo(o2);
                return n1;
            }
        });
        treeMap.put("us","MeiGuo");
        treeMap.put("cn","ZhongGuo");
        treeMap.put("un","YingGuo");
        System.out.println(treeMap);
    }
}
```

### 16、Collections工具类

概念：集合工具类，定义了除了存取以外的集合常用方法

直接二分查找`int i = Collections.binarySearch(list, x);` 成功返回索引

其他方法 ： **copy复制、reverse反转、shuffle打乱、sort排序**

补充：

```java
package com.chang.Collections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class Demo6 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(20);
        list.add(5);
        list.add(12);
        list.add(30);
        list.add(6);
        //sort排序
        Collections.sort(list);
        System.out.println(list);
        //shuffle打乱顺序
        Collections.shuffle(list);
        System.out.println(list);
        //binarySearch二分查找
        int index = Collections.binarySearch(list, 12);
        System.out.println(index);
        //copy复制
        List<Integer> newList = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            newList.add(0);
        }
        Collections.copy(newList,list);
        newList.add(40);
        System.out.println(newList);
        System.out.println(list);
        //reverse反转
        Collections.reverse(list);
        System.out.println(list);

        //list转成数组
        Integer[] objects = list.toArray(new Integer[0]);
        System.out.println(Arrays.toString(objects));

        //数组转成集合
        String[] name = {"张三","李四","王五"};
        List<String> list2 = new ArrayList<>(Arrays.asList(name));
        System.out.println(list2);
        list2.add("刘六");
        System.out.println(list2);
    }
}
```

### 17、stream与Lambda表达式

1. `list转map`：Collectors.toMap就可以把一个list数组转成一个Map，类似的，还有Collectors.toList()、Collectors.toSet()，表示把对应的流转化为list或者Set

2. `filter() 过滤`：从数组集合中，过滤掉不符合条件的元素，留下符合条件的元素

3. `foreach 遍历`：foreach 遍历list，遍历map，真的很丝滑

4. `groupingBy 分组`：按某个属性对list进行分组操作

5. `sorted+Comparator 排序`：Comparator.comparing(UserInfo::getAge) 或者Integer::compareTo

6. `distinct 去重`：可以去除重复的元素

7. `findFirst 返回第一个元素`

8. `anyMatch 是否至少匹配一个元素`：检查流是否包含至少一个满足给定谓词的元素

9. `allMatch 匹配所有元素`：检查流是否所有都满足给定谓词的元素

10. `map 转换`：map方法可以帮我们做元素转换，比如一个元素所有字母转化为大写，又或者把获取一个元素对象的某个属性

11. `reduce 合并`：可以合并流的元素，并生成一个值

12. `peek 打印日志`：peek()方法是一个中间Stream操作，有时候我们可以使用peek来打印日志

13. `max、min最大最小`

14. `count统计`：一般count()表示获取流数据元素总数

15. `常用函数式接口`

    其实lambda离不开函数式接口，我们来看下JDK8常用的几个函数式接口：

    - `Function<T, R>`（转换型）: 接受一个输入参数，返回一个结果
    - `Consumer<T>` （消费型）: 接收一个输入参数，并且无返回操作
    - `Predicate<T>` （判断型）: 接收一个输入参数，并且返回布尔值结果
    - `Supplier<T>` （供给型）: 无参数，返回结果

    `Function<T, R>` 是一个功能转换型的接口，可以把将一种类型的数据转化为另外一种类型的数据

    `Consumer<T>`是一个消费性接口，通过传入参数，并且无返回的操作

    `Predicate<T>`是一个判断型接口,并且返回布尔值结果

    `Supplier<T>`是一个供给型接口,无参数，有返回结果

```java
package com.chang.Collections;

import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Demo7 {
    public static void main(String[] args) {
        ArrayList<UserInfo> userInfoList = new ArrayList<>();
        userInfoList.add(new UserInfo(1L, "捡田螺的小男孩", 18));
        userInfoList.add(new UserInfo(2L, "程序员田螺", 27));
        userInfoList.add(new UserInfo(2L, "捡瓶子的小男孩", 26));

        /**
         *  (1)
         *  list 转 map
         *  使用Collectors.toMap的时候，如果有可以重复会报错，所以需要加(k1, k2) -> k1
         *  (k1, k2) -> k1 表示，如果有重复的key,则保留第一个，舍弃第二个
         */
        Map<Long, UserInfo> userInfoMap = userInfoList.stream().collect(Collectors.toMap(UserInfo::getId, userInfo -> userInfo, (k1, k2) -> k1));
        userInfoMap.values().forEach(a->System.out.println(a.getName()));
        //运行结果
        //捡田螺的小男孩
        //程序员田螺

        /**
         *  (2)
         * filter 过滤，留下超过20岁的用户
         */
        List<UserInfo> userInfoResultList = userInfoList.stream().filter(user -> user.getAge() > 20).collect(Collectors.toList());
        userInfoResultList.add(new UserInfo(3L,"吃饺子的小男孩",16));
        System.out.println(userInfoResultList);
        //[UserInfo{id=2, name='程序员田螺', age=27}, UserInfo{id=2, name='捡瓶子的小男孩', age=26}, UserInfo{id=3, name='吃饺子的小男孩', age=16}]

        /**
         *  (4)
         * groupingBy分组
         */
        Map<Long, List<UserInfo>> result = userInfoList.stream().collect(Collectors.groupingBy(UserInfo::getId));
        System.out.println(result);
        //{1=[UserInfo{id=1, name='捡田螺的小男孩', age=18}], 2=[UserInfo{id=2, name='程序员田螺', age=27}, UserInfo{id=2, name='捡瓶子的小男孩', age=26}]}

        /**
         *  (5)
         *  sorted + Comparator.comparing 排序列表，
         */
        List<UserInfo>newUserInfoList = userInfoList.stream().sorted(Comparator.comparing(UserInfo::getAge)).collect(Collectors.toList());
        newUserInfoList.forEach(a -> System.out.println(a.toString()));
        //UserInfo{id=1, name='捡田螺的小男孩', age=18}
        //UserInfo{id=2, name='捡瓶子的小男孩', age=26}
        //UserInfo{id=2, name='程序员田螺', age=27}

        System.out.println("开始降序排序");

        /**
         * 如果想降序排序，则可以使用加reversed()
         */
        List<UserInfo>newUserInfoList2 = userInfoList.stream().sorted(Comparator.comparing(UserInfo::getAge).reversed()).collect(Collectors.toList());
        newUserInfoList2.forEach(a -> System.out.println(a.toString()));
        //UserInfo{id=2, name='程序员田螺', age=27}
        //UserInfo{id=2, name='捡瓶子的小男孩', age=26}
        //UserInfo{id=1, name='捡田螺的小男孩', age=18}

        /*
        *  (6)
        *distinct去重
         */
        List<String> list = Arrays.asList("A", "B", "F", "A", "C");
        List<String> temp = list.stream().distinct().collect(Collectors.toList());
        temp.forEach(System.out::println);
        //A
        //B
        //F
        //C

        /*
        *  (7)
        *findFirst 返回第一个元素
         */
        List<String> list2 = Arrays.asList("A", "B", "F", "A", "C");
        list2.stream().findFirst().ifPresent(System.out::println);
        //A

        /*
        *  (8)
        *anyMatch 检查流是否包含至少一个满足给定谓词的元素
         */
        Stream<String> stream = Stream.of("A", "B", "C", "D");
        boolean match = stream.anyMatch(s -> s.contains("C"));
        System.out.println(match);
        //true
        List<String> list3 = Arrays.asList("A", "B", "F", "A", "C");
        boolean matchResult = list3.stream().anyMatch(s -> s.contains("A"));
        System.out.println(matchResult);
        //true

        /*
        *  (9)
        *allMatch 检查流是否所有都满足给定谓词的元素。
         */
        Stream<String> stream2 = Stream.of("A", "B", "C", "D");
        boolean match2 = stream2.allMatch(s -> s.contains("C"));
        System.out.println(match2);
        //false

        /*
        *  (10)
        *map转换
         */
        List<String> list4 = Arrays.asList("jay", "tianluo");
        List<String> upperCaselist = list4.stream().map(String::toUpperCase).collect(Collectors.toList());
        System.out.println(upperCaselist);
        List<String> collect = list4.stream().map(s -> s.toUpperCase()).collect(Collectors.toList());
        System.out.println(collect);
        List<String> collect2 = list4.stream().map(s -> s.toUpperCase()+"a").collect(Collectors.toList());
        System.out.println(collect2);
        //[JAY, TIANLUO]
        //[JAY, TIANLUO]
        //[JAYa, TIANLUOa]

        /*
        *  (11)
        *reduce可以合并流的元素，并生成一个值
         */
        List<Integer> list5 = Arrays.asList(1,2,3,4);
        Integer sum = list5.stream().reduce(0, (a, b) -> a + b);
        System.out.println(sum);
        //10

        /*
        *  (12)
        *peek()方法是一个中间Stream操作，有时候我们可以使用peek来打印日志。
         */
        List<String> list6 = Stream.of("程序员田螺", "捡田螺的小男孩", "捡瓶子的小男孩")
                .filter(a -> a.contains("田螺"))
                .peek(a -> System.out.println("公众号:" + a)).collect(Collectors.toList());
        System.out.println(list6);
        //公众号:程序员田螺
        //公众号:捡田螺的小男孩
        //[程序员田螺, 捡田螺的小男孩]

        /*
        *  (13)
        *max，min最大最小
         */
        List<Integer> list7 = Arrays.asList(1,2,3,4);
        Optional<Integer> max1 = list7.stream().max(Integer::compareTo);
        Integer integer1 = max1.get();
        System.out.println(integer1);
        //4
        int[] arr={1,2,3,4};
        int maxArr = Arrays.stream(arr).max().getAsInt();
        System.out.println(maxArr);
        //4
        List<UserInfo> userInfoList2 = new ArrayList<>();
        userInfoList2.add(new UserInfo(1L, "捡田螺的小男孩", 18));
        userInfoList2.add(new UserInfo(3L, "捡瓶子的小男孩", 26));
        userInfoList2.add(new UserInfo(2L, "程序员田螺", 27));

        Optional<UserInfo> maxAgeUserInfoOpt = userInfoList2.stream().max(Comparator.comparing(UserInfo::getAge));
        maxAgeUserInfoOpt.ifPresent(userInfo -> System.out.println("max age user:" + userInfo));
        //max age user:UserInfo{id=2, name='程序员田螺', age=27}
        Optional<UserInfo> minAgeUserInfoOpt = userInfoList2.stream().min(Comparator.comparing(UserInfo::getAge));
        minAgeUserInfoOpt.ifPresent(userInfo -> System.out.println("min age user:" + userInfo));
        //min age user:UserInfo{id=1, name='捡田螺的小男孩', age=18}

        /*
        *  (14)
        *count()表示获取流数据元素总数
         */
        long count = userInfoList2.stream().filter(user -> user.getAge() > 18).count();
        System.out.println("大于18岁的用户:" + count);
        //大于18岁的用户:2

        /*
        *  (15)
        Function<T, R> 是一个功能转换型的接口，可以把将一种类型的数据转化为另外一种类型的数据
         */
        //获取每个字符串的长度，并且返回
        Function<String, Integer> function = String::length;
        Stream<String> stream3 = Stream.of("程序员田螺", "捡田螺的小男孩", "捡瓶子的小男孩");
        Stream<Integer> resultStream = stream3.map(function);
        resultStream.forEach(System.out::println);
        //5
        //7
        //7

        /*
        Consumer<T>是一个消费性接口，通过传入参数，并且无返回的操作
         */
        //获取每个字符串的长度，并且返回
        Consumer<String> comsumer = System.out::println;
        Stream<String> stream4 = Stream.of("程序员田螺", "捡田螺的小男孩", "捡瓶子的小男孩");
        stream4.forEach(comsumer);
        //程序员田螺
        //捡田螺的小男孩
        //捡瓶子的小男孩

        /*
        Predicate<T>是一个判断型接口,并且返回布尔值结果.
         */
        //获取每个字符串的长度，并且返回
        Predicate<Integer> predicate = a -> a > 18;
        UserInfo userInfo = new UserInfo(2L, "程序员田螺", 27);
        System.out.println(predicate.test(userInfo.getAge()));
        //true

        /*
        Supplier<T>是一个供给型接口,无参数，有返回结果。
         */
        Supplier<Integer> supplier = () -> Integer.valueOf("666");
        System.out.println(supplier.get());
        //666
        //比如我们DAO操作完数据库，是会有个result的整型结果返回。我们就可以用Supplier<T>来统一判断是否操作成功。
//        private void saveDb(Supplier<Integer> supplier) {
//            if (supplier.get() > 0) {
//                System.out.println("插入数据库成功");
//            }else{
//                System.out.println("插入数据库失败");
//            }
//        }
//
//        @Test
//        public void add() throws Exception {
//            Course course=new Course();
//            course.setCname("java");
//            course.setUserId(100L);
//            course.setCstatus("Normal");
//            saveDb(() -> courseMapper.insert(course));
//        }
    }
}

class UserInfo{
    private Long id;
    private String name;
    private int age;

    public UserInfo() {
    }

    public UserInfo(Long id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "UserInfo{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

## 7、常用类

### 1、内部类

成员内部类、静态内部类、局部内部类、匿名内部类

概念：在一个类的内部再定义一个完整的类

特点：

- 编译之后可生成独立的字节码文件
- 内部类可直接访问外部类私有成员，而不破坏封装
- 可为外部类提供必要的内部功能组件

```java
Outer$Inner.class` `Outer.class
```

```java
// 身体
class Body{
  // 头部
  class Header{
    // 也会生成class文件
  }
}
```

**成员内部类**

- 在类的内部定义，与实例变量、实例方法同级别的类
- 外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象
- 当外部类、内部类存在重名属性时，会优先访问内部类属性
- 成员内部类里不能定义**静态成员**、可以包含**静态常量(final)**

```java
// 外部类
public class Outer{
  //实例变量
  private String name = "张三";
  private int age = 20;
  //内部类
  class Inner{
    private String address = "北京";
    private String phone = "110";
    private String name = "李四";
    
    //方法
    public void show(){
      //打印外部类属性 此时有重名属性name
      System.out.println(Outer.this.name); // 张三
      System.out.println(age);
      //打印内部类中的属性
      System.out.println(name); // 李四
      System.out.println(address);
      System.out.println(phone);
    }
  }
}

// 测试类
public class Test{
  public static void main(String[] args){
    // 创建外部类对象
    Outer outer = new Outer();
    // 创建内部类对象
    Inner inner = outer.new Inner();
    
    //一步到位
    Outer.Inner inner = new Outer().new Inner();
                            
    inner.show();
  }
}
```

**静态内部类**

- 不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员

```java
// 外部类
public class Outer{
  //实例变量
  private String name = "xxx";
  private int age = 20;
  
  // 静态内部类，和外部类相同
  static class Inner{
    private String address = "上海";
    private String phone = "111";
    // 静态成员
    private static int count = 1000;
    
    //方法
    public void show(){
      // 调用外部类的属性
      // 1. 先创建外部类对象
      Outer outer = new Outer();
      // 2. 调用外部类对象的属性
      System.out.println(outer.name);
      System.out.println(outer.age);
      // 调用静态内部类的属性和方法
      System.out.println(address);
      System.out.println(phone);
      // 调用静态内部类的静态属性
      System.out.println(Inner.count);
    }
  }
}

// 测试类
public class Test{
  public static void main(String[] args){
    // 直接创建静态内部类对象
    Outer.Inner inner = new Outer.Inner();
                     
    inner.show();
  }
}
```

**局部内部类**

- 定义在外部类**方法**中，作用范围和创建对象范围仅限于当前方法
- 局部内部类访问外部类当前方法中的局部变量时，因无法保障变量的生命周期与自身相同，变量必须修饰为final
- 限制类的使用范围

```java
// 外部类
public class Outer{
  //实例变量
  private String name = "刘德华";
  private int age = 35;
  
  //方法
  public void show(){
    // 定义局部变量
    String address = "sz";
    
    // 局部内部类：注意不能加任何访问修饰符
    class Inner{
      private String phone = "11234";
      private String email = "ldh@qq.com";
      
      public void show2(){
        // 访问外部类的属性
        System.out.println(name); // 相当于 Outer.this.name
        System.out.println(age);
        // 访问内部类的属性
        System.out.println(this.phone);
        System.out.println(this.email);
        
        // 访问局部变量 jdk1.7要求必须常量final、jdk1.8自动添加final
        
      }
    }
    // 创建局部内部类对象
    Inner inner = new Inner();
    inner.show2();
  }
}

// 测试类
public class Test{
  public static void main(String[] args){
    // 创建外部类对象
    Outer outer = new Outer();
                     
    outer.show();
  }
}
```

**匿名内部类**

- 没有类名的局部内部类（一切特征都与局部内部类相同）
- 必须继承一个父类或者实现一个接口
- 定义类、实现类、创建对象的语法合并，只能创建一个该类的对象
- 优点：减少代码量
- 缺点可读性较差

```java
// 使用匿名内部类优化（相当于创建了一个局部内部类）
Usb usb = new Usb(){ // Usb为一个接口
  @Override
  public void service(){
    sout("连接电脑成功，fan开始工作")
  }
};
usb.service();
```

### 2、Object类

- 超类、基类，所有类的直接或间接父类，位于继承树的最顶层
- 任何类，如没有书写extends显示继承某个类，都默认直接继承Object类，否则为间接继承
- Object类中所定义的方法，是所有对象都具备的方法
- Object类型可以存储任何对象
  - 作为参数，可接受任何对象
  - 作为返回值，可返回任何对象

#### 1、getClass方法

- `public final Class<?> getClass(){}`
- 返回引用中存储的实际对象类型
- 应用：通常用于判断两个引用中实际存储对象类型是否一致

```java
// 判断s1 和 s2是不是同一个类型
Class class1 = s1.getClass();
Class class2 = s2.getClass();
// getClass返回 class类型
```

#### 2、hashCode()方法

- `public int hashCode(){}`
- 返回该对象的哈希码值
- 哈希值根据对象的地址或字符串或数字使用hash算法计算出来的int类型的值
- 一般情况下相同对象返回相同哈希码

```java
s1.hashCode();
s2.hashCode();
// 自然不同
Student s3 = s1; // 此时s3的hashCode与s1相同
```

#### 3、toString()方法

- `public String toSring(){}`
- 返回该对象的字符串表示（表现形式）
- 可以根据程序需求覆盖该方法，如：展示对象各个属性值

```java
System.out.println(s1.toString()); // 直接打印包+类名+哈希值
// 重写 alt + enter + s
@override
public String toString(){
  return "Student [name = " + name + ", age = " + age + "]";
}
```

#### 4、equals()方法

- `public boolean equals(Object obj){}`
- 默认实现为(this == obj), 比较两个对象地址是否相同
- 可进行覆盖，比较两个对象的内容是否相同

```java
// 判断两个对象是否相等
System.out.println(s1.equals(s2)); // false

Student s4 = new Strudent("小明", 17);
Student s5 = new Strudent("小明", 17);
sout(s4.equals(s5)); // false 堆中地址不同

// 重写 改变其比较内容
/*
步骤  1. 比较两个应用是否指向同一个对象
     2. 判断obj是否为null
     3. 判断两个引用只想的实际对象类型是否一致
     4. 强制类型转换
     5. 依次比较各个属性值是否相同
*/
@override
public boolean equals(Object obj){
  // 1.
  if(this == obj){
    return true;
  }
  // 2.
  if(obj == null){
    return false;
  }
  // 3.
  // if(this.getClass() == obj.getClass()){
  //
  // }
  // instanceof 判断对象是否是某种类型
  if(obj instanceof Student){
    // 4.强制类型转换
    Student s = (Student)obj;
    // 5. 比较属性
    if(this.name.equals(s.getName()) && this.age == s.getAge()){
      return true;
    }
  }
  return false;
}
```

#### 5、finalize() 方法

- 当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列
- 垃圾对象：没有有效引用指向此对象时，为垃圾对象
- 垃圾回收：由gc销毁垃圾对象，释放数据存储空间
- 自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象
- 手动回收机制：使用`System.gc();`通知JVM执行垃圾回收

```java
@Override
protected void finalize() throws Throwable{
  sout(this.name + "对象被回收了");
}

public static void main(String[] args){
  Student s1 = new Student("aaa", 29); // 不是垃圾
  new Student("bbb", 30); // 是辣鸡 会被回收
  //回收垃圾
  System.gc();
  System.out.println("回收垃圾"); 
  // 打印出 “回收垃圾 
  //         aaa对象被回收了”
}
```

### 3、包装类

- **基本数据类型**所对应的**引用数据类型**
- Object 可统一所有数据，包装类的默认值是null

| 基本数据类型 | 包装类型  |
| :----------: | :-------: |
|     byte     |   Byte    |
|    short     |   Short   |
|     int      |  Integer  |
|     long     |   Long    |
|    float     |   Float   |
|    double    |  Double   |
|   boolean    |  Boolean  |
|     char     | Character |

**类型转换与装箱、拆箱**

- 8种包装类提供不用类型间的转换方式
  1. Number父类中提供的6个共性方法
  2. `parseXXX( )`静态方法
  3. `valueOf( )`静态方法
- 注意：需保证类型兼容，否则抛出NumberFormatException异常

```java
public static void main(String[] args){
  // 装箱， 基本类型 → 引用类型
  // 基本类型
  int num1 = 18;
  // 使用Integer类创建对象
  Integer integer1 = new Integer(num1);
  Integer integer2 = Integer.valueOf(num1);
  
  // 拆箱， 引用类型 → 基本类型
  Integer integer3 = new Integer(100);
  int num2 = integer3.intValue();
  
  // 上述为jdk1.5之前方法，之后提供了自动装箱拆箱
  int age = 30;
  // 自动装箱
  Integer integer4 = age;
  // 自动拆箱
  int age2 = integer4;
  
  // 基本类型和字符串之间转换
  // 1. 基本类型转成字符串
  int n1 = 100;
  // 1.1 使用+号
  String s1 = n1 + "";
  // 1.2 使用Integer中的toString()方法
  String s2 = Integer.toString(n1);
  String s2 = Integer.toString(n1, x); // x为进制要求
  
  // 2. 字符串转成基本类型
  String str = "150";
  // 使用Integer.parseXXX();
  int n2 = Integer.parseInt(str);
  
  // boolean 字符串形式转成基本类型，"true" ---> true 非“true ———> false
  String str2 = "true";
  boolean b1 = Boolean.parseBoolean(str2);
}
```

**整数缓冲区**

- Java预先创建了256个常用的证书包装类型对象
- 在实际应用当中，对已创建的对象进行复用

```java
public static void main(String[] args){
  // 面试题
  Integer integer1 = new Integer(100);
  Integer integer2 = new Integer(100);
  System.out.println(integer1 == integer2); // false
  
  Integer integer3 = 100;// 自动装箱
  // 相当于调用 Integer.valueOf(100);
  Integer integer4 = 100;
  System.out.println(integer3 == integer4); // true
  
  Integer integer5 = 200;// 自动装箱
  Integer integer6 = 200;
  System.out.println(integer5 == integer6); // false
  
  // 因为缓存区数组 [-128, 127] 在这之内地址一样
}
```

### 4、String类

- 字符串是常量，创建之后不可改变
- 字符串字面值存储在字符串池中，可以共享
- `String s = "Hello";`产生一个对象，字符串池中存储
- `String s = new String("Hello");` 产生两个对象，**堆、池**各一个

**常用方法**

```java
// 1. length(); 返回字符串长度
// 2. charAt(int index); 返回某个位置的字符
// 3. contains(String str); 判断是否包含某个字符串

String content = "java是最好的语言";
sout(content.length()); // 10
sout(content.charAt(content.length() - 1)); // 言
sout(content.contains("java")); // true

// 4. toCharArray(); 返回字符串对应数组 
// 5. indexOf(); 返回子字符串首次出现的位置
// 6. lastIndexOf(); 返回字符串最后一次出现的位置

sout(content.toCharArray());
sout(content.indexOf("java")); // 0
sout(content.indexOf("java", 4)); // 从索引4开始找 返回12
sout(content.lastIndexOf("java")); // 12

// 7. trim(); //去掉字符串前后空格
// 8. toUpperCase(); toLowerCase(); 转换大小写
// 9. endWith(str); startWith(str);  判断是否以str 结尾、开头

String ct = " hello world ";
sout(ct.trim()); // "hello world"
sout(ct.toUpperCase()); // HELLO WORLD
sout(ct.toLowerCase()); // hello world
sout(ct.endWith("world")); // true
sout(ct.startWith("hello")) // true
  
// 10. replace(char old, char new); 用心的字符或字符串替换旧的字符或字符串
// 11. split(); 对字符串拆分

sout(content.replace("java", "php")); // php是最好的语言, php no1

String say = "java is the best language";
String[] arr = arr.say.split(" "); // "[ ,]+" 表示空格 逗号切分 +号表示切分可以多个 比如多个空格
sout(arr.length); // 5
for(String string : arr){
  sout(string);
}
// 打印出 
//java
//is
//the 
//best
//language

// 补充两个equals/compareTo();比较大小
String s1 = "hello";
String s2 = "HELLO";
sout(s1.equalsIgnoreCase(s2));// 忽略大小写比较true

// compareTo(); 两字符不同时比较字符字典序的ascii码
// 字符相同时比较长度 返回差值
```

**案例演示**

需求：

1. 已知String str = "this is a text";
2. 将str中的单词单独获取
3. 将str中的text替换成practice
4. 在text前面插入一个easy
5. 将每个单词的首字母改为大写

```java
psvm(String[] args){
  String str = "this is a text";
  // 2. 
  String[] arr = str.split(" ");
  for(String s : arr){
    sout(s);
  }
  // 3.
 String str2 = str.replace("text", "practice");
  // 4. 
 String str3 = str.replace("text", "easy text");
  // 5. 
 String[] s = str.split(" ");
 StringBuilder sb = new StringBuilder();
        for (String s1 : s) {
            char c = s1.charAt(0);
            char c1 = Character.toUpperCase(c);
            String strNew=c1+s1.substring(1);
            sb.append(strNew);
            sb.append(" ");
        }
        String res = sb.toString();
        System.out.println(res);
        System.out.println(res.length());
        String val = res.substring(0,res.length()-1);
        System.out.println(val);
        System.out.println(val.length());
}
```

**可变字符串**

- StringBuffer : 可变长字符串，运行效率慢、线程安全
- StringBuilder : 可边长字符串、运行快、线程不安全

效率都比String高且节省内存

```java
psvm(String[] args){
  // StringBuffer 和 StringBuilder 用法一致
  StringBuffer sb = new StringBuffer();
  // 1. append(); 追加
  sb.append("java no1");
  // 2. insert(); 添加、插入
  sb.insert(0, "在第一个位置插入");
  // 3.replace(); 替换
  sb.replace(0, 9, str); // 左闭右开
  // 4. delete(); 删除
  sb.delete(0, 5); // 左闭右开
  // 5. 清空
  sb.delete(0, sb.length());
}
```

### 5、BigDecimal类

- 位置 `java.math` 包中
- 作用 精确计算浮点数
- 创建方式 `BigDecimal bd = new BigDecimal("1.0");`

```java
BigDecimal bd1 = new BigDecimal("1.0"); // 需用字符串
BigDecimal bd2 = new BigDecimal("0.9");
// 减法
BigDecimal r1 = bd1.subtract(bd2);
System.out.println(r1); // 0.1

// 加法
BigDecimal r2 = bd1.add(bd2);	//1.9

//乘法
BigDecimal r3 = bd1.multiply(bd2);	//0.90

// 除法
BigDecimal r4 = bd1.divide(bd2,2,BigDecimal.ROUND_HALF_UP);	//1.11

BigDecimal r5 = new BigDecimal("1.4").subtract(new BigDecimal("0.5")).divide(new BigDecimal("0.9"), x, BigDecimal.ROUND_HALF_UP); 	//1.11
//除不尽时 x填保留位数 后面为四舍五入之意
```

###  6、Date类

#### Date

Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代

时间单位：1s = 1,000ms = 1,000,000 μs = 1,000,000,000 = ns

```java
public static void main(String[] args){
  // 1 创建Date对象
  Date date1 = new Date();
  System.out.println(date1.toString()); //WED Sept 02 22:25:23 CST 2020
  System.out.println(date1.toLocaleString()); // 已过时 但也能用 2020-9-2
  
  // 创建昨天的
  Date date2 = new Date(date1.getTime() - (60*60*24*1000));
  System.out.println(date2.toLocaleString());
  
  // 2 方法after before
  boolean b1 = date1.after(date2);
  System.out.println(b1); //true
  boolean b2 = date1.before(date2);
  System.out.println(b2); //false
  
  // 比较compareTo();
  int d = date1.compareTo(date2);
  System.out.println(d); //1 多的为1 少的为 -1 
  
  // 比较是否相等 equals()
  boolean b3 = date1.equals(date2);
  System.out.println(b3); // false
}
```

#### Calendar

- Calendar提供了获取或设置各种日历字段的方法
- 构造方法 `protected Calendar();` 由于是protected 所以无法直接创建
- 其他方法

| 方法名                                                       | 说明                                       |
| :----------------------------------------------------------- | :----------------------------------------- |
| static Calendar getInstance()                                | 使用默认时区和区域获取日历                 |
| void set(int year, int month, int date, int hourofday, int minute, int second) | 设置日历的年、月、日、时、分、秒           |
| int get(int field)                                           | 返回给定日历字段的值。字段比如年、月、日   |
| void setTime(Date date)                                      | 用给定的date设置此日历时间                 |
| Date getTime()                                               | 返回一个date表示此日历的时间               |
| void add(int field, int amount)                              | 按照日历的规则，给指定字段添加或减少时间量 |
| long getTimeInMilles()                                       | 毫秒为单位返回该日历的时间值               |

```java
public static void main(String[] args){
    	// 0.处理Date对象
   		Calendar calendar_0 = Calendar.getInstance();
        calendar_0.setTime(date);
        System.out.println(calendar_0.get(Calendar.YEAR));
		// 1. 创建 Calendar 对象
        Calendar calendar = Calendar.getInstance();
        System.out.println(calendar);
        System.out.println(calendar.getTime().toString());
        // 2. 获取时间信息
        // 获取年
        int year = calendar.get(Calendar.YEAR);
        System.out.println(year);
        // 获取月 从 0 - 11
        int month = calendar.get(Calendar.MONTH);
        System.out.println(month);
        // 日
        int day = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(day);
        // 小时
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        System.out.println(hour);
        // 分钟
        int minute = calendar.get(Calendar.MINUTE);
        System.out.println(minute);
        // 秒
        int second = calendar.get(Calendar.SECOND);
        System.out.println(second);
        // 3. 修改时间
        Calendar calendar2 = Calendar.getInstance();
        calendar2.set(Calendar.DAY_OF_MONTH, 1);
        System.out.println(calendar2);
        // 4. add修改时间
        calendar2.add(Calendar.HOUR, 1); // x为正就加 负就减
        System.out.println(calendar2);
        // 5. 补充方法
        int max = calendar2.getActualMaximum(Calendar.DAY_OF_MONTH);// 月数最大天数
        int min = calendar2.getActualMinimum(Calendar.DAY_OF_MONTH);
        System.out.println(max);
        System.out.println(min);
}
```

#### SimpleDateFormat

- SimpleDateFormat是一个以与语言环境有关的方式来格式化和解析日期的具体类
- 进行格式化（日期→文本）、解析（文本→日期）
- 常用的时间模式字母

| 字母 | 日期或时间         | 示例 |
| :--- | :----------------- | :--- |
| y    | 年                 | 2019 |
| 08   | 年中月份           | 08   |
| d    | 月中天数           | 10   |
| H    | 一天中小时（0-23） | 22   |
| m    | 分钟               | 16   |
| s    | 秒                 | 59   |
| S    | 毫秒               | 356  |

```java
package com.chang.CommonClass;

import java.math.BigDecimal;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class Test {
    public static void main(String[] args) throws ParseException {
        // 1. 创建对象
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH-mm-ss");
        System.out.println(sdf);    //java.text.SimpleDateFormat@fc61e000
        // 2. 创建Date
        Date date = new Date();
        System.out.println(date);   //Mon Nov 28 12:24:55 CST 2022
        // 格式化date（日期→字符串）
        String str = sdf.format(date);
        System.out.println(str);    //2022/11/28 12-24-55
        // 解析（字符串→时间）
        Date date2 = sdf.parse("1948/03/12 12-24-03");  //Fri Mar 12 12:24:03 CST 1948
        System.out.println(date2);
    }
}

```

### 7、System类

主要用于获取系统的属性数据和其他操作，构造方法私有的

| 方法名                           | 说明                                               |
| :------------------------------- | :------------------------------------------------- |
| static void arraycopy(...)       | 复制数组                                           |
| static long currentTimeMillis(); | 获取当前系统时间，返回毫秒值                       |
| static void gc();                | 建议jvm赶快启动垃圾回收期器回收垃圾                |
| static void exit(int status);    | 退出jvm 如果参数是0表示正常退出jvm 非0表示异常退出 |

```java
package com.chang.CommonClass;

import java.text.ParseException;
import java.util.Arrays;

//arraycopy 复制
//src-原数组 srcPos-从哪个位置开始复制0 dest-目标数组 destPos-目标数组的位置 length-复制的长度
public class Test {
    public static void main(String[] args) throws ParseException {
        int[] arr = {20, 18, 39, 3};
        int[] dest = new int [4];
        //System.arraycopy(src, srcPos, dest, destPos, length);
        System.arraycopy(arr, 1, dest, 0, 3);
        System.out.println(Arrays.toString(dest));  //[18, 39, 3, 0]
    }
}

```