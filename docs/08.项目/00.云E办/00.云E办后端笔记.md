---
title: 云E办后端笔记
date: 2023-02-03 23:00:00
permalink: /pages/c2b2ed/
categories:
  - 项目
  - 云E办
tags:
  - 
---
# 云E办后端笔记

## 1、云E办后端项目介绍

本项目目的是实现中小型企业的在线办公系统，云E办在线办公系统是一个用来管理日常的办公事务的一个系统，他能够管的内容有：日常的各种流程审批，新闻，通知，公告，文件信息，财务，人事，费用，资产，行政，项目，移动办公等等。它的作用就是通过软件的方式，方便管理，更加简单，更加扁平。更加高效，更加规范，能够提高整体的管理运营水平。

本项目在技术方面采用最主流的前后端分离开发模式，使用业界最流行、社区非常活跃的开源框架Spring Boot来构建后端，旨在实现云E办在线办公系统。包括职位管理、职称管理、部门管理、员工管理、工资管理、在线聊天等模块。项目中还会使用业界主流的第三方组件扩展大家的知识面和技能池。

本项目主要模块及技术点如图：

![image-20230118114205308](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118114205308.png)

## 2、yebBack项目搭建

### 2.1、创建yeb数据库

首先在MySQL数据库中使用yeb.sql生成对应的数据库`yeb`

![image-20230118114448305](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118114448305.png)

### 2.2、创建yebBack父项目

> **由于yebBack作为项目的父工程，可以不用选择依赖，而是交由子工程自行选择，并且除pom.xml之外的其他文件均可删掉，此外还需要在pom.xml文件中指定打包方式为pom，并且删除掉其中的<dependencies></dependencies>与<build></build>**

![image-20230118114740397](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118114740397.png)

![image-20230118130724730](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118130724730.png)

![image-20230118115138486](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118115138486.png)

**yebBack/pom.xml：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.7</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    
    <groupId>com.chang</groupId>
    <artifactId>yebBack</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>yebBack</name>
    <description>yebBack</description>
    
    <properties>
        <java.version>1.8</java.version>
    </properties>

</project>
```

### 2.3、创建yeb-server子项目

![image-20230118120020658](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118120020658.png)

![image-20230118131321303](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118131321303.png)

> 添加如下依赖

![image-20230118131355684](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118131355684.png)

> 修改yebBack/yeb-server/pom.xml中的parent标签

```xml
	<parent>
        <groupId>com.chang</groupId>
        <artifactId>yebBack</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
```

> 为yebBack/pom.xml添加modules标签

```xml
	<modules>
        <module>yeb-server</module>
    </modules>
```

> 除创建子工程时添加的Web、Lombock、MySQL依赖，继续在pom.xml中添加mybatis-plus、swagger2、swagger第三方UI依赖

```xml
		<!--mybatis-plus 依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.2</version>
        </dependency>

        <!-- swagger2 依赖 -->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>

        <!-- Swagger第三方ui依赖 -->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>swagger-bootstrap-ui</artifactId>
            <version>1.9.6</version>
        </dependency>
```

yebBack/yeb-server/pom.xml汇总如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.chang</groupId>
        <artifactId>yebBack</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>

    <groupId>com.chang</groupId>
    <artifactId>yeb-server</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>yeb-server</name>
    <description>yeb-server</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!--mybatis-plus 依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.2</version>
        </dependency>

        <!-- swagger2 依赖 -->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>

        <!-- Swagger第三方ui依赖 -->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>swagger-bootstrap-ui</artifactId>
            <version>1.9.6</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```

### 2.4、完善项目路径

在`com.chang.yebserver`中添加如下文件夹：

- config
- controller
- mapper
- pojo
- service

在resources中添加文件夹`mapper`

![image-20230118140646939](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118140646939.png)

### 2.5、修改配置文件

将`application.properties`重命名为`application.yml`，然后在其中填写如下内容，指定项目的端口号、连接的数据库、mybatis-plus扫描包、日志打印扫描包

```yml
server:
  # 端口
  port: 8081
spring:
  # 数据源配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/yeb?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: root
    password: mysql
    hikari:
      # 连接池名
      pool-name: DateHikariCP
      # 最小空闲连接数
      minimum-idle: 5
      # 空闲连接存活最大时间，默认600000（10分钟）
      idle-timeout: 180000
      # 最大连接数，默认10
      maximum-pool-size: 10
      # 从连接池返回的连接的自动提交
      auto-commit: true
      # 连接最大存活时间，0表示永久存活，默认1800000（30分钟）
      max-lifetime: 1800000
      # 连接超时时间，默认30000（30秒）
      connection-timeout: 30000
      # 测试连接是否可用的查询语句
      connection-test-query: SELECT 1

# Mybatis-plus配置
mybatis-plus:
  #配置Mapper映射文件
  mapper-locations: classpath*:/mapper/*Mapper.xml
  # 配置MyBatis数据返回类型别名（默认别名是类名）
  type-aliases-package: com.chang.yebserver.pojo
  configuration:
    # 自动驼峰命名
    map-underscore-to-camel-case: false

## Mybatis SQL 打印(方法接口所在的包，不是Mapper.xml所在的包)
logging:
  level:
    com.chang.yebserver.mapper: debug
```

### 2.6、在启动类上添加扫描

```java
@MapperScan("com.chang.yebserver.mapper")
```

```java
package com.chang.yebserver;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan("com.chang.yebserver.mapper")
public class YebServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(YebServerApplication.class, args);
    }

}
```

## 3、AutoGenerator逆向工程

### 3.1、AutoGenerator是什么

AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Pojo、Mapper、Mapper XML、Service、Controller 等各个模块的代码

### 3.2、AutoGenerator能干什么

对于单表而言，几乎是一个全能的工具，极大的提升了开发效率。更多的关注业务逻辑的实现。  

### 3.3、AutoGenerator使用

> AutoGenerator本身和我们项目没有关联，所以可以单独新建为一个Project，这边也做成Maven聚
> 合项目里的一个子项目  

#### 3.3.1、创建yeb-generator子工程

> 由于创建的是Maven子工程，所以会自动引入parent标签

![image-20230118142709764](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118142709764.png)

![image-20230118142923229](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118142923229.png)

#### 3.3.2、添加项目依赖

yebBack/yeb-generator/pom.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.chang</groupId>
        <artifactId>yebBack</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>

    <artifactId>yeb-generator</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!--web 依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--mybatis-plus 依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.2</version>
        </dependency>
        <!--mybatis-plus 代码生成器依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.0.5</version>
        </dependency>
        <!--freemarker 依赖-->
        <dependency>
            <groupId>org.freemarker</groupId>
            <artifactId>freemarker</artifactId>
        </dependency>
        <!--mysql 依赖-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>

    </dependencies>

</project>
```

#### 3.3.3、编写代码生成器

> 编写代码生成器CodeGenerator，将其生成在yeb-server中，而不是yeb-generator中，
>
> 将要生成的数据库表在控制台中填写，每个表名用英文逗号进行分割，例如：t_admin,t_admin_role,t_appraise,t_department,t_employee,t_employee_ec,t_employee_remove,t_employee_train,t_joblevel,t_mail_log,t_menu,t_menu_role,t_nation,t_oplog,t_politics_status,t_position,t_role,t_salary,t_salary_adjust,t_sys_msg,t_sys_msg_content

CodeGenerator：

```java
package com.chang.generator;

import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;
import com.baomidou.mybatisplus.core.toolkit.StringPool;
import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.InjectionConfig;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.po.TableInfo;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;


import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class CodeGenerator {
    /**
     * <p>
     * 读取控制台内容
     * </p>
     */
    public static String scanner(String tip) {
        Scanner scanner = new Scanner(System.in);
        StringBuilder help = new StringBuilder();
        help.append("请输入" + tip + "：");
        System.out.println(help.toString());
        if (scanner.hasNext()) {
            String ipt = scanner.next();
            if (StringUtils.isNotEmpty(ipt)) {
                return ipt;
            }
        }
        throw new MybatisPlusException("请输入正确的" + tip + "！");
    }
    public static void main(String[] args) {
        // 代码生成器
        AutoGenerator mpg = new AutoGenerator();
        // 全局配置
        GlobalConfig gc = new GlobalConfig();
        String projectPath = System.getProperty("user.dir");
        gc.setOutputDir(projectPath + "/yeb-server/src/main/java");
        //作者
        gc.setAuthor("ZhangChang");
        //打开输出目录
        gc.setOpen(false);
        //xml开启 BaseResultMap
        gc.setBaseResultMap(true);
        //xml 开启BaseColumnList
        gc.setBaseColumnList(true);
        // 实体属性 Swagger2 注解
        gc.setSwagger2(true);
        // 是否覆盖原来生成的
        gc.setFileOverride(false);
        // 去Service的I前缀
        gc.setServiceName("%sService");
        mpg.setGlobalConfig(gc);

        // 数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl("jdbc:mysql://localhost:3306/yeb?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("root");
        dsc.setPassword("mysql");
        mpg.setDataSource(dsc);

        // 包配置
        PackageConfig pc = new PackageConfig();
        pc.setParent("com.chang.yebserver")
                .setEntity("pojo")
                .setMapper("mapper")
                .setService("service")
                .setServiceImpl("service.impl")
                .setController("controller");
        mpg.setPackageInfo(pc);

        // 自定义配置
        InjectionConfig cfg = new InjectionConfig() {
            @Override
            public void initMap() {
                // to do nothing
            }
        };
        // 如果模板引擎是 freemarker
        String templatePath = "/templates/mapper.xml.ftl";
        // 如果模板引擎是 velocity
        // String templatePath = "/templates/mapper.xml.vm";
        // 自定义输出配置
        List<FileOutConfig> focList = new ArrayList<>();
        // 自定义配置会被优先输出
        focList.add(new FileOutConfig(templatePath) {
            @Override
            public String outputFile(TableInfo tableInfo) {
                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！
                return projectPath + "/yeb-server/src/main/resources/mapper/"
                        + tableInfo.getEntityName() + "Mapper"
                        + StringPool.DOT_XML;
            }
        });
        cfg.setFileOutConfigList(focList);
        mpg.setCfg(cfg);

        // 配置模板
        TemplateConfig templateConfig = new TemplateConfig();
        templateConfig.setXml(null);
        mpg.setTemplate(templateConfig);

        // 策略配置
        StrategyConfig strategy = new StrategyConfig();
        //数据库表映射到实体的命名策略
        strategy.setNaming(NamingStrategy.underline_to_camel);
        //数据库表字段映射到实体的命名策略
        strategy.setColumnNaming(NamingStrategy.nochange);
        //lombok模型
        strategy.setEntityLombokModel(true);
        //生成 @RestController 控制器
        strategy.setRestControllerStyle(true);
        strategy.setInclude(scanner("表名，多个英文逗号分割").split(","));
        strategy.setControllerMappingHyphenStyle(true);
        //表前缀
        strategy.setTablePrefix("t_");
        mpg.setStrategy(strategy);
        mpg.setTemplateEngine(new FreemarkerTemplateEngine());
        mpg.execute();
    }
}
/*表名称如下：
t_admin,t_admin_role,t_appraise,t_department,t_employee,t_employee_ec,t_employee_remove,t_employee_train,t_joblevel,t_mail_log,t_menu,t_menu_role,t_nation,t_oplog,t_politics_status,t_position,t_role,t_salary,t_salary_adjust,t_sys_msg,t_sys_msg_content
 */
```

![image-20230118152208957](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118152208957.png)

## 4、定义公共返回对象

在`com.chang.yebserver`中新建包`respPojo`，并在其中定义`RespBean`，作为公共返回对象，其中参数如下：

- code：返回状态码
- message：返回提示信息
- obj：返回对象

此外还定义了成功返回方法`success`与失败返回方法`error`

`com.chang.yebserver.respPojo.RespBean：`

```java
package com.chang.yebserver.respPojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class RespBean {
    //返回状态码
    private long code;
    //返回提示信息
    private String message;
    //返回对象
    private Object obj;

    /*
    1、定义成功返回方法，参数只有message
     */
    public static RespBean success(String message){
        return new RespBean(200,message,null);
    }

    /*
    2、定义成功返回方法，参数有message与obj
     */
    public static RespBean success(String message,Object obj){
        return new RespBean(200,message,obj);
    }

    /*
    3、定义失败返回方法，参数只有message
     */
    public static RespBean error(String message){
        return new RespBean(500,message,null);
    }

    /*
     4、定义失败返回方法，参数有message与obj
     */
    public static RespBean error(String message,Object obj){
        return new RespBean(500,message,obj);
    }
}
```

## 5、SpringSecurity与JWT

> 使用 Spring Security 框架与JWT实现登录功能,  

### 5.1、添加依赖

在`yebBack/yeb-server/pom.xml`中添加依赖：

```xml
<!--security 依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!--JWT 依赖-->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.0</version>
</dependency>
```

### 5.2、配置JWT信息

在`yebBack/yeb-server/application.yml`中增加配置：

```yml
jwt:
    # JWT存储的请求头
    tokenHeader: Authorization
    # JWT 加解密使用的密钥
    secret: yeb-secret
    # JWT的超期限时间（60*60*24：24小时失效）
    expiration: 604800
    # JWT 负载中拿到开头
    tokenHead: Bearer
```

### 5.3、配置JWT工具类JwtTokenUtils

在`com.chang.yebserver/config`中新建`security`文件夹，并在该文件夹中新建`JwtTokenUtils`工具类

![image-20230118153515172](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118153515172.png)

`JwtTokenUtils`工具类有如下5个功能：

1. 根据用户信息生成Token：generateToken()
   - 用户信息从Security框架中的UserDetails获取
   - 其中用到了私有方法generateToken()，作用是根据负载生成Token
   - 私有方法generateToken()调用generateExpirationDate()方法，生成Token的过期时间
2. 从token中获取登录用户名：getUserNameFormToken()
   - 其中用到了私有方法getClaimsFromToken()，作用是根据Token获取负载
3. 验证token是否有效：validateToken()
   - 首先根据getUserNameFormToken()获取用户名，并与UserDetails中的用户名比对
   - 使用私有方法isTokenExpired()判断Token是否过期
   - 私有方法isTokenExpired()用到了私有方法getExpiredDateFromToken()获取Token过期时间
4. 判断Token是否可以被刷新：canRefresh()
   - 其中调用私有方法isTokenExpired()判断Token是否过期
5. 刷新Token：refreshToken()
   - 其中调用私有方法getClaimsFromToken获取负载
   - 更新负载claims中的创建时间
   - 调用私有方法generateToken()重新生成Token

`com/chang/yebserver/config/security/JwtTokenUtils：`

```java
package com.chang.yebserver.config.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;


@Component
public class JwtTokenUtils {
    //负载里面的用户名
    private static final String CLAIM_KEY_USERNAME = "sub";
    //创建时间
    private static final String CLAIM_KEY_CREATED = "created";
    //Jwt密钥
    @Value("${jwt.secret}")
    private String secret;
    //Jwt失效时间
    @Value("${jwt.expiration}")
    private Long expiration;

    /**
     * 功能1：根据用户信息生成Token
     * 用户信息根据security框架中的UserDetails拿取
     */
    public String generateToken(UserDetails userDetails) {
        //准备一个负载
        Map<String,Object> claims = new HashMap<>();
        //名字
        claims.put(CLAIM_KEY_USERNAME,userDetails.getUsername());
        //创建时间
        claims.put(CLAIM_KEY_CREATED,new Date());
        return generateToken(claims);
    }

    /**
     * 一个私有方法generateToken
     * 根据负载生成JWT Token
     * @param claims
     * @return
     */
    private String generateToken(Map<String, Object> claims) {
        return Jwts.builder()
                .setClaims(claims)
                .setExpiration(generateExpirationDate())
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }

    /**
     * 生成token过期时间
     *
     * @return
     */
    private Date generateExpirationDate() {
        return new Date(System.currentTimeMillis() + expiration * 1000);
    }

    /**
     * 功能2：从token中获取登录用户名
     *
     * @param token
     * @return
     */
    public String getUserNameFormToken(String token) {
        String username;
        try {
            Claims claims = getClaimsFromToken(token);
            username = claims.getSubject();
        } catch (Exception e) {
            username = null;
        }
        return username;
    }

    /**
     * 从token中获取JWT中的负载
     *
     * @param token
     * @return
     */
    private Claims getClaimsFromToken(String token) {
        Claims claims = null;
        try {
            claims = Jwts.parser()
                    .setSigningKey(secret)
                    .parseClaimsJws(token)
                    .getBody();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return claims;
    }

    /*
    * 功能3：验证token是否有效
    *
    * @param token
    * @param userDetails
    * @return
     */
    public boolean validateToken(String token, UserDetails userDetails) {
        String username = getUserNameFormToken(token);
        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);
    }

    /**
     * 判断token是否过期
     *
     * @param token
     * @return
     */
    private boolean isTokenExpired(String token) {
        Date expiredDate = getExpiredDateFromToken(token);
        return expiredDate.before(new Date());
    }

    /**
     * 从token中获取过期时间
     *
     * @param token
     * @return
     */
    private Date getExpiredDateFromToken(String token) {
        Claims claims = getClaimsFromToken(token);
        return claims.getExpiration();
    }

    /**
     * 功能4：判断token是否可以被刷新
     * 过期了可以被刷新
     * @param token
     * @return
     */
    public boolean canRefresh(String token){
        return !isTokenExpired(token);
    }

    /**
     * 功能5：刷新token
     * @param token
     * @return
     */
    public String refreshToken(String token){
        Claims claims = getClaimsFromToken(token);
        claims.put(CLAIM_KEY_CREATED,new Date());
        return generateToken(claims);
    }

}
```

### 5.4、Admin实现UserDetails接口

在`com.chang.yebserver.pojo.Admin`中实现UserDetails接口，重写其中方法：

```java
package com.chang.yebserver.pojo;

import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;
import java.util.Collection;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

/**
 * <p>
 * 
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("t_admin")
@ApiModel(value="Admin对象", description="")
public class Admin implements Serializable, UserDetails {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "id")
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @ApiModelProperty(value = "姓名")
    private String name;

    @ApiModelProperty(value = "手机号码")
    private String phone;

    @ApiModelProperty(value = "住宅电话")
    private String telephone;

    @ApiModelProperty(value = "联系地址")
    private String address;

    @ApiModelProperty(value = "是否启用")
    private Boolean enabled;

    @ApiModelProperty(value = "用户名")
    private String username;

    @ApiModelProperty(value = "密码")
    private String password;

    @ApiModelProperty(value = "用户头像")
    private String userFace;

    @ApiModelProperty(value = "备注")
    private String remark;


    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return null;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    //上方已经定义了enabled属性：“是否启用”
    @Override
    public boolean isEnabled() {
        return enabled;
    }
}
```

### 5.5、用户登录实体类AdminLoginParam

用户登录实体类AdminLoginParam用来接收前端传递来的登录信息，没有必要使用参数过多的Admin类

在`com.chang.yebserver`中创建`reqPojo`包用来存放前端传递信息的接收类，在其中创建`AdminLoginParam`

```java
package com.chang.yebserver.reqPojo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/*
用户登录实体类
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@ApiModel(value = "AdminLoginParam对象",description = "")
public class AdminLoginParam {
    @ApiModelProperty(value = "用户名",required = true)
    private String username;
    @ApiModelProperty(value = "密码",required = true)
    private String password;
}
```

### 5.6、SpringSecurity配置

在`com.chang.yebserver.config.security`中新增`SecurityConfig`类

- 重写`UserDetailsService方法`，使用AdminService中的getAdminByUserName方法从数据库中查询Admin对象
- 设置密码解析器：`passwordEncoder`
- 重写`configure(AuthenticationManagerBuilder auth)`，让Security走登录逻辑时使用我们的UserDetails自定义方法
- 重写Security的配置类`configure(HttpSecurity http)`，在其中设置权限路径、Jwt登录授权过滤器、当未登录或者token失效时访问返回信息、访问接口没有权限返回信息

![image-20230118191943415](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118191943415.png)

#### 5.6.1、JwtAuthenticationTokenFilter

JwtAuthenticationTokenFilter：Jwt登录授权过滤器

```java
package com.chang.yebserver.config.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/*
Jwt登录授权过滤器
 */
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    @Value("${jwt.tokenHeader}")
    private String tokenHeader;

    @Value("${jwt.tokenHead}")
    private String tokenHead;

    @Autowired
    private JwtTokenUtils jwtTokenUtils;

    @Autowired
    private UserDetailsService userDetailsService;

    /*
    前置拦截
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //拿到要验证的头
        String authHeader = request.getHeader(tokenHeader);
        //存在Token
        if(null!=authHeader && authHeader.startsWith(tokenHead)){
            String authToken = authHeader.substring(tokenHead.length());
            String username = jwtTokenUtils.getUserNameFormToken(authToken);
            //能在Token拿到用户名，但在Security上下文拿不到，也就是Token存在用户名但未登录
            if(null!=username && null== SecurityContextHolder.getContext().getAuthentication()){
                //登录
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                //验证token是否有效，重新设置用户对象
                if(jwtTokenUtils.validateToken(authToken,userDetails)){
                    UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);
                }
            }
        }
        filterChain.doFilter(request,response);
    }
}
```

#### 5.6.2、RestAuthorizationEntryPoint

```java
package com.chang.yebserver.config.security;

import com.chang.yebserver.respPojo.RespBean;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/*
当未登录或者token失效时访问接口，自定义的返回结果
 */
@Component
public class RestAuthorizationEntryPoint implements AuthenticationEntryPoint{

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        response.setCharacterEncoding("utf-8");
        response.setContentType("application/json");
        PrintWriter out = response.getWriter();
        RespBean bean = RespBean.error("未登录或者token失效，请重新登录！");
        bean.setCode(401);
        out.write(new ObjectMapper().writeValueAsString(bean));
        out.flush();
        out.close();
    }
}
```

#### 5.6.3、RestfulAccessDeniedHandler

```java
package com.chang.yebserver.config.security;

import com.chang.yebserver.respPojo.RespBean;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/*
当访问接口没有权限时，自定义返回结果
 */
@Component
public class RestfulAccessDeniedHandler implements AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        response.setCharacterEncoding("utf-8");
        response.setContentType("application/json");
        PrintWriter out = response.getWriter();
        RespBean bean = RespBean.error("权限不足，请联系管理员！");
        bean.setCode(403);
        out.write(new ObjectMapper().writeValueAsString(bean));
        out.flush();
        out.close();
    }
}
```

#### 5.6.4、SecurityConfig

> **注意：要在AdminService加上@Lazy注解，否侧会造成循环依赖错误！！！**

```java
package com.chang.yebserver.config.security;

/*
Security配置类
 */

import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.service.AdminService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Lazy
    @Autowired
    private AdminService adminService;
    
    //当未登录或者token失效时访问接口返回信息
    @Autowired
    private RestAuthorizationEntryPoint restAuthorizationEntryPoint;

    //访问接口没有权限返回信息
    @Autowired
    private RestfulAccessDeniedHandler restfulAccessDeniedHandler;

    /*
    Security完整配置
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //使用JWT，不需要使用csrf
        http.csrf().disable()
                //基于token，不需要session
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                //除上面外，所有请求都要求认证
                .anyRequest()
                .authenticated()
                .and()
                //禁用缓存
                .headers()
                .cacheControl();
        //添加jwt登录授权过滤器
        http.addFilterBefore(jwtAuthenticationTokenFilter(),UsernamePasswordAuthenticationFilter.class);
        //添加自定义未授权和未登录结果返回
        http.exceptionHandling()
                .accessDeniedHandler(restfulAccessDeniedHandler)
                .authenticationEntryPoint(restAuthorizationEntryPoint);
    }

    /*
    让Security走登录逻辑时使用我们的UserDetails自定义方法
    */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception{
        auth.userDetailsService(userDetailsService())
                .passwordEncoder(passwordEncoder());
    }

    /*
    重写UserDetailsService
     */
    @Override
    @Bean
    public UserDetailsService userDetailsService(){
        return username -> {
            Admin admin = adminService.getAdminByUserName(username);
            if (null!=admin){
                return admin;
            }
            return null;
        };
    }

    /*
    密码解析器
     */
    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    /*
	Jwt登录授权过滤器
     */
    @Bean
    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter() {
        return new JwtAuthenticationTokenFilter();
    }
}
```

### 5.7、登录控制器LoginController

在`com.chang.yebserver.controller`中创建`LoginController`，作为登录功能的控制器，其中包含3个功能：

1. 登录之后返回Token
   - 接收前端传递过来的adminLoginParam对象，将其中的username、password传递给adminService中的`login`方法
2. 获取当前登录用户的信息
   - 登录成功后，用户信息被更新存放到security全文中，可以通过principal获取
   - 通过principle获取当前登录人员的用户名，并将其传递给adminService中的`getAdminByUserName`方法获取Admin对象
3. 退出登录
   - 正常的流程是登录成功后返回token，前端会token放在请求头里面，访问任何接口都会携带这个token令牌，我们通过一个拦截器判断这个token是否合法且有效，只有合法有效才能方位其他的接口，如果非法则无法访问。
   - 和前端定义好，调用后端退出登录的接口，返回一个"退出成功"以及200的状态码，前端拿到这个200状态码之后直接在请求头中将token删除，之后再调接口就会被拦截器拦截无法访问
   - 这样做是为了提高系统的响应速度，验证信息不走后端，只在前端比较字符串

**com.chang.yebserver.controller.LoginController：**

```java
package com.chang.yebserver.controller;

import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.reqPojo.AdminLoginParam;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.service.AdminService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.security.Principal;

@RestController
@Api(tags = "LoginController")
public class LoginController {

    @Autowired
    private AdminService adminService;

    @ApiOperation(value = "登录之后返回Token")
    @PostMapping("/login")
    public RespBean login(@RequestBody AdminLoginParam adminLoginParam, HttpServletRequest request) {
        return adminService.login(adminLoginParam.getUsername(),adminLoginParam.getPassword(),request);
    }

    @ApiOperation(value = "获取当前登录用户的信息")
    @GetMapping("/admin/info")
    //登录成功后，用户信息被更新存放到security全文中，可以通过principal获取
    public Admin getAdminInfo(Principal principal){
        if(null==principal){
            return null;
        }
        String username = principal.getName();
        Admin admin = adminService.getAdminByUserName(username);
        //用户密码即使加密也不应该被返回，所以要设置为null
        admin.setPassword(null);
        return admin;
    }

    /*
    正常的流程是登录成功后返回token，前端会token放在请求头里面，访问任何接口都会携带这个token令牌，我们通过一个拦截器判断这个token是否合法且有效，只有合法有效才能方位其他的接口，如果非法则无法访问。
    和前端定义好，调用后端退出登录的接口，返回一个"退出成功"以及200的状态码，前端拿到这个200状态码之后直接在请求头中将token删除，之后再调接口就会被拦截器拦截无法访问
    这样做是为了提高系统的响应速度，验证信息不走后端，只在前端比较字符串
     */
    @ApiOperation(value = "退出登录")
    @PostMapping("/logout")
    public RespBean logout(){
        return RespBean.success("注销成功！");
    }
}
```

### 5.8、登录业务器AdminService

com.chang.yebserver.service.AdminService：

```java
package com.chang.yebserver.service;

import com.chang.yebserver.pojo.Admin;
import com.baomidou.mybatisplus.extension.service.IService;
import com.chang.yebserver.respPojo.RespBean;

import javax.servlet.http.HttpServletRequest;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
public interface AdminService extends IService<Admin> {
    /*
    登录之后返回Token
     */
    RespBean login(String username, String password, HttpServletRequest request);

    /*
    根据用户名获取用户
     */
    Admin getAdminByUserName(String username);
}
```

**com.chang.yebserver.service.impl.AdminServiceImpl：**

- 使用`userDetailsService.loadUserByUsername(username)`进行登录，然后放在Security全文当中方便使用，然后使用`jwtTokenUtils.generateToken(userDetails)`生成Token

```java
package com.chang.yebserver.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.chang.yebserver.config.security.JwtTokenUtils;
import com.chang.yebserver.mapper.AdminMapper;
import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.service.AdminService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Service
public class AdminServiceImpl extends ServiceImpl<AdminMapper, Admin> implements AdminService {

    //基于SpringSecurity验证，所以首先要注入UserDetailsService
    @Autowired
    private UserDetailsService userDetailsService;

    //SpringSecurity密码校验
    @Autowired
    private PasswordEncoder passwordEncoder;

    //注入Jwt工具类获取令牌
    @Autowired
    private JwtTokenUtils jwtTokenUtils;

    //注入token的头部信息，通过@Value从application.yml中获取
    @Value("${jwt.tokenHead}")
    private String tokenHead;

    //根据用户名去数据库获取Admin信息
    @Autowired
    private AdminMapper adminMapper;

    /*
    登录之后返回Token
     */
    @Override
    public RespBean login(String username, String password, HttpServletRequest request) {
        //登录
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        if(userDetails==null || !passwordEncoder.matches(password,userDetails.getPassword())){
            //没有获取到userDetails或者密码没有匹配成功
            return RespBean.error("用户名或者密码不正确");
        }
        if(!userDetails.isEnabled()){
            return RespBean.error("账号被禁用，请联系管理员");
        }

        //更新security登录用户对象，将用户信息放在SpringSecurity全文中
        //第1个参数是userDetails，第2个参数是密码，第3个参数是权限
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);

        //生成Token
        String token = jwtTokenUtils.generateToken(userDetails);
        Map<String,String> tokenMap = new HashMap<>();
        tokenMap.put("token",token);
        tokenMap.put("tokenHead",tokenHead);
        return RespBean.success("登录成功",tokenMap);
    }

    /*
    根据用户名获取用户
     */
    @Override
    public Admin getAdminByUserName(String username) {
        return adminMapper.selectOne(new QueryWrapper<Admin>().eq("username",username).eq("enabled",true));
    }
    
}
```

## 6、Swagger2接口文档

### 6.1、Swagger2所需依赖

```xml
		<!-- swagger2 依赖 -->
		<dependency>
            <groupId>io.swagger</groupId>
            <artifactId>swagger-annotations</artifactId>
            <version>1.5.21</version>
        </dependency>

        <dependency>
            <groupId>io.swagger</groupId>
            <artifactId>swagger-models</artifactId>
            <version>1.5.21</version>
        </dependency>

        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>

        <!-- Swagger第三方ui依赖 -->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>swagger-bootstrap-ui</artifactId>
            <version>1.9.6</version>
        </dependency>
```

### 6.2、Swagger2配置

在`com.chang.yebserver.config`中创建`Swagger2Config`，作为Swagger2的配置类

```java
package com.chang.yebserver.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/*
Swagger2配置类
 */
@Configuration
@EnableSwagger2
public class Swagger2Config {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo()) //文档信息
                .select()
                //为当前包下的controller生成api文档
                .apis(RequestHandlerSelectors.basePackage("com.chang.yebserver.controller"))
                .paths(PathSelectors.any())
                .build();
    }
    private ApiInfo apiInfo() {
        //设置文档信息
        return new ApiInfoBuilder()
                .title("云E办接口文档")
                .description("云E办接口文档")
                .contact(new Contact("ZhangChang", "http:localhost:8081/doc.html",
                        "ZhangChang@java.com"))
                .version("1.0")
                .build();
    }
}
```

### 6.3、application.yml增加配置

> **修改原因是Springfox使用的路径匹配是基于AntPathMatcher的，而Spring Boot 2.6.X使用的是PathPatternMatcher，修改application.yaml spring: mvc: pathmatch: matching-strategy: ANT_PATH_MATCHER**

```yml
spring:  
  mvc:
    pathmatch:
      matching-strategy: ant_path_matcher
```

### 6.4、测试接口

在controller中增加HelloController：

```java
package com.chang.yebserver.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {
    @GetMapping("/hello")
    public String hello(){
        return "hello";
    }
}
```

### 6.5、测试访问

访问：

```http
http:localhost:8081/doc.html  
```

![image-20230118213305179](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118213305179.png)

> **原因：Security没有放行Swagger2**

### 6.6、Security配置放行内容

在`com.chang.yebserver.config.security.SecurityConfig`增加如下配置：

```java
	/*
    配置Security放行内容
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(
                "/login",
                "/logout",
                "/css/**",
                "/js/**",
                "index.html",
                "favicon.ico",
                "/doc.html",
                "/webjars/**",
                "/swagger-resources/**",
                "/v2/api-docs/**"
        );
    }
```

再次访问就可以进入主页，但任然无法访问“/hello”，这是因为还没有登录

```http
http:localhost:8081/doc.html  
```

![image-20230118214249054](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118214249054.png)

![image-20230118214304417](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118214304417.png)

### 6.7、添加全局Authorize

> 添加全局Authorize作为登录令牌，以下配置为Swagger2完整配置！！！其中包括“设置需要登录认证的路径”、“设置请求头信息”
>
> 主要是在`new Docket().build().securityContexts(securityContexts()).securitySchemes(securitySchemes());`

`com.chang.yebserver.config.Swagger2Config`：

```java
package com.chang.yebserver.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.*;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spi.service.contexts.SecurityContext;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import java.util.ArrayList;
import java.util.List;

/*
Swagger2配置类
 */
@Configuration
@EnableSwagger2
public class Swagger2Config {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo()) //文档信息
                .select()
                //为当前包下的controller生成api文档
                .apis(RequestHandlerSelectors.basePackage("com.chang.yebserver.controller"))
                .paths(PathSelectors.any())
                .build()
                .securityContexts(securityContexts())
                .securitySchemes(securitySchemes());
    }
    private ApiInfo apiInfo() {
        //设置文档信息
        return new ApiInfoBuilder()
                .title("云E办接口文档")
                .description("云E办接口文档")
                .contact(new Contact("ZhangChang", "http:localhost:8081/doc.html",
                        "ZhangChang@java.com"))
                .version("1.0")
                .build();
    }

    private List<SecurityContext> securityContexts() {
        //设置需要登录认证的路径
        List<SecurityContext> result = new ArrayList<>();
        result.add(getContextByPath("/hello/.*"));
        return result;
    }

    private SecurityContext getContextByPath(String pathRegex) {
        return SecurityContext.builder()
                .securityReferences(defaultAuth())
                .forPaths(PathSelectors.regex(pathRegex))
                .build();
    }

    private List<SecurityReference> defaultAuth() {
        List<SecurityReference> result = new ArrayList<>();
        //授权范围是全局“global”，后面那个参数是描述
        AuthorizationScope authorizationScope = new AuthorizationScope("global","accessEverything");
        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];
        authorizationScopes[0] = authorizationScope;
        result.add(new SecurityReference("Authorization",authorizationScopes));
        return result;
    }

    private List<ApiKey> securitySchemes(){
        //设置请求头信息
        List<ApiKey> result = new ArrayList<>();
        ApiKey apiKey = new ApiKey("Authorization","Authorization","header");
        result.add(apiKey);
        return result;
    }
}
```

### 6.8、安全测试运行

1. 访问：

   ```http
   localhost:8081/doc.html
   ```

   ![image-20230118221128433](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118221128433.png)

2. 在“登录之后返回Token”页面中以Json格式输入用户名"admin"与密码"123"，点解发送，可以在下方获得token的值

   ![image-20230118221401396](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118221401396.png)

3. 将上面token的值复制，然后打开Authorize页面，在其中参数值一栏输入：

   ```text
   Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE2NzQwNTEyMDU3MjgsImV4cCI6MTY3NDY1NjAwNX0.akl8qlGaJhHNJm3Kt5Wq9idY5Q5cBU0sofFJD-H4EMAQR-YAMVO4DK9R9TgWhjmTEfaxTO6JrYkdh9zl5T8V2g
   ```

   Bearer即项目中设置的tokenHead，也就是负载的开头，可以根据需要进行替换，但值得注意的是：

   **Bearer与token具体值之间必须要有一个`空格`隔开**，输入完毕后点击右侧保存按钮

   ![image-20230118222017520](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118222017520.png)

4. 测试正常访问

   1. 对于“获取当前登录用户的信息”，其路由为“/admin/info”，在参数值中输入当前登录的用户名admin，即可查看对象的完整具体信息（密码除外）

      ![image-20230118222310518](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118222310518.png)

   2. 对于路由"/hello"也可访问

      ![image-20230118222406696](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118222406696.png)

## 7、Kaptcha验证码

> 图像验证码显示功能使用 google Kaptcha 验证码产品 实现前台验证码显示功能  

### 7.1、Kaptcha依赖

`yebBack/yeb-server/pom.xml`

```xml
		<!-- google kaptcha依赖 -->
        <dependency>
            <groupId>com.github.axet</groupId>
            <artifactId>kaptcha</artifactId>
            <version>0.0.9</version>
        </dependency>	
```

### 7.2、Kaptcha配置类

> 直接使用，无需更改

`com.chang.yebserver.config.CaptchaConfig`

```java
package com.chang.yebserver.config;

import com.google.code.kaptcha.impl.DefaultKaptcha;
import com.google.code.kaptcha.util.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Properties;


/**
 * 验证码配置类
 */
@Configuration
public class CaptchaConfig {
    @Bean
    public DefaultKaptcha getDefaultKaptcha() {
        //验证码生成器
        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
        //配置
        Properties properties = new Properties();
        //是否有边框
        properties.setProperty("kaptcha.border", "yes");
        //设置边框颜色
        properties.setProperty("kaptcha.border.color", "105,179,90");
        //边框粗细度，默认为1
        // properties.setProperty("kaptcha.border.thickness","1");
        //验证码
        properties.setProperty("kaptcha.session.key", "code");
        //验证码文本字符颜色 默认为黑色
        properties.setProperty("kaptcha.textproducer.font.color", "blue");
        //设置字体样式
        properties.setProperty("kaptcha.textproducer.font.names", "宋体,楷体,微软雅黑");
        //字体大小，默认40
        properties.setProperty("kaptcha.textproducer.font.size", "30");
        //验证码文本字符内容范围 默认为abced2345678gfynmnpwx
        // properties.setProperty("kaptcha.textproducer.char.string", "");
        //字符长度，默认为5
        properties.setProperty("kaptcha.textproducer.char.length", "4");
        //字符间距 默认为2
        properties.setProperty("kaptcha.textproducer.char.space", "4");
        //验证码图片宽度 默认为200
        properties.setProperty("kaptcha.image.width", "100");
        //验证码图片高度 默认为40
        properties.setProperty("kaptcha.image.height", "40");
        Config config = new Config(properties);
        defaultKaptcha.setConfig(config);
        return defaultKaptcha;
    }
}
```

### 7.3、验证码生成接口

在`com.chang.yebserver.controller.CaptchaController`中提供“/captcha”路由作用在captcha方法上，该方法用来生成验证码，并存放在session中，此外还会在控制台中打印出来，方便对比

```java
package com.chang.yebserver.controller;

import com.google.code.kaptcha.impl.DefaultKaptcha;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;

import org.springframework.web.bind.annotation.RestController;
import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.IOException;

/**
 * 验证码Controller
 */
@RestController
public class CaptchaController {

    @Autowired
    private DefaultKaptcha defaultKaptcha;

    @ApiOperation(value = "验证码")
    @GetMapping(value = "/captcha", produces = "image/jpeg")
    public void captcha(HttpServletRequest request, HttpServletResponse response) {
        // 定义response输出类型为image/jpeg类型
        response.setDateHeader("Expires", 0);
        // Set standard HTTP/1.1 no-cache headers.
        response.setHeader("Cache-Control", "no-store, no-cache, mustrevalidate");
        // Set IE extended HTTP/1.1 no-cache headers (use addHeader).
        response.addHeader("Cache-Control", "post-check=0, pre-check=0");
        // Set standard HTTP/1.0 no-cache header.
        response.setHeader("Pragma", "no-cache");
        // return a jpeg
        response.setContentType("image/jpeg");
        //-------------------生成验证码 begin --------------------------
        //获取验证码文本内容
        String text = defaultKaptcha.createText();
        System.out.println("验证码内容：" + text);
        //将验证码放入session中
        request.getSession().setAttribute("captcha", text);
        //根据文本内容创建图形验证码
        BufferedImage image = defaultKaptcha.createImage(text);
        ServletOutputStream outputStream = null;
        try {
            outputStream = response.getOutputStream();
            //输出流输出图片，格式jpg
            ImageIO.write(image, "jpg", outputStream);
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (null != outputStream) {
                try {
                    outputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        //-------------------生成验证码 end ----------------------------
    }
}
```

### 7.4、验证码接口放行

在`com.chang.yebserver.config.security.SecurityConfig`中增加验证码路由接口的放行，即不需要登录即可访问

```java
	/*
    配置Security放行内容
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(
                "/login",
                "/logout",
                "/css/**",
                "/js/**",
                "index.html",
                "favicon.ico",
                "/doc.html",
                "/webjars/**",
                "/swagger-resources/**",
                "/v2/api-docs/**",
                "/captcha"
        );
    }
```

### 7.5、验证码生成测试

![image-20230118224941897](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118224941897.png)

![image-20230118225023597](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118225023597.png)

### 7.6、登录参数对象添加验证码属性  

`com.chang.yebserver.reqPojo.AdminLoginParam`

```java
package com.chang.yebserver.reqPojo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/*
用户登录实体类
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@ApiModel(value = "AdminLoginParam对象",description = "")
public class AdminLoginParam {
    @ApiModelProperty(value = "用户名",required = true)
    private String username;
    @ApiModelProperty(value = "密码",required = true)
    private String password;
    @ApiModelProperty(value = "验证码", required = true)
    private String code;
}
```

### 7.7、登录方法添加验证码判断  

1. `com.chang.yebserver.controller.LoginController`：

   ```java
   	@ApiOperation(value = "登录之后返回Token")
       @PostMapping("/login")
       public RespBean login(@RequestBody AdminLoginParam adminLoginParam, HttpServletRequest request) {
           return adminService.login(adminLoginParam.getUsername(),adminLoginParam.getPassword(),adminLoginParam.getCode(),request);
       }
   ```

2. `com.chang.yebserver.service.AdminService`：

   ```java
   public interface AdminService extends IService<Admin> {
       /*
       登录之后返回Token
        */
       RespBean login(String username, String password, String code, HttpServletRequest request);
   
       /*
       根据用户名获取用户
        */
       Admin getAdminByUserName(String username);
   }
   ```
   
3. `com.chang.yebserver.service.impl.AdminServiceImpl`：

   ```java
       /*
       登录之后返回Token
        */
       @Override
       public RespBean login(String username, String password, String code, HttpServletRequest request) {
           String captcha = (String) request.getSession().getAttribute("captcha");
           if (StringUtils.isBlank(code) || !captcha.equals(code)) {
               return RespBean.error("验证码填写错误，请重新输入！");
           }
           //登录
           UserDetails userDetails = userDetailsService.loadUserByUsername(username);
           if(userDetails==null || !passwordEncoder.matches(password,userDetails.getPassword())){
               //没有获取到userDetails或者密码没有匹配成功
               return RespBean.error("用户名或者密码不正确");
           }
           if(!userDetails.isEnabled()){
               return RespBean.error("账号被禁用，请联系管理员");
           }
   
           //更新security登录用户对象，将用户信息放在SpringSecurity全文中
           //第1个参数是userDetails，第2个参数是密码，第3个参数是权限
           UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
           SecurityContextHolder.getContext().setAuthentication(authenticationToken);
   
           //生成Token
           String token = jwtTokenUtils.generateToken(userDetails);
           Map<String,String> tokenMap = new HashMap<>();
           tokenMap.put("token",token);
           tokenMap.put("tokenHead",tokenHead);
           return RespBean.success("登录成功",tokenMap);
       }
   ```
   
   ![image-20230118231145412](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118231145412.png)

### 7.8、验证码校验测试

1. 先在“/captcha”中生成验证码，例如：y3mp

   ![image-20230118231328226](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118231328226.png)

2. 然后在“/login”中输入用户名、密码、验证码，获取Token

   ![image-20230118231519503](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118231519503.png)

3. 之后在Authorize中更新Token即可

   ![image-20230118231634594](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230118231634594.png)

## 8、MyBatisPlus根据id查询列表（多表查询）

> **使用mybatisplus根据用户Id查询菜单列表**

### 8.1、修改菜单类Menu

> 菜单分两级，一级菜单下面有子菜单，所以需要添加集合类型的**子菜单children**
>
> 并且需要在children上增加注解`@TableField(exist = false)`，表示该字段并不存在与数据库的对应表单中

`com.chang.yebserver.pojo.Menu`：

```java
package com.chang.yebserver.pojo;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;
import java.util.List;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/**
 * <p>
 * 
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("t_menu")
@ApiModel(value="Menu对象", description="")
public class Menu implements Serializable {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "id")
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @ApiModelProperty(value = "url")
    private String url;

    @ApiModelProperty(value = "path")
    private String path;

    @ApiModelProperty(value = "组件")
    private String component;

    @ApiModelProperty(value = "菜单名")
    private String name;

    @ApiModelProperty(value = "图标")
    private String iconCls;

    @ApiModelProperty(value = "是否保持激活")
    private Boolean keepAlive;

    @ApiModelProperty(value = "是否要求权限")
    private Boolean requireAuth;

    @ApiModelProperty(value = "父id")
    private Integer parentId;

    @ApiModelProperty(value = "是否启用")
    private Boolean enabled;

    @ApiModelProperty(value = "子菜单")
    //表示数据库的表中没有如下字段
    @TableField(exist = false)
    private List<Menu> children;

}
```

### 8.2、查询菜单接口MenuController

> 根据数据库的表t_menu，菜单一般放在系统管理里面，所以其路由设置为"/system/config"

`com.chang.yebserver.controller.MenuController`：

```java
package com.chang.yebserver.controller;

import com.chang.yebserver.pojo.Menu;
import com.chang.yebserver.service.MenuService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@RestController
//查询数据库的表t_menu，菜单一般放在系统管理里面，所以其路由设置为"/system/config"
@RequestMapping("/system/config")
public class MenuController {

    @Autowired
    private MenuService menuService;

    @ApiOperation(value = "通过用户id获取菜单列表")
    @GetMapping("/menu")
    public List<Menu> getMenusByHrId(){
        //之所以没有传入参数，是因为使用security即可在全局范围内获取到用户对象
        return menuService.getMenusByAdminId();
    }

}
```

### 8.3、查询菜单业务接口MenuService

`com.chang.yebserver.service.MenuService`：

```java
package com.chang.yebserver.service;

import com.chang.yebserver.pojo.Menu;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
public interface MenuService extends IService<Menu> {

    /**
     * 通过用户id获取菜单列表
     * @return
     */
    List<Menu> getMenusByAdminId();

}
```

`com.chang.yebserver.service.impl.MenuServiceImpl`：

```java
package com.chang.yebserver.service.impl;

import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.pojo.Menu;
import com.chang.yebserver.mapper.MenuMapper;
import com.chang.yebserver.service.MenuService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Service
public class MenuServiceImpl extends ServiceImpl<MenuMapper, Menu> implements MenuService {
    @Autowired
    private MenuMapper menuMapper;
    /**
     * 通过用户id获取菜单列表
     * 通过SecurityContextHolder获得用户，并且获得用户Id
     * @return
     */
    @Override
    public List<Menu> getMenusByAdminId() {
        return menuMapper.getMenusByAdminId(((Admin) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId());
    }

}
```

### 8.4、查询菜单持久层MenuMapper

> 该功能需要连表查询，使用MyBatisPlus实现起来比较复杂，因此选择直接使用SQL语句进行查询

`com.chang.yebserver.mapper.MenuMapper`：

```java
package com.chang.yebserver.mapper;

import com.chang.yebserver.pojo.Menu;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Repository
public interface MenuMapper extends BaseMapper<Menu> {

    /*
    根据用户ID查询菜单列表
     */
    List<Menu> getMenusByAdminId(Integer id);
}
```

`mapper/MenuMapper.xml`

> - 使用#{id}将用户id作为参数传入查询语句
> - getMenusByAdminId查询结果为Menus
> - Menus继承自BaseResultMap，所以只需要补充collection标签，针对children字段存放子菜单数据
> - 其中：
>   - collection ：关联关系，是实现一对多的关键
>   - property ：javabean中容器对应字段名
>   - ofType ：指定集合中元素的对象类型
>   - select ：使用另一个查询封装的结果
>   - column ：数据库中的列名，与 select 配合使用  

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.chang.yebserver.mapper.MenuMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.chang.yebserver.pojo.Menu">
        <id column="id" property="id" />
        <result column="url" property="url" />
        <result column="path" property="path" />
        <result column="component" property="component" />
        <result column="name" property="name" />
        <result column="iconCls" property="iconCls" />
        <result column="keepAlive" property="keepAlive" />
        <result column="requireAuth" property="requireAuth" />
        <result column="parentId" property="parentId" />
        <result column="enabled" property="enabled" />
    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
        id, url, path, component, name, iconCls, keepAlive, requireAuth, parentId, enabled
    </sql>

    <resultMap id="Menus" type="com.chang.yebserver.pojo.Menu" extends="BaseResultMap">
        <collection property="children" ofType="com.chang.yebserver.pojo.Menu">
            <id column="id2" property="id" />
            <result column="url2" property="url" />
            <result column="path2" property="path" />
            <result column="component2" property="component" />
            <result column="name2" property="name" />
            <result column="iconCls2" property="iconCls" />
            <result column="keepAlive2" property="keepAlive" />
            <result column="requireAuth2" property="requireAuth" />
            <result column="parentId2" property="parentId" />
            <result column="enabled2" property="enabled" />
        </collection>
    </resultMap>

    <!--通过用户id获取菜单列表-->
    <select id="getMenusByAdminId" resultMap="Menus">
        SELECT
            DISTINCT m1.*,
                     m2.id as id2,
        			 m2.url as url2,
                     m2.component as component2,
                     m2.enabled as enabled2,
                     m2.iconCls as iconCls2,
                     m2.keepAlive as keepAlive2,
                     m2.name as name2,
                     m2.parentId as parentId2,
                     m2.requireAuth as requireAuth2,
                     m2.path as path2
        FROM
            t_menu m1,
            t_menu m2,
            t_admin_role ar,
            t_menu_role mr
        WHERE
            m1.id = m2.parentId
          AND ar.adminId = #{id}
          AND ar.rid = mr.rid
          AND mr.mid = m2.id
          AND m2.enabled = true
        ORDER BY
            m1.id,
            m2.id
    </select>

</mapper>
```

> 使用上述查询语句直接查询结果如下图，可以看到左侧的一级菜单会对应右侧多个二级菜单

![image-20230119002558159](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119002558159.png)

> 使用Swagger2测试如下图，可以看到查询出多个一级菜单，并且一级菜单包含着二级菜单

![image-20230119002755953](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119002755953.png)

## 9、Redis菜单优化

> 菜单大部分情况下不会出现变化，我们可以将其放入 Redis 加快加载速度。

### 9.1、Redis依赖

```xml
<!-- spring data redis 依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!-- commons-pool2 对象池依赖 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

### 9.2、Redis配置信息

`application.yml`：

```yml
  # Redis配置
  redis:
    timeout: 10000ms          # 连接超时时间
    host: 127.0.0.1           # Redis服务器地址
    port: 6379                # Redis服务器端口
    database: 0               # 选择哪个库，默认0库
    lettuce:
      pool:
        max-active: 1024      # 最大连接数，默认 8
        max-wait: 10000ms     # 最大连接阻塞等待时间，单位毫秒，默认 -1
        max-idle: 200         # 最大空闲连接，默认 8
        min-idle: 5           # 最小空闲连接，默认 0
```

### 9.3、Redis配置类RedisConfig  

> 主要是一些序列化的配置

`com.chang.yebserver.config.RedisConfig`：

```java
package com.chang.yebserver.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * Redis配置类
 */
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String,Object> redisTemplate(LettuceConnectionFactory redisConnectionFactory){
        RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();
        //为string类型key设置序列器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //为string类型value设置序列器
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        //为hash类型key设置序列器
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //为hash类型value设置序列器
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;
    }
}
```

### 9.4、修改菜单查询MenuServiceImpl

> 首选会尝试从redis中直接获取，如果获取成功直接返回，获取失败则从MySQL数据库中查询，并将结果存储在Redis中

`com.chang.yebserver.service.impl.MenuServiceImpl`

```java
package com.chang.yebserver.service.impl;

import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.pojo.Menu;
import com.chang.yebserver.mapper.MenuMapper;
import com.chang.yebserver.service.MenuService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.util.List;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Service
public class MenuServiceImpl extends ServiceImpl<MenuMapper, Menu> implements MenuService {
    @Autowired
    private MenuMapper menuMapper;

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 通过用户id获取菜单列表
     * @return
     */
    @Override
    public List<Menu> getMenusByAdminId() {
        Integer adminId = ((Admin) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId();
        ValueOperations<String, Object> valueOperations = redisTemplate.opsForValue();
        //查询redis缓存中是否有数据
        List<Menu> menus = (List<Menu>) valueOperations.get("menu_" + adminId);
        if (CollectionUtils.isEmpty(menus)){
            //如果没数据，数据库中查询，并设置到缓存中
            menus = menuMapper.getMenusByAdminId(adminId);
            valueOperations.set("menu_"+adminId,menus);
        }
        return menus;
    }

}
```

## 10、Security权限管理

### 10.1、权限管理RBAC基本概念

RBAC是基于角色的访问控制（ Role-Based Access Control ）在RBAC中，权限与角色相关联，用户通过扮演适当的角色从而得到这些角色的权限。这样管理都是层级相互依赖的，权限赋予给角色，角色又赋予用户，这样的权限设计很清楚，管理起来很方便。

RBAC授权实际上是 Who 、 What 、 How 三元组之间的关系，也就是 Who 对 What 进行 How 的操作，**简单说明就是谁对什么资源做了怎样的操作。**  

### 10.2、RBAC表结构设计  

#### 10.2.1、实体对应关系

用户-角色-资源实体间对应关系图分析如下：

![image-20230119012831359](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119012831359.png)

这里用户与角色实体对应关系为多对多,角色与资源对应关系同样为多对多关系，所以在实体设计上用户与角色间增加用户角色实体,将多对多的对应关系拆分为一对多，同理，角色与资源多对多对应关系拆分出中间实体对象权限实体。  

#### 10.2.2、表结构设计

从上面实体对应关系分析,权限表设计分为以下基本的五张表结构:用户表(admin),角色表(role),用户角色表(admin_role),菜单表(menu),菜单权限表(menu_role)，表结构关系如下:  

![image-20230119013302064](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119013302064.png)

### 10.3、根据请求的url判断角色

> **根据当前请求的Url，获取所有能够匹配的角色**

#### 10.3.1、修改菜单类

> 在菜单类里添加角色列表属性  

`com.chang.yebserver.pojo.Menu`：

```java
package com.chang.yebserver.pojo;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;
import java.util.List;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/**
 * <p>
 * 
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("t_menu")
@ApiModel(value="Menu对象", description="")
public class Menu implements Serializable {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "id")
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @ApiModelProperty(value = "url")
    private String url;

    @ApiModelProperty(value = "path")
    private String path;

    @ApiModelProperty(value = "组件")
    private String component;

    @ApiModelProperty(value = "菜单名")
    private String name;

    @ApiModelProperty(value = "图标")
    private String iconCls;

    @ApiModelProperty(value = "是否保持激活")
    private Boolean keepAlive;

    @ApiModelProperty(value = "是否要求权限")
    private Boolean requireAuth;

    @ApiModelProperty(value = "父id")
    private Integer parentId;

    @ApiModelProperty(value = "是否启用")
    private Boolean enabled;

    @ApiModelProperty(value = "子菜单")
    //表示数据库的表中没有如下字段
    @TableField(exist = false)
    private List<Menu> children;
    
    @ApiModelProperty(value = "角色列表")
    @TableField(exist = false)
    private List<Role> roles;

}
```

#### 10.3.2、修改查询菜单业务接口MenuService

> 增加通过角色获取菜单列表方法：getAllMenusWithRole()

`com.chang.yebserver.service.MenuService`

```java
package com.chang.yebserver.service;

import com.chang.yebserver.pojo.Menu;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
public interface MenuService extends IService<Menu> {

    /**
     * 通过用户id获取菜单列表
     * @return
     */
    List<Menu> getMenusByAdminId();

    /**
     * 通过角色获取菜单列表
     * @return
     */
    List<Menu> getAllMenusWithRole();

}
```

`com.chang.yebserver.service.impl.MenuServiceImpl`

```java
	/**
     * 通过角色获取菜单列表
     *
     * @return
     */
    @Override
    public List<Menu> getAllMenusWithRole() {
        return menuMapper.getAllMenusWithRole();
    }
```

#### 10.3.3、修改菜单持久层MenuMapper

> 增加通过角色获取菜单列表方法：getAllMenusWithRole()

```java
package com.chang.yebserver.mapper;

import com.chang.yebserver.pojo.Menu;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Repository
public interface MenuMapper extends BaseMapper<Menu> {

    /*
    根据用户ID查询菜单列表
     */
    List<Menu> getMenusByAdminId(Integer id);

    /**
     通过角色获取菜单列表
     */
    List<Menu> getAllMenusWithRole();
}
```

> 在MenuMapper.xml中继续补充

```xml
    <resultMap id="MenusWithRole" type="com.chang.yebserver.pojo.Menu" extends="BaseResultMap">
        <collection property="roles" ofType="com.chang.yebserver.pojo.Role">
            <id column="rid" property="id" />
            <result column="rname" property="name"/>
            <result column="rnameZh" property="nameZh"/>
        </collection>
    </resultMap>

    <select id="getAllMenusWithRole" resultMap="MenusWithRole">
        SELECT
            m.*,
            r.id AS rid,
            r.`name` AS rname,
            r.nameZh AS rnameZh
        FROM
            t_menu m,
            t_menu_role mr,
            t_role r
        WHERE
            m.id = mr.mid
          AND mr.rid = r.id
        ORDER BY
            m.id
    </select>
```

![image-20230119022057337](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119022057337.png)

#### 10.3.4、添加过滤器匹配所有角色

> 添加过滤器根据当前请求的Url，获取所有能够匹配的角色：
>
> - 在config包中创建Filter包，并在Filter包中创建CustomFilter，作为权限控制过滤器
>
> - 首先通过`((FilterInvocation) object).getRequestUrl()`获取当前请求的Url
> - 然后调用Service层中的`menuService.getAllMenusWithRole()`方法根据角色获取所有菜单
> - 遍历菜单，如果菜单中的Url与请求的Url能够匹配，则将对应的角色转换为数组形式传递给Security，**只有符合这些角色的登录用户才能够进行访问**
> - 没有匹配的url默认为登录即可访问："ROLE_LOGIN"

`com.chang.yebserver.config.Filter.CustomFilter`

```java
package com.chang.yebserver.config.Filter;

import com.chang.yebserver.pojo.Menu;
import com.chang.yebserver.pojo.Role;
import com.chang.yebserver.service.MenuService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.access.SecurityConfig;
import org.springframework.security.web.FilterInvocation;
import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import java.util.Collection;
import java.util.List;

/**
 * 权限控制过滤器
 * 根据请求url分析出请求所需角色
 */
@Component
public class CustomFilter implements FilterInvocationSecurityMetadataSource {

    @Autowired
    private MenuService menuService;

    AntPathMatcher antPathMatcher = new AntPathMatcher();

    @Override
    public Collection<ConfigAttribute> getAttributes(Object object) throws IllegalArgumentException {
        //获取请求的url
        String requestUrl = ((FilterInvocation) object).getRequestUrl();
        //获取菜单
        List<Menu> menus = menuService.getAllMenusWithRole();
        for (Menu menu : menus) {
            //判断请求url与菜单角色是否匹配
            if (antPathMatcher.match(menu.getUrl(),requestUrl)){
                String[] str = menu.getRoles().stream().map(Role::getName).toArray(String[]::new);
                return SecurityConfig.createList(str);
            }
        }
        //没匹配的url默认为登录即可访问
        return SecurityConfig.createList("ROLE_LOGIN");
    }
    @Override
    public Collection<ConfigAttribute> getAllConfigAttributes() {
        return null;
    }
    @Override
    public boolean supports(Class<?> clazz) {
        return true;
    }
}
```

### 10.4、判断用户的角色  

> 获取当前登录用户的角色

#### 10.4.1、修改管理员类 Admin

> 为Admin类添加Roles列表属性，并且对Security权限列表做一定修改

`com.chang.yebserver.pojo.Admin`

```java
package com.chang.yebserver.pojo;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

/**
 * <p>
 * 
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("t_admin")
@ApiModel(value="Admin对象", description="")
public class Admin implements Serializable, UserDetails {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "id")
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @ApiModelProperty(value = "姓名")
    private String name;

    @ApiModelProperty(value = "手机号码")
    private String phone;

    @ApiModelProperty(value = "住宅电话")
    private String telephone;

    @ApiModelProperty(value = "联系地址")
    private String address;

    @ApiModelProperty(value = "是否启用")
    private Boolean enabled;

    @ApiModelProperty(value = "用户名")
    private String username;

    @ApiModelProperty(value = "密码")
    private String password;

    @ApiModelProperty(value = "用户头像")
    private String userFace;

    @ApiModelProperty(value = "备注")
    private String remark;

    @ApiModelProperty(value = "权限")
    @TableField(exist = false)
    private List<Role> roles;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //权限列表
        List<SimpleGrantedAuthority> authorities =
                roles.stream()
                        .map(role -> new SimpleGrantedAuthority(role.getName()))
                        .collect(Collectors.toList());
        return authorities;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    //上方已经定义了enabled属性：“是否启用”
    @Override
    public boolean isEnabled() {
        return enabled;
    }
}
```

#### 10.4.2、修改用户查询层AdminService

> 为AdminService增加getRoles(Integer adminId)方法，通过用户id查询用户角色

`com.chang.yebserver.service.AdminService`：

```java
    /**
     * 根据用户id或者权限列表
     */
    List<Role> getRoles(Integer adminId);
```

`com.chang.yebserver.service.impl.AdminServiceImpl`

```java
	@Autowired
    private RoleMapper roleMapper;

	@Override
    public List<Role> getRoles(Integer adminId) {
        return roleMapper.getRoles(adminId);
    }
```

#### 10.4.3、修改角色持久层RoleMapper

> 增加方法getRoles(Integer adminId)，通过用户id查询用户角色

`com.chang.yebserver.mapper.RoleMapper`

```java
package com.chang.yebserver.mapper;

import com.chang.yebserver.pojo.Role;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Repository
public interface RoleMapper extends BaseMapper<Role> {
    /**
     * 根据用户id获取权限列表
     * @param adminId
     * @return
     */
    List<Role> getRoles(Integer adminId);
}
```

`RoleMapper.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.chang.yebserver.mapper.RoleMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.chang.yebserver.pojo.Role">
        <id column="id" property="id" />
        <result column="name" property="name" />
        <result column="nameZh" property="nameZh" />
    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
        id, name, nameZh
    </sql>

    <!--根据用户id获取权限列表-->
    <select id="getRoles" resultType="com.chang.yebserver.pojo.Role">
        SELECT
            r.id,
            r.`name`,
            r.nameZh
        FROM
            t_role AS r
                LEFT JOIN t_admin_role AS ar ON ar.rid = r.id
        WHERE
            ar.adminId = #{adminId}
    </select>

</mapper>
```

#### 10.4.4、修改LoginController与SecurityConfig

> **在获取用户信息和登录方法中添加该方法，获取用户信息时能得到角色列表**  

`com.chang.yebserver.controller.LoginController`

```java
	@ApiOperation(value = "获取当前登录用户的信息")
    @GetMapping("/admin/info")
    //登录成功后，用户信息被更新存放到security全文中，可以通过principal获取
    public Admin getAdminInfo(Principal principal){
        if(null==principal){
            return null;
        }
        String username = principal.getName();
        Admin admin = adminService.getAdminByUserName(username);
        //用户密码即使加密也不应该被返回，所以要设置为null
        admin.setPassword(null);
        admin.setRoles(adminService.getRoles(admin.getId()));
        return admin;
    }
```

`com.chang.yebserver.config.security.SecurityConfig`

```java
	/*
    重写UserDetailsService
     */
    @Override
    @Bean
    public UserDetailsService userDetailsService(){
        //获取登录用户信息
        return username -> {
            Admin admin = adminService.getAdminByUserName(username);
            if (null!=admin){
                admin.setRoles(adminService.getRoles(admin.getId()));
                return admin;
            }
            throw new UsernameNotFoundException("用户名或密码不正确！");
        };
    }
```

#### 10.4.5、添加过滤器判断用户的角色

`com.chang.yebserver.config.Filter.CustomUrlDecisionManager.`

```java
package com.chang.yebserver.config.Filter;

import org.springframework.security.access.AccessDecisionManager;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import java.util.Collection;
/**
 * 权限控制
 * 判断用户角色
 */

@Component
public class CustomUrlDecisionManager implements AccessDecisionManager  {

    @Override
    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {
        for (ConfigAttribute configAttribute : configAttributes) {
            //当前url所需角色
            String needRole = configAttribute.getAttribute();
            //判断角色是否为登录即可访问的角色，此角色在CustomFilter中设置
            if ("ROLE_LOGIN".equals(needRole)) {
                //判断是否登录
                if (authentication instanceof AnonymousAuthenticationToken) {
                    throw new AccessDeniedException("尚未登录，请登录！");
                } else {
                    return;
                }
            }
            //判断用户角色是否为url所需角色
            Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
            for (GrantedAuthority authority : authorities) {
                if (authority.getAuthority().equals(needRole)) {
                    return;
                }
            }
        }
        throw new AccessDeniedException("权限不足，请联系管理员！");
    }
    @Override
    public boolean supports(ConfigAttribute attribute) {
        return true;
    }
    @Override
    public boolean supports(Class<?> clazz) {
        return true;
    }
}
```

### 10.5、Security配置修改

> - 注入Filter中的两个过滤器，一个用来获取与url匹配的所有角色，一个用来判断用户的角色
> - 进行动态权限配置

``com.chang.yebserver.config.security.SecurityConfig``

```java
package com.chang.yebserver.config.security;

/*
Security配置类
 */

import com.chang.yebserver.config.Filter.CustomFilter;
import com.chang.yebserver.config.Filter.CustomUrlDecisionManager;
import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.service.AdminService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;
import org.springframework.security.config.annotation.ObjectPostProcessor;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.access.intercept.FilterSecurityInterceptor;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Lazy
    @Autowired
    private AdminService adminService;

    @Autowired
    private RestAuthorizationEntryPoint restAuthorizationEntryPoint;

    @Autowired
    private RestfulAccessDeniedHandler restfulAccessDeniedHandler;

    @Autowired
    private CustomFilter customFilter;

    @Autowired
    private CustomUrlDecisionManager customUrlDecisionManager;

    /*
    Security完整配置
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //使用JWT，不需要使用csrf
        http.csrf().disable()
                //基于token，不需要session
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                //除上面外，所有请求都要求认证
                .anyRequest()
                .authenticated()
                //动态权限配置
                .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
                    @Override
                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {
                        object.setAccessDecisionManager(customUrlDecisionManager);
                        object.setSecurityMetadataSource(customFilter);
                        return object;
                    }
                })
                .and()
                //禁用缓存
                .headers()
                .cacheControl();
        //添加jwt 登录授权过滤器
        http.addFilterBefore(jwtAuthenticationTokenFilter(),UsernamePasswordAuthenticationFilter.class);
        //添加自定义未授权和未登录结果返回
        http.exceptionHandling()
                .accessDeniedHandler(restfulAccessDeniedHandler)
                .authenticationEntryPoint(restAuthorizationEntryPoint);
    }

    /*
    让Security走登录逻辑时使用我们的UserDetails自定义方法
    */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception{
        auth.userDetailsService(userDetailsService())
                .passwordEncoder(passwordEncoder());
    }

    /*
    重写UserDetailsService
     */
    @Override
    @Bean
    public UserDetailsService userDetailsService(){
        return username -> {
            Admin admin = adminService.getAdminByUserName(username);
            if (null!=admin){
                admin.setRoles(adminService.getRoles(admin.getId()));
                return admin;
            }
            throw new UsernameNotFoundException("用户名或密码不正确！");
        };
    }

    /*
    密码解析
     */
    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    /*
    jwt登录授权拦截器
     */
    @Bean
    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter() {
        return new JwtAuthenticationTokenFilter();
    }

    /*
    配置Security放行内容
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(
                "/login",
                "/logout",
                "/css/**",
                "/js/**",
                "index.html",
                "favicon.ico",
                "/doc.html",
                "/webjars/**",
                "/swagger-resources/**",
                "/v2/api-docs/**",
                "/captcha"
        );
    }
}
```

### 10.6、测试

`com.chang.yebserver.controller.HelloController`

```java
package com.chang.yebserver.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {
    @GetMapping("/hello")
    public String hello(){
        return "hello";
    }

    @GetMapping("/employee/basic/hello")
    public String hello2(){
        return "/employee/basic/hello";
    }
    @GetMapping("/employee/advanced/hello")
    public String hello3(){
        return "/employee/advanced/hello";
    }
}
```

> hello3在数据库中没有给admin配置相应角色权限，所以会提示“权限不足！”，其余正常访问

![image-20230119031654305](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119031654305.png)

## 11、MyBatisPlus职位管理（单表查询）

> - 针对职位管理的MyBatisPlus查询是单表查询，完全可以不用去写SQL语句完成，并且MyBatisPlus更为优秀的一点是，通过逆向工程生成项目后，**在Controller层注入service方法后，不需要去修改任何service方法以及mapper方法，即可完成单表的增删改查**
>
> - 职位管理应该放在系统管理里面，因此要注意其路由为："/system/basic/pos"，**至于调用何种方法通过不同请求去区分**，例如查询使用Get方法，增加使用Post方法，更新使用Put方法，删除使用Delete方法
>
> - 针对时间的字段可以自定义样式：
>
>   `@JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")`

### 11.1、定义Position中创建时间字段格式

`com.chang.yebserver.pojo.Position`

![image-20230119152344277](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119152344277.png)

```java
package com.chang.yebserver.pojo;

import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.time.LocalDateTime;
import java.io.Serializable;

import com.fasterxml.jackson.annotation.JsonFormat;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/**
 * <p>
 * 
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("t_position")
@ApiModel(value="Position对象", description="")
public class Position implements Serializable {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "id")
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @ApiModelProperty(value = "职位")
    private String name;

    @ApiModelProperty(value = "创建时间")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    private LocalDateTime createDate;

    @ApiModelProperty(value = "是否启用")
    private Boolean enabled;

}
```

### 11.2、在PositionController中实现单表增删改查

1. 查询方法（获取所有职位信息）：
   1. 接收路由为`@GetMapping("/")`
   2. 调用`positionService.list();`
   3. 其中可以增加QueryWrapper来指定查询的条件
2. 增加方法（添加职位信息）：
   1. 接收路由为`@PostMapping("/")`
   2. 调用`positionService.save(position);`
   3. position对象由前端传递过来，更具数据库中的表字段可知enabled字段默认为true，创建时间字段可由后端代码完成，Id字段配置了自增策略，所以只需要给定name（职称）字段内容
3. 更新方法（更新职位信息）：
   1. 接收方法为`@PutMapping("/")`
   2. 调用`positionService.updateById(position)`
   3. position对象由前端传递过来，需要指定Id字段以及要更新的name字段
4. 删除方法（删除职位信息）：
   1. 接收方法`@DeleteMapping("/{id}")`
   2. 调用`positionService.removeById(id)`
   3. 给定要删除position对象的id
5. 删除方法（批量删除职位信息）：
   1. 接收方法`@DeleteMapping("/")`
   2. 调用`positionService.removeByIds(Arrays.asList(ids))`
   3. 所用参数ids，前端以Integer[]数组形式传递过来，然后转为List列表形式

`com.chang.yebserver.controller.PositionController`

```java
package com.chang.yebserver.controller;

import com.chang.yebserver.pojo.Position;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.service.PositionService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/system/basic/pos")
public class PositionController {
    @Autowired
    private PositionService positionService;
    @ApiOperation(value = "获取所有职位信息")
    @GetMapping("/")
    public List<Position> getAllPositions() {
        return positionService.list();
    }
    @ApiOperation(value = "添加职位信息")
    @PostMapping("/")
    public RespBean addPosition(@RequestBody Position position) {
        position.setCreateDate(LocalDateTime.now());
        if (positionService.save(position)) {
            return RespBean.success("添加成功!");
        }
        return RespBean.error("添加失败!");
    }
    @ApiOperation(value = "更新职位信息")
    @PutMapping("/")
    public RespBean updatePosition(@RequestBody Position position) {
        if (positionService.updateById(position)) {
            return RespBean.success("更新成功!");
        }
        return RespBean.error("更新失败！");
    }

    @ApiOperation(value = "删除职位信息")
    @DeleteMapping("/{id}")
    public RespBean deletePosition(@PathVariable Integer id) {
        if (positionService.removeById(id)) {
            return RespBean.success("删除成功!");
        }
        return RespBean.error("删除失败!");
    }
    @ApiOperation(value = "批量删除职位信息")
    @DeleteMapping("/")
    public RespBean deletePositionByIds(Integer[] ids) {
        if (positionService.removeByIds(Arrays.asList(ids))) {
            return RespBean.success("删除成功!");
        }
        return RespBean.error("删除失败!");
    }
}
```

### 11.3、增删改查测试

#### 11.3.1、查询方法测试

> 其中不需要任何参数

![image-20230119154214937](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119154214937.png)

#### 11.3.2、增加方法测试

> 给定职位的name字段

![image-20230119154257289](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119154257289.png)

#### 11.3.3、更新方法测试

> 给定要更新对象的id以机name字段

![image-20230119154445325](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119154445325.png)

#### 11.3.4、删除方法测试

> 给定删除对象的id

![image-20230119154552238](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119154552238.png)

#### 11.3.5、批量删除方法测试

> 以数组的形式给定多个要删除对象的id

![image-20230119154720458](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119154720458.png)

## 12、全局异常处理  

我们知道，系统中异常包括：编译时异常和运行时异常 RuntimeException ，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。

在开发中，不管是dao层、service层还是controller层，都有可能抛出异常，在Springmvc中，能将所有类型的异常处理从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。

SpringBoot全局异常处理方式主要两种：

- 使用 @ControllerAdvice 和 @ExceptionHandler 注解。
- 使用 ErrorController类 来实现

区别：

1. @ControllerAdvice 方式只能处理控制器抛出的异常。此时请求已经进入控制器中。

2. ErrorController类 方式可以处理所有的异常，包括未进入控制器的错误，比如404,401等错误

3. 如果应用中两者共同存在，则 @ControllerAdvice 方式处理控制器抛出的异常，ErrorController类方式处理未进入控制器的异常。

4. @ControllerAdvice 方式可以定义多个拦截方法，拦截不同的异常类，并且可以获取抛出的异常信息，自由度更大。  

> 新建一个exception包用来存放异常类

`com.chang.yebserver.exception.GlobalExceptionHandler`

```java
package com.chang.yebserver.exception;

import com.chang.yebserver.respPojo.RespBean;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import java.sql.SQLException;
import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常
 */

//@ControllerAdvice ：表示这是一个控制器增强类，当控制器发生异常且符合类中定义的拦截异常类，将会被拦截
//@ExceptionHandler ：定义拦截的异常类
//使用instanceof来确定异常具体是哪一类

@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(SQLException.class)
    public RespBean mySQLException(SQLException e) {
        if (e instanceof SQLIntegrityConstraintViolationException) {
            return RespBean.error("该数据有关联数据，操作失败！");
        }
        return RespBean.error("数据库异常，操作失败！");
    }
}
```

![image-20230119155859330](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119155859330.png)

## 13、职称管理(单表查询)

> 具体编写过程与`11、MyBatisPlus职位管理(单表查询)`相一致
>
> - 首先在JobLevel对象中为创建时间字段增加注解
>
>   `@JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")`
>
> - 针对JoblevelController编写增删改查方法

`com.chang.yebserver.controller.JoblevelController`：

```java
package com.chang.yebserver.controller;


import com.chang.yebserver.pojo.Joblevel;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.service.JoblevelService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/system/basic/joblevel")
public class JoblevelController {

    @Autowired
    private JoblevelService joblevelService;

    @ApiOperation(value = "获取所有职称")
    @GetMapping("/")
    public List<Joblevel> getAllJobLevels(){
        return joblevelService.list();
    }

    @ApiOperation(value = "添加职称")
    @PostMapping("/")
    public RespBean addJobLevel(@RequestBody Joblevel joblevel){
        joblevel.setCreateDate(LocalDateTime.now());
        if(joblevelService.save(joblevel)){
            return RespBean.success("添加成功！");
        }
        return RespBean.error("添加失败！");
    }

    @ApiOperation(value = "更新职称")
    @PutMapping("/")
    public RespBean updateJobLevel(@RequestBody Joblevel joblevel){
        if(joblevelService.updateById(joblevel)){
            return RespBean.success("更新成功！");
        }
        return RespBean.error("更新失败！");
    }

    @ApiOperation(value = "删除职称")
    @DeleteMapping("/{id}")
    public RespBean deleteJobLevel(@PathVariable Integer id){
        if(joblevelService.removeById(id)){
            return RespBean.success("删除成功！");
        }
        return RespBean.error("删除失败！");
    }

    @ApiOperation(value = "批量删除")
    @DeleteMapping("/")
    public RespBean deleteJobLevels(Integer[] ids){
        if(joblevelService.removeByIds(Arrays.asList(ids))){
            return RespBean.success("批量删除成功！");
        }
        return RespBean.error("批量删除失败！");
    }

}
```

## 14、权限组功能实现

### 14.1、角色管理(单表查询)

`com.chang.yebserver.controller.RoleController`：

```java
package com.chang.yebserver.controller;

import com.chang.yebserver.pojo.Role;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.service.RoleService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/system/basic/permission")
public class RoleController {
    @Autowired
    private RoleService roleService;

    @ApiOperation(value = "获取所有角色")
    @GetMapping("/")
    public List<Role> getAllRoles(){
        return roleService.list();
    }

    @ApiOperation(value = "添加角色")
    @PostMapping("/role")
    public RespBean addRole(@RequestBody Role role){
        if(!role.getName().startsWith("ROLE_")){
            role.setName("ROLE_"+role.getName());
        }
        if(roleService.save(role)){
            return RespBean.success("添加成功！");
        }
        return RespBean.error("添加失败！");
    }

    @ApiOperation(value = "删除角色")
    @DeleteMapping("/role/{rid}")
    public RespBean deleteRole(@PathVariable Integer rid){
        if(roleService.removeById(rid)){
            return RespBean.success("删除成功！");
        }
        return RespBean.error("删除失败！");
    }
}
```

### 14.2、菜单查询功能实现（xml中穷尽级别关系）

> - 查询Menu，实体类Menu有不属于数据库表字段的子菜单，所以不能使用MyBatisPlus的list方法，而是需要使用SQL语句查询
> - 查询包含子菜单的所有菜单，其中共有着3级菜单：`getAllMenus()`
> - 根据角色id查询菜单id：`getMidByRid(@PathVariable Integer rid)`

在`com.chang.yebserver.controller.RoleController`中继续添加：

```java
	@Autowired
    private MenuService menuService;

    @Autowired
    private MenuRoleService menuRoleService;
```

```java
	@ApiOperation(value = "查询所有菜单")
    @GetMapping("/menus")
    public List<Menu> getAllMenus(){
        return menuService.getAllMenus();
    }

    @ApiOperation(value = "根据角色id查询菜单id")
    @GetMapping("/mid/{rid}")
	//使用QueryWrapper设定查询条件为rid，此时查询出来的对象类型是List<MenuRole>，然后需要使用stream()将其转换为List<Integer>类型
    public List<Integer> getMidByRid(@PathVariable Integer rid){
        return menuRoleService.list(new QueryWrapper<MenuRole>().eq("rid",rid)).stream().map(MenuRole::getMid).collect(Collectors.toList());
    }
```

在`com.chang.yebserver.service.MenuService`中增加接口：

```java
	/**
     * 查询所有菜单
     * @return
     */
    List<Menu> getAllMenus();
```

在`com.chang.yebserver.service.impl.MenuServiceImpl`实现接口：

```java
	/**
     * 查询所有菜单
     * @return
     */
    @Override
    public List<Menu> getAllMenus() {
        return menuMapper.getAllMenus();
    }
```

在`com.chang.yebserver.mapper.MenuMapper`中指定连表查询的方法：

```java
	/**
     * 查询所有菜单
     * @return
     */
    List<Menu> getAllMenus();
```

在`MenuMapper`中添加连表查询的sql语句：

```xml
	<resultMap id="MenusWithChildren" type="com.chang.yebserver.pojo.Menu" extends="BaseResultMap">
        <id column="id1" property="id" />
        <result column="name1" property="name" />
        <collection property="children" ofType="com.chang.yebserver.pojo.Menu">
            <id column="id2" property="id" />
            <result column="name2" property="name" />
            <collection property="children" ofType="com.chang.yebserver.pojo.Menu">
                <id column="id3" property="id" />
                <result column="name3" property="name" />
            </collection>
        </collection>
    </resultMap>

    <!--查询所有菜单-->
    <select id="getAllMenus" resultMap="MenusWithChildren">
        SELECT
            m1.id AS id1,
            m1.`name` AS name1,
            m2.id AS id2,
            m2.`name` AS name2,
            m3.id AS id3,
            m3.`name` AS name3
        FROM
            t_menu m1,
            t_menu m2,
            t_menu m3
        WHERE
            m1.id = m2.parentId
          AND
            m2.id = m3.parentId
          AND
            m3.enabled = TRUE
    </select>
```

![image-20230119180355384](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119180355384.png)

![image-20230119180449939](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119180449939.png)

![image-20230119180513805](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119180513805.png)

### 14.3、角色菜单关系更新功能实现

> - 一个角色可以关联多个菜单
> - 在更新角色菜单关系时，可以先清空当前角色下的所有菜单，然后进行批量增加

在`com.chang.yebserver.controller.RoleController`中继续添加：

```java
 	/**
     * @param rid：角色id
     * @param mids：菜单数组
     * @return
     */
    @ApiOperation(value = "更新角色菜单")
    @PutMapping("/")
    public RespBean updateMenuRole(Integer rid,Integer[] mids){
        return menuRoleService.updateMenuRole(rid,mids);
    }
```

在`com.chang.yebserver.service.MenuRoleService`中增加更新接口：

```java
package com.chang.yebserver.service;

import com.chang.yebserver.pojo.MenuRole;
import com.baomidou.mybatisplus.extension.service.IService;
import com.chang.yebserver.respPojo.RespBean;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
public interface MenuRoleService extends IService<MenuRole> {

    /**
     * 更新角色菜单
     * @param rid
     * @param mids
     * @return
     */
    RespBean updateMenuRole(Integer rid, Integer[] mids);
}
```

在`com.chang.yebserver.service.impl.MenuRoleServiceImpl`中实现接口：

```java
package com.chang.yebserver.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.chang.yebserver.pojo.MenuRole;
import com.chang.yebserver.mapper.MenuRoleMapper;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.service.MenuRoleService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Service
public class MenuRoleServiceImpl extends ServiceImpl<MenuRoleMapper, MenuRole> implements MenuRoleService {

    @Autowired
    private MenuRoleMapper menuRoleMapper;
    /**
     * 更新角色菜单
     *  1、先删除rid下的所有菜单mid
     *  2、然后再设置所有mid
     *  因为涉及到删除最好加上事务注解@Transactional
     */
    @Override
    @Transactional
    public RespBean updateMenuRole(Integer rid, Integer[] mids) {
        menuRoleMapper.delete(new QueryWrapper<MenuRole>().eq("rid",rid));
        if(null == mids || 0==mids.length){
            return RespBean.success("更新成功！");
        }
        //如果mids中有值，那么就需要批量更新
        Integer result = menuRoleMapper.insertRecord(rid, mids);
        if(result == mids.length){
            //通过长度判断是否更新完毕
            return RespBean.success("更新成功！");
        }
        return RespBean.error("更新失败！");
    }

}
```

在`com.chang.yebserver.mapper.MenuRoleMapper`增加批量更新方法：

```java
package com.chang.yebserver.mapper;

import com.chang.yebserver.pojo.MenuRole;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import io.lettuce.core.dynamic.annotation.Param;
import org.springframework.stereotype.Repository;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Repository
public interface MenuRoleMapper extends BaseMapper<MenuRole> {

    /**
     * 批量更新角色菜单
     * @param rid
     * @param mids
     */
    Integer insertRecord(@Param("rid") Integer rid, @Param("mids") Integer[] mids);
}
```

在`MenuRoleMapper`中实现批量更新：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.chang.yebserver.mapper.MenuRoleMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.chang.yebserver.pojo.MenuRole">
        <id column="id" property="id" />
        <result column="mid" property="mid" />
        <result column="rid" property="rid" />
    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
        id, mid, rid
    </sql>

    <!--批量更新角色菜单-->
    <insert id="insertRecord">
        insert into t_menu_role(mid,rid) values
        <foreach collection="mids" item="mid" separator=",">
            (#{mid},#{rid})
        </foreach>
    </insert>

</mapper>
```

## 15、存储过程

MySQL5.0版本量始支持存储过程。

存储过程(Stored Procedure) 是一种在数据库中存储复杂程序， 以便外部程序调用的一种数据库对象。

存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给
定参数（ 需要时）来调用执行。

存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。

**通俗来讲： 存储过程具实就是能完成一定操作的一组SQL语句**

**优点**

- 存储过程可封装，并隐藏复杂的商业逻辑。
- 存储过程可以回传值，并可以接受参数。
- 存储过程无法使用SELECT指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。
- 存储过程可以用在数据检验，强制实行商业逻辑等。

**缺点**

- 存储过程，往往定制化于特定的数据库上，因为支持的编程言不同。当切换到具他厂商的数据库系统时，需要重写原有的存储过程。
-  存储过程的性能调校与撰写， 受限于各种数据库系统。

### 15.1、存储过程的创建和调用

- 存储过程就是具有名字的一段代码， 用来完成一个特定的功能。
-  创建的存储过程保存在数据库的数据字典中。

#### 15.1.1、创建存储过程

```mysql
CREATE
	[DEFAULT = { user | CURRENT_USER}]
  PROCEDURE sp_name ([proc_parameter[,...]])
  	[characteristic ...] routine_body
  	
proc_parameter:
	[ IN | OUT | INOUT ] param_name type
	
characteristic:
	COMMENT 'string'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
  
routine_body:
	valid SQL routine statement
	
[begin_label:] BEGIN
	[statement_list]
		...
END [end_label]
```

**MySQL存储过程中的关键语法（在BEGIN与END里面）**

声明语句结束符，可以自定义：

```mysql
DELIMITER $$
或（mysql8.0之前用上面的，之后用下面的）
DELIMITER //
```

声明存储过程：

```mysql
CREATE PROCEDURE demo_in_parameter(IN p_in int)
```

存储过程开始和结束符号：

```mysql
BEGIN...END
```

变量赋值：

```mysql
SET @p_in=1
```

变量定义：

```mysql
DECLARE l_int int unsigned default 4000000;
```

创建mysql存储过程、存储函数：

```mysql
create procedure 存储过程名（参数）
```

存储过程体：

```mysql
create function 存储函数名（参数）
```

### 15.1.2、调用存储过程

```mysql
call sp_name[(传参)];
```

### 15.2、存储过程的参数

MySQL存储过程的参数用在存储过程的定义，共有三种参数类型：IN、OUT、INOUT，形式如下：

```mysql
CREATE PROCEDURE 存储过程名([[ IN | OUT | INOUT ] 参数名 数据类型...])
```

- IN输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）
- OUT输出参数：表示过程向调用者传出值（可以返回多个值）（传出值只能是变量）
- INOUT输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）

**注意：**

1. 如果过程没有参数，也必须在过程名后面写上小括号，例：

   ```mysql
   CREATE PROCEDURE sp_name ([proc_parameter[,...]]) ...
   ```

2. 确保参数的名字不等于列的名字，否则在过程体中，参数名被当作列名来处理

**建议：**

- 输入值使用in参数
- 输出值使用out参数
- inout参数就尽量少用

### 15.3、变量

#### 15.3.1、变量定义

局部变量声明一定要放在存储过程体的开始：

```mysql
DECLARE variable_name [,variable_name...] datatype [DEFAULT value];
```

其中，datatype为MySQL的数据类型，如：int、float、date、varchar(length)

#### 15.3.2、变量赋值

```mysql
SET 变量名 = 表达式 [,variable_name = expression ...]
```

#### 15.3.3、用户变量

**在存储过程中使用用户变量**

> 创建一个名为GreetWorld()的存储过程，其中包含一个拼接字符串的SELECT查询，只不过省略了BEGIN与END

```mysql
CREATE PROCEDURE GreetWorld() SELECT CONCAT(@gretting,'world');

SET @gretting = 'Hello';

CALL GreetWorld()
```

![image-20230119213759978](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119213759978.png)

**在存储过程间传递全局范围的用户变量**

```mysql
CREATE PROCEDURE p1() SET @last_procedure = 'p1';

CREATE PROCEDURE p2() SELECT CONCAT('Last procedure was ',@last_procedure);

CALL p1();

CALL p2();
```

![image-20230119214557725](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119214557725.png)

### 15.4、针对部门管理的存储过程

![image-20230119224749716](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230119224749716.png)

#### 15.4.1、添加部门的存储过程

`addDep`

```mysql
CREATE DEFINER=`root`@`localhost` PROCEDURE `addDep`(in depName varchar(32),in parentId int,in enabled boolean,out result int,out result2 int)
begin
	/*
		添加部门（t_department）的输入变量：
			depName：新加入的部门名称
			parentId：父部门的Id，放在哪个父部门下面
			enabled：是否启用
		添加部门（t_department）的输出变量：
			result：添加过程中受影响的行数，正常来说应该只有1条
			result2：最后一次获取的id，也就是插入信息的id
	*/
	-- 定义存放插入信息id的变量：did
  declare did int;	
	-- 定义存放父部门depPath的变量：pDepPath
  declare pDepPath varchar(64);
	-- 更具输入参数，向t_department中插入新增一条数据
  insert into t_department set name=depName,parentId=parentId,enabled=enabled;
  -- 获取插入信息过程中受影响的行数，正常情况为1条
	select row_count() into result;
	-- 获取插入信息的id数
  select last_insert_id() into did;
	-- 将插入信息的id数作为返回值
  set result2=did;
	-- 根据父id获取父depPath
  select depPath into pDepPath from t_department where id=parentId;
	-- 根据did，使用concat方法拼接，更新当前的depPath
  update t_department set depPath=concat(pDepPath,'.',did) where id=did;
	-- 根据父id，设置该行数据是“父亲”
  update t_department set isParent=true where id=parentId;
end
```

#### 15.4.2、删除部门的存储过程

`deleteDep`

```mysql
CREATE DEFINER=`root`@`localhost` PROCEDURE `deleteDep`(in did int,out result int)
begin
	/*
		删除部门（t_department）的输入变量：
			did：要删除部门的id
		删除部门（t_department）的输出变量：
			result：
				-2:要么不存在输入id，要么该条数据还有子部门
				-1:该部门下员工数量不为0，还有下属员工
				1:受影响行数
	*/
  declare ecount int;
  declare pid int;
  declare pcount int;
  declare a int;
	
	-- 查询id等于输入变量did，并且不是“父亲”的总条数，将数量设置到a中
  select count(*) into a from t_department where id=did and isParent=false;
	-- 要么不存在输入id，要么该条数据还有子部门，设置result=-2
  if a=0 then set result=-2;
	else
		-- 能够从t_department中正常查询到，然后去t_employee查询该部门中是否还有员工，将数量设置到ecount中
		select count(*) into ecount from t_employee where departmentId=did;
		-- 如果查询员工的数量大于0，设置result=-1
		if ecount>0 then set result=-1;
		else 
			-- 根据输入did，查询该部门的父id，设置到pid中
			select parentId into pid from t_department where id=did;
			-- 根据输入did，删除该部门信息
			delete from t_department where id=did and isParent=false;
			-- 将受影响的行数放到result中
			select row_count() into result;
			-- 使用父id查询行数有哪些，设置到pcount中
			select count(*) into pcount from t_department where parentId=pid;
			-- 如果没有，将父id对应部门的isParent字段设置为false
			if pcount=0 then update t_department set isParent=false where id=pid;
			end if;
		end if;
  end if;
end
```

### 15.5、获取所有部门（xml中进行SQL递归）

> - 首先在Department实体类中增加children与result两个字段，children表示子部门列表，result表示存储过程使用的返回结果
> - 由于Department实体类中有子列表，所以不能使用departmentService中的方法，而需要去在mapper中编写SQL语句
> - **就本质而言，SQL的查询结果与14.2中菜单查询结果的形式是一致的，但不同点在于，14.2中菜单查询结果仅有3个级别嵌套，但部门查询结果中包含多个级别嵌套，如果在mapper的collection标签中穷尽所有部门是比较繁琐的，所以可以采用在collection标签中二次递归查询的操作**

在`com.chang.yebserver.pojo.Department`中新增如下内容：

```java
	@ApiModelProperty(value = "子部门列表")
    @TableField(exist = false)
    private List<Department> children;

    @ApiModelProperty(value = "返回结果，存储过程使用")
    @TableField(exist = false)
    private Integer result;
```

在`com.chang.yebserver.controller.DepartmentController`中更新为如下内容：

```java
package com.chang.yebserver.controller;


import com.chang.yebserver.pojo.Department;
import com.chang.yebserver.service.DepartmentService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/system/basic/department")
public class DepartmentController {

    @Autowired
    private DepartmentService departmentService;

    @ApiOperation(value = "获取所有部门")
    @GetMapping("/")
    public List<Department> getAllDepartment(){
        return departmentService.getAllDepartments();
    }
}
```

在`com.chang.yebserver.service.DepartmentService`中增加如下内容：

```java
	/**
     * 获取所有部门
     * @return
     */
    List<Department> getAllDepartments();
```

在`com.chang.yebserver.service.impl.DepartmentServiceImpl`中增加如下内容：

```java
	@Autowired
    private DepartmentMapper departmentMapper;

    /**
     * 获取所有部门
     * @return
     */
    @Override
    public List<Department> getAllDepartments() {
        //给定头部的id
        return departmentMapper.getAllDepartments(-1);
    }
```

在`com.chang.yebserver.mapper.DepartmentMapper`中增加如下内容：

```java
	/**
     * 获取所有部门
     * @return
     */
    List<Department> getAllDepartments(Integer parentId);
```

在`DepartmentMapper.xml`中编写SQL，对children进行递归查询，其参数是上一次的id值

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.chang.yebserver.mapper.DepartmentMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.chang.yebserver.pojo.Department">
        <id column="id" property="id" />
        <result column="name" property="name" />
        <result column="parentId" property="parentId" />
        <result column="depPath" property="depPath" />
        <result column="enabled" property="enabled" />
        <result column="isParent" property="isParent" />
    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
        id, name, parentId, depPath, enabled, isParent
    </sql>

    <resultMap id="DepartmentWithChildren" type="com.chang.yebserver.pojo.Department" extends="BaseResultMap">
        <collection property="children" ofType="com.chang.yebserver.pojo.Department" select="com.chang.yebserver.mapper.DepartmentMapper.getAllDepartments" column="id">
        </collection>
    </resultMap>

    <!--获取所有部门-->
    <select id="getAllDepartments" resultMap="DepartmentWithChildren">
        select
            <include refid="Base_Column_List"></include>
        from t_department
        where parentId = #{parentId}
    </select>

</mapper>
```

### 15.6、添加部门（调用存储过程）

> 使用15.4.1中定义的addDep存储过程进行部门添加，之所以这样做，是因为添加部门的sql实现起来比较繁琐

在`com.chang.yebserver.controller.DepartmentController`中增加如下内容：

```java
	@ApiOperation(value = "添加部门")
    @PostMapping("/")
    public RespBean addDep(@RequestBody Department dep){
        dep.setEnabled(true);
        return departmentService.addDep(dep);
    }
```

在`com.chang.yebserver.service.DepartmentService`中增加如下内容：

```java
 	/**
     * 添加部门
     * @param dep
     * @return
     */
    RespBean addDep(Department dep);
```

在`com.chang.yebserver.service.impl.DepartmentServiceImpl`中增加如下内容：

```java
	@Override
    public RespBean addDep(Department dep) {
        departmentMapper.addDep(dep);
        if(1==dep.getResult()){
            return RespBean.success("添加成功！",dep);
        }
        return RespBean.error("添加失败！");
    }
```

在`com.chang.yebserver.mapper.DepartmentMapper`中增加如下内容：

```java
	/**
     * 添加部门
     * @param dep
     */
    void addDep(Department dep);
```

在`DepartmentMapper.xml`中增加如下内容：

```xml
	<!--添加部门-->
    <select id="addDep" statementType="CALLABLE">
        call addDep(#{name,mode=IN,jdbcType=VARCHAR},#{parentId,mode=IN,jdbcType=INTEGER},#{enabled,mode=IN,jdbcType=BOOLEAN},#{result,mode=OUT,jdbcType=INTEGER},#{id,mode=OUT,jdbcType=INTEGER})
    </select>
```

![image-20230120001130608](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120001130608.png)

> 注意xml的#{}中参数内容，参照addDep存储过程中定义的输入变量与输出变量，按照addDep存储过程中的顺序编写，第一个是Department中的字段属性，第二个mode用来指定是输入还是输出类型，第三个jdbcType用来指定字段类型
>
> 在调用方法后，可以看到“运维测试部门”已经被成功加入，并且它的上级“运维部”的isParent字段也已经被修改为1

![image-20230120000800595](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120000800595.png)

![image-20230120000932538](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120000932538.png)

### 15.7、删除部门（调用存储过程）

> 使用15.4.2中定义的deleteDep存储过程进行部门删除，之所以这样做，是因为删除部门的sql实现起来比较繁琐

在`com.chang.yebserver.controller.DepartmentController`中增加如下内容：

```java
	@ApiOperation(value = "删除部门")
    @DeleteMapping("/{id}")
    public RespBean deleteDep(@PathVariable Integer id){
        return departmentService.deleteDep(id);
    }
```

在`com.chang.yebserver.service.DepartmentService`中增加如下内容：

```java
	/**
     * 删除部门
     * @param id
     * @return
     */
    RespBean deleteDep(Integer id);
```

在`com.chang.yebserver.service.impl.DepartmentServiceImpl`中增加如下内容：

```java
	/**
     * 删除部门
     * @param id
     * @return
     */
    @Override
    public RespBean deleteDep(Integer id) {
        Department dep = new Department();
        dep.setId(id);
        departmentMapper.deleteDep(dep);
        if(-2==dep.getResult()){
            return RespBean.error("该部门下还有子部门，删除失败！");
        }
        if (-1==dep.getResult()) {
            return RespBean.error("该部门下还有员工，删除失败！");
        }
        if(1==dep.getResult()){
            return RespBean.success("删除成功！");
        }
        return RespBean.error("删除失败！");
    }
```

在`com.chang.yebserver.mapper.DepartmentMapper`中增加如下内容：

```java
	/**
     * 删除部门
     * @param dep
     */
    void deleteDep(Department dep);
```

在`DepartmentMapper.xml`中增加如下内容：

```xml
	<!--删除部门-->
    <select id="deleteDep" statementType="CALLABLE">
        call deleteDep(#{id,mode=IN,jdbcType=INTEGER},#{result,mode=OUT,jdbcType=INTEGER})
    </select>
```

![image-20230120002355553](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120002355553.png)

> 进行测试：
>
> - 输入13，测试删除运维部，提示“该部门下还有子部门，删除失败！”
> - 输入12，测试删除技术部，提示“该部门下还有员工，删除失败！”
> - 输入149，测试删除运维测试部门，提示“删除成功！”

![image-20230120002636530](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120002636530.png)

![image-20230120002616051](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120002616051.png)

![image-20230120002732305](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120002732305.png)

![image-20230120002808459](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120002808459.png)

## 16、操作员功能实现

### 16.1、查询获取操作员

> - 在查询过程过程中需要t_admin、t_admin_role、t_role进行连表查询，所以不便使用adminService直接查询
> - 不能查询当前登录对象的信息，例如（管理员）
> - 支持模糊查询（like）
> - 创建AdminUtils作为操作员管理工具类，其中提供getCurrentAdmin()方法，用来获取当前的操作员

对于有两种查询方式：（本次实现使用左连接）

1. 隐式内连接
2. 左连接

`隐式内连接`：

```mysql
SELECT
a.*,
r.id as rid,
r.`name` as rname,
r.nameZh as rnameZh
FROM
t_admin a,
t_admin_role ar,
t_role r
WHERE
a.id = ar.adminId
AND
ar.rid = r.id
AND
a.id != 1
AND
a.`name` LIKE CONCAT("%","淑","%")
ORDER BY
a.id
```

`左连接`

```mysql
SELECT
a.*,
r.id as rid,
r.`name` as rname,
r.nameZh as rnameZh
FROM
t_admin a
LEFT JOIN
t_admin_role ar ON a.id = ar.adminId
LEFT JOIN
t_role r ON ar.rid = r.id
WHERE
a.id != 1
AND
a.`name` LIKE CONCAT("%","淑","%")
ORDER BY
a.id
```

在`com.chang.yebserver.utils.AdminUtils`中增加如下内容：

```java
package com.chang.yebserver.utils;

import com.chang.yebserver.pojo.Admin;
import org.springframework.security.core.context.SecurityContextHolder;

/**
 * 操作员工具类
 */
public class AdminUtils {

    /**
     * 获取当前登录的Admin
     * @return
     */
    public static Admin getCurrentAdmin(){
        return (Admin) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    }
}
```

在`com.chang.yebserver.controller.AdminController`中增加如下内容：（可以接收前端传递来的查询关键词）

```java
package com.chang.yebserver.controller;


import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.service.AdminService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/system/admin")
public class AdminController {

    @Autowired
    private AdminService adminService;

    @ApiOperation(value = "获取所有操作员")
    @GetMapping("/")
    public List<Admin> getAllAdmins(String keywords){
        return adminService.getAllAdmins(keywords);
    }
}
```

在`com.chang.yebserver.service.AdminService`中增加如下内容：

```java
	/**
     * 获取所有操作员
     * @param keywords
     * @return
     */
    List<Admin> getAllAdmins(String keywords);
```

在`com.chang.yebserver.service.impl.getAllAdmins`中增加如下内容：

```java
	/**
     * 获取所有操作员
     * @param keywords
     * @return
     */
    @Override
    public List<Admin> getAllAdmins(String keywords) {
        return adminMapper.getAllAdmins(AdminUtils.getCurrentAdmin().getId(),keywords);
    }
```

在`com.chang.yebserver.mapper.AdminMapper`中增加如下内容：

```java
	/**
     * 获取所有操作员
     * @param id
     * @param keywords
     * @return
     */
    List<Admin> getAllAdmins(@Param("id") Integer id, @Param("keywords") String keywords);
```

在`AdminMapper.xml`中增加如下内容：（注意：CONCAT中为单引号，并且对其进行if判断）

```xml
	<resultMap id="AdminWithRole" type="com.chang.yebserver.pojo.Admin" extends="BaseResultMap">
        <collection property="roles" ofType="com.chang.yebserver.pojo.Role">
            <id column="rid" property="id" />
            <result column="rname" property="name" />
            <result column="rnameZh" property="nameZh" />
        </collection>
    </resultMap>

    <!--获取所有操作员-->
    <select id="getAllAdmins" resultMap="AdminWithRole">
        SELECT
            a.*,
            r.id as rid,
            r.`name` as rname,
            r.nameZh as rnameZh
        FROM
            t_admin a
                LEFT JOIN
            t_admin_role ar ON a.id = ar.adminId
                LEFT JOIN
            t_role r ON ar.rid = r.id
        WHERE
            a.id != #{id}
            <if test="null!=keywords and ''!=keywords">
                AND a.`name` LIKE CONCAT('%',#{keywords},'%')
            </if>
        ORDER BY
            a.id
    </select>
```

![image-20230120012755078](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120012755078.png)

### 16.2、更新操作员

> 对于Admin类来说enabled，既继承了UserDetails又有了lombock注解，在更新操作时，二者会重复，所以要在enabled字段上添加注解`@Getter(AccessLevel.NONE)`

在`com.chang.yebserver.controller.AdminController`中增加如下内容：

```java
	@ApiOperation(value = "更新操作员")
    @PutMapping("/")
    public RespBean updateAdmin(@RequestBody Admin admin){
        if(adminService.updateById(admin)){
            return RespBean.success("更新成功！");
        }
        return RespBean.error("更新失败！");
    }
```

测试数据：

```json
{
	"id": 2,
    "name": "何淑芬",
    "phone": "18875971675",
    "telephone": "41413109",
    "address": "河北省秀荣市萧山长沙街p座 737268",
    "enabled": false,
    "username": "taomeng",
    "userFace": "https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1585830947922&di=60b35821fb9112d0aad6915efe982c8d&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201703%2F26%2F20170326161532_aGteC.jpeg",
    "remark": null,
    "roles": [
      {
        "id": 3,
        "name": "ROLE_recruiter",
        "nameZh": "招聘主管"
      },
      {
        "id": 4,
        "name": "ROLE_train",
        "nameZh": "培训主管"
      }
    ]
}
```

![image-20230120020532808](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120020532808.png)

### 16.3、删除操作员

在`com.chang.yebserver.controller.AdminController`中增加如下内容：

```java
 	@ApiOperation(value = "删除操作员")
    @DeleteMapping("/{id}")
    public RespBean deleteAdmin(@PathVariable Integer id){
        if(adminService.removeById(id)){
            return RespBean.success("删除成功！");
        }
        return RespBean.error("删除失败！");
    }
```

### 16.4、获取所有角色

在`com.chang.yebserver.controller.AdminController`中增加如下内容：

```java
	@ApiOperation(value = "获取所有角色")
    @GetMapping("/roles")
    public List<Role> getAllRoles(){
        return roleService.list();
    }
```

### 16.5、更新操作员角色

> 与之前操作相同，均是先删除所有角色，再统一添加

在`com.chang.yebserver.controller.AdminController`中增加如下内容：

```java
	@ApiOperation(value = "更新操作员角色")
    @PutMapping("/role")
    public RespBean updateAdminRole(Integer adminId,Integer[] rids){
        return adminService.updateAdminRole(adminId,rids);
    }
```

在`com.chang.yebserver.service.AdminService`中增加如下内容：

```java
	/**
     * 更新操作员角色
     * @param adminId
     * @param rids
     * @return
     */
    RespBean updateAdminRole(Integer adminId, Integer[] rids);
```

在`com.chang.yebserver.service.impl.getAllAdmins`中增加如下内容：

```java
	@Autowired
    private AdminRoleMapper adminRoleMapper;
```

```java
	/**
     * 更新操作员角色
     * @param adminId
     * @param rids
     * @return
     */
    @Override
    @Transactional
    public RespBean updateAdminRole(Integer adminId, Integer[] rids) {
        adminRoleMapper.delete(new QueryWrapper<AdminRole>().eq("adminId",adminId));
        Integer result = adminRoleMapper.addAdminRole(adminId,rids);
        if(rids.length==result){
            return RespBean.success("更新成功！");
        }
        return RespBean.error("更新失败！");
    }
```

在`com.chang.yebserver.mapper.AdminRoleMapper`中增加如下内容：

```java
	/**
     * 更新操作员角色
     * @param adminId
     * @param rids
     * @return
     */
    Integer addAdminRole(@Param("adminId") Integer adminId, @Param("rids") Integer[] rids);
```

在`AdminRoleMapper.xml`中增加如下内容：

```xml
	<!--更新操作员角色-->
    <update id="addAdminRole">
        insert into t_admin_role(adminId,rid) values
        <foreach collection="rids" item="rid" separator=",">
            (#{adminId},#{rid})
        </foreach>
    </update>
```

## 17、员工功能实现（分页插件）

### 17.1、员工表t_employee

> 其中：
>
> - 民族nationId是一个int类型的id，可以在t_nation中查找到具体的值
> - 政治面貌politicId是一个int类型的id，可以在t_politics_status中查找到具体的值
> - ......

![image-20230120023447031](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120023447031.png)

### 17.2、员工功能实现准备工作

#### 17.2.1、配置分页插件

在`config`目录下新建`MyBatisPlusConfig`类

`com.chang.yebserver.config.MyBatisPlusConfig`：

```java
package com.chang.yebserver.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * MyBaitsPlus分页插件配置
 */
@Configuration
public class MyBatisPlusConfig {

    //mybatisplus中也提供了一个分页插件PaginationInnerInterceptor，其实分页的本质就是内部封装了一个拦截器，对于满足条件的数据进行过滤处理。
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        //添加分页插件
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
```

#### 17.2.2、配置分页公共返回对象

`com.chang.yebserver.respPojo.RespPageBean`：

```java
package com.chang.yebserver.respPojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * 分页公共返回对象
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RespPageBean {
    /**
     * 总条数
     */
    private Long total;

    /**
     * 数据List
     */
    private List<?> data;
}
```

#### 17.2.3、设置全局日期转换工具

> 将前端传递来的时间进行一定的格式转换

在`yebserver`中新建`converter`文件夹

`com.chang.yebserver.converter.DateConverter`

```java
package com.chang.yebserver.converter;

import org.springframework.core.convert.converter.Converter;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

/**
 * 全局日期转换
 */

@Component
public class DateConverter implements Converter<String, LocalDate> {

    @Override
    public LocalDate convert(String source) {
        try {
            return LocalDate.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }
}
```

#### 17.2.4、Employee类注解信息完善

> - 首先为所有时间字段加上注解：`@JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")`，作用是传递给前端时格式是确定规范的
> - 为所有通过id连接的字段在类中增加属性：Nation、PoliticsStatus、Department、Joblevel、Position

`com.chang.yebserver.pojo.Employee`：

```java
package com.chang.yebserver.pojo;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import java.time.LocalDate;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;

import com.fasterxml.jackson.annotation.JsonFormat;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/**
 * <p>
 * 
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("t_employee")
@ApiModel(value="Employee对象", description="")
public class Employee implements Serializable {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "员工编号")
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @ApiModelProperty(value = "员工姓名")
    private String name;

    @ApiModelProperty(value = "性别")
    private String gender;

    @ApiModelProperty(value = "出生日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    private LocalDate birthday;

    @ApiModelProperty(value = "身份证号")
    private String idCard;

    @ApiModelProperty(value = "婚姻状况")
    private String wedlock;

    @ApiModelProperty(value = "民族")
    private Integer nationId;

    @ApiModelProperty(value = "籍贯")
    private String nativePlace;

    @ApiModelProperty(value = "政治面貌")
    private Integer politicId;

    @ApiModelProperty(value = "邮箱")
    private String email;

    @ApiModelProperty(value = "电话号码")
    private String phone;

    @ApiModelProperty(value = "联系地址")
    private String address;

    @ApiModelProperty(value = "所属部门")
    private Integer departmentId;

    @ApiModelProperty(value = "职称ID")
    private Integer jobLevelId;

    @ApiModelProperty(value = "职位ID")
    private Integer posId;

    @ApiModelProperty(value = "聘用形式")
    private String engageForm;

    @ApiModelProperty(value = "最高学历")
    private String tiptopDegree;

    @ApiModelProperty(value = "所属专业")
    private String specialty;

    @ApiModelProperty(value = "毕业院校")
    private String school;

    @ApiModelProperty(value = "入职日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    private LocalDate beginDate;

    @ApiModelProperty(value = "在职状态")
    private String workState;

    @ApiModelProperty(value = "工号")
    private String workID;

    @ApiModelProperty(value = "合同期限")
    private Double contractTerm;

    @ApiModelProperty(value = "转正日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    private LocalDate conversionTime;

    @ApiModelProperty(value = "离职日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    private LocalDate notWorkDate;

    @ApiModelProperty(value = "合同起始日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    private LocalDate beginContract;

    @ApiModelProperty(value = "合同终止日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    private LocalDate endContract;

    @ApiModelProperty(value = "工龄")
    private Integer workAge;

    @ApiModelProperty(value = "工资账套ID")
    private Integer salaryId;

    @ApiModelProperty(value = "民族")
    @TableField(exist = false)
    private Nation nation;

    @ApiModelProperty(value = "政治面貌")
    @TableField(exist = false)
    private PoliticsStatus politicsStatus;

    @ApiModelProperty(value = "部门")
    @TableField(exist = false)
    private Department department;

    @ApiModelProperty(value = "职称")
    @TableField(exist = false)
    private Joblevel joblevel;

    @ApiModelProperty(value = "职位")
    @TableField(exist = false)
    private Position position;

}
```

#### 17.2.5、员工信息分页查询（IPage）

> 分页查询的结果类型为IPage

在`com.chang.yebserver.controller.EmployeeController`中加入如下内容：

```java
package com.chang.yebserver.controller;


import com.chang.yebserver.pojo.Employee;
import com.chang.yebserver.respPojo.RespPageBean;
import com.chang.yebserver.service.EmployeeService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/employee/basic")
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    @ApiOperation(value = "获取所有员工（分页）")
    @GetMapping("/")
    public RespPageBean getEmployee(@RequestParam(defaultValue = "1") Integer currentPage,
                                    @RequestParam(defaultValue = "10") Integer size,
                                    Employee employee,
                                    LocalDate[] beginDateScope){
        return employeeService.getEmployeeByPage(currentPage,size,employee,beginDateScope);
    }

}
```

在`com.chang.yebserver.service.EmployeeService`中增加如下内容：

```java
package com.chang.yebserver.service;

import com.chang.yebserver.pojo.Employee;
import com.baomidou.mybatisplus.extension.service.IService;
import com.chang.yebserver.respPojo.RespPageBean;

import java.time.LocalDate;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
public interface EmployeeService extends IService<Employee> {

    /**
     * 获取所有员工（分页）
     * @param currentPage
     * @param size
     * @param employee
     * @param beginDateScope
     * @return
     */
    RespPageBean getEmployeeByPage(Integer currentPage, Integer size, Employee employee, LocalDate[] beginDateScope);
}

```

在`com.chang.yebserver.service.impl.EmployeeServiceImpl`中增加如下内容：

```java
package com.chang.yebserver.service.impl;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.chang.yebserver.pojo.Employee;
import com.chang.yebserver.mapper.EmployeeMapper;
import com.chang.yebserver.respPojo.RespPageBean;
import com.chang.yebserver.service.EmployeeService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Service
public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee> implements EmployeeService{

    @Autowired
    private EmployeeMapper employeeMapper;
    /**
     * 获取所有员工（分页）
     * @param currentPage
     * @param size
     * @param employee
     * @param beginDateScope
     * @return
     */
    @Override
    public RespPageBean getEmployeeByPage(Integer currentPage, Integer size, Employee employee, LocalDate[] beginDateScope) {
        //开启分页
        Page<Employee> page = new Page<>(currentPage, size);
        //开始查询
        IPage<Employee> employeeByPage = employeeMapper.getEmployeeByPage(page, employee, beginDateScope);
        RespPageBean respPageBean = new RespPageBean(employeeByPage.getTotal(), employeeByPage.getRecords());
        return respPageBean;
    }
}
```

在`com.chang.yebserver.mapper.EmployeeMapper`中增加如下内容：

```java
package com.chang.yebserver.mapper;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.chang.yebserver.pojo.Employee;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import io.lettuce.core.dynamic.annotation.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Repository
public interface EmployeeMapper extends BaseMapper<Employee> {

    /**
     * 获取所有员工（分页）
     * @param page
     * @param employee
     * @param beginDataScope
     * @return
     */
    IPage<Employee> getEmployeeByPage(Page<Employee> page, @Param("employee") Employee employee, @Param("beginDateScope") LocalDate[] beginDateScope);
}
```

在`EmployeeMapper.xml`中增加如下内容：

```xml
	<resultMap id="EmployeeInfo" type="com.chang.yebserver.pojo.Employee" extends="BaseResultMap">
        <association property="nation" javaType="com.chang.yebserver.pojo.Nation">
            <id column="nid" property="id" />
            <result column="nname" property="name" />
        </association>
        <association property="politicsStatus" javaType="com.chang.yebserver.pojo.PoliticsStatus">
            <id column="pid" property="id" />
            <result column="pname" property="name" />
        </association>
        <association property="department" javaType="com.chang.yebserver.pojo.Department">
            <id column="did" property="id" />
            <result column="dname" property="name" />
        </association>
        <association property="joblevel" javaType="com.chang.yebserver.pojo.Joblevel">
            <id column="jid" property="id" />
            <result column="jname" property="name" />
        </association>
        <association property="position" javaType="com.chang.yebserver.pojo.Position">
            <id column="posid" property="id" />
            <result column="posname" property="name" />
        </association>

    </resultMap>

    <!--获取所有员工（分页）-->
    <select id="getEmployeeByPage" resultMap="EmployeeInfo">
        SELECT
            e.*,
            n.id AS nid,
            n.`name` as nname,
            p.id AS pid,
            p.`name` as pname,
            d.id AS did,
            d.`name` AS dname,
            j.id AS jid,
            j.`name` AS jname,
            pos.id AS posid,
            pos.`name` AS posname
        FROM
            t_employee e,
            t_nation n,
            t_politics_status p,
            t_department d,
            t_joblevel j,
            t_position pos
        WHERE
            e.nationId = n.id
          AND
            e.politicId = p.id
          AND
            e.departmentId = d.id
          AND
            e.jobLevelId = j.id
          AND
            e.posId = pos.id
            <if test="null!=employee.name and ''!=employee.name">
                AND e.`name` LIKE CONCAT('%',#{employee.name},'%')
            </if>
            <if test="null!=employee.politicId">
                AND e.politicId = #{employee.politicId}
            </if>
            <if test="null!=employee.nationId">
                AND e.nationId = #{employee.nationId}
            </if>
            <if test="null!=employee.jobLevelId">
                AND e.jobLevelId = #{employee.jobLevelId}
            </if>
            <if test="null!=employee.posId">
                AND e.posId = #{employee.posId}
            </if>
            <if test="null!=employee.engageForm and ''!=employee.engageForm">
                AND e.engageForm = #{employee.engageForm}
            </if>
            <if test="null!=employee.departmentId">
                AND e.departmentId = #{employee.departmentId}
            </if>
            <if test="null!=beginDateScope and 2==beginDateScope.length">
                AND e.beginDate BETWEEN #{beginDateScope[0]} AND #{beginDateScope[1]}
            </if>
        ORDER BY
            e.id
    </select>
```

![image-20230120142354048](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120142354048.png)

#### 17.2.6、添加员工功能实现

> 1. 首先提供：获取所有政治面貌、获取所有职称、获取所有民族、获取所有职位、获取所有部门、获取工号的接口方法
> 2. 获取所有部门的方法中由于存在多级子部门，不能直接使用mybatisplus中提供的方法获取，但在之前的代码中以及提供了方法：departmentService.getAllDepartments();
> 3. **获取工号，查询当前最大功号，然后在此基础上+1，然后将其转换为8位的字符串格式**
> 4. **添加员工操作，其中的合同期限需要做一定程度的处理修改，在service层中进行**

在`com.chang.yebserver.controller.EmployeeController`中增加如下内容：

```java
	@Autowired
    private PoliticsStatusService politicsStatusService;

    @Autowired
    private JoblevelService joblevelService;

    @Autowired
    private NationService nationService;

    @Autowired
    private PositionService positionService;

    @Autowired
    private DepartmentService departmentService;

	@ApiOperation(value = "获取所有政治面貌")
    @GetMapping("/politicsstatus")
    public List<PoliticsStatus> getAllPoliticsStatus(){
        return politicsStatusService.list();
    }

    @ApiOperation(value = "获取所有职称")
    @GetMapping("/joblevels")
    public List<Joblevel> getAllJoblevels(){
        return joblevelService.list();
    }

    @ApiOperation(value = "获取所有民族")
    @GetMapping("/nations")
    public List<Nation> getAllNations(){
        return nationService.list();
    }

    @ApiOperation(value = "获取所有职位")
    @GetMapping("/positions")
    public List<Position> getAllPositions(){
        return positionService.list();
    }

    @ApiOperation(value = "获取所有部门")
    @GetMapping("/deps")
    public List<Department> getAllDepartments(){
        return departmentService.getAllDepartments();
    }

    @ApiOperation(value = "获取工号")
    @GetMapping("/maxWorkID")
    public RespBean maxWorkID(){
        return employeeService.maxWorkID();
    }

    @ApiOperation(value = "添加员工")
    @PostMapping("/")
    public RespBean addEmp(@RequestBody Employee employee){
        return employeeService.addEmp(employee);
    }
```

在`com.chang.yebserver.service.EmployeeService`中增加如下内容：

```java
	/**
     * 获取工号
     * @return
     */
    RespBean maxWorkID();

    /**
     * 添加员工
     * @param employee
     * @return
     */
    RespBean addEmp(Employee employee);
```

在`com.chang.yebserver.service.impl.EmployeeServiceImpl`中增加如下内容：

```java
	/**
     * 获取工号
     * 当前最大工号+1
     * @return
     */
    @Override
    public RespBean maxWorkID() {
        List<Map<String, Object>> maps = employeeMapper.selectMaps(new QueryWrapper<Employee>().select("max(workID)"));
        return RespBean.success(null,String.format("%08d",Integer.parseInt(maps.get(0).get("max(workID)").toString())+1));
    }

    /**
     * 添加员工
     * @param employee
     * @return
     */
    @Override
    public RespBean addEmp(Employee employee) {
        //处理合同期限，二者做差获取所有天数，然后除以365并保留2位小数
        LocalDate beginContract = employee.getBeginContract();
        LocalDate endContract = employee.getEndContract();
        long days = beginContract.until(endContract, ChronoUnit.DAYS);
        DecimalFormat decimalFormat = new DecimalFormat("##.00");
        employee.setContractTerm(Double.parseDouble(decimalFormat.format(days/365.00)));
        if(1==employeeMapper.insert(employee)){
            return RespBean.success("添加成功！");
        }
        return RespBean.error("添加失败！");
    }
```

`添加员工测试内容`：（添加成功后可以看到其工号在之前最大功号00000100的基础上进行了+1）

```json
{
      "name": "张三",
      "gender": "女",
      "birthday": "1999-11-20",
      "idCard": "341502198810196427",
      "wedlock": "未婚",
      "nationId": 1,
      "nativePlace": "英市",
      "politicId": 11,
      "email": "xia53@gangjing.cn",
      "phone": "15567487644",
      "address": "贵州省洁市清城汕尾街d座 502246",
      "departmentId": 3,
      "jobLevelId": 5,
      "posId": 5,
      "engageForm": "劳动合同",
      "tiptopDegree": "博士",
      "specialty": "电子工程",
      "school": "中国科学技术大学",
      "beginDate": "2018-10-16",
      "workState": "在职",
      "workID": "00000101",
      "conversionTime": "2018-08-29",
      "notWorkDate": null,
      "beginContract": "2017-09-03",
      "endContract": "2019-08-26",
      "workAge": null,
      "salaryId": 4
}
```

![image-20230120152914253](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120152914253.png)

![image-20230120153008682](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120153008682.png)

#### 17.2.7、更新员工功能实现

在`com.chang.yebserver.controller.EmployeeController`中增加如下内容：

```java
	@ApiOperation(value = "更新员工")
    @PutMapping("/")
    public RespBean updateEmp(@RequestBody Employee employee){
        if(employeeService.updateById(employee)){
            return RespBean.success("更新成功！");
        }
        return RespBean.error("更新失败！");
    }
```

`更新员工测试内容`：（根据id进行更新）

```json
{
      "id": 418,
      "name": "张三123",
      "gender": "男",
      "birthday": "1999-11-20",
      "idCard": "341502198810196427",
      "wedlock": "未婚",
      "nationId": 1,
      "nativePlace": "英市",
      "politicId": 11,
      "email": "xia53@gangjing.cn",
      "phone": "15567487644",
      "address": "贵州省洁市清城汕尾街d座 502246",
      "departmentId": 3,
      "jobLevelId": 5,
      "posId": 5,
      "engageForm": "劳动合同",
      "tiptopDegree": "博士",
      "specialty": "电子工程",
      "school": "中国科学技术大学",
      "beginDate": "2018-10-16",
      "workState": "在职",
      "workID": "00000101",
      "conversionTime": "2018-08-29",
      "notWorkDate": null,
      "beginContract": "2017-09-03",
      "endContract": "2019-08-26",
      "workAge": null,
      "salaryId": 4
}
```

![image-20230120160753294](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120160753294.png)

![image-20230120160821516](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120160821516.png)

#### 17.2.8、删除员工功能实现

在`com.chang.yebserver.controller.EmployeeController`中增加如下内容：

```java
	@ApiOperation(value = "删除员工")
    @DeleteMapping("/{id}")
    public RespBean deleteEmp(@PathVariable Integer id){
        if(employeeService.removeById(id)){
            return RespBean.success("删除成功！");
        }
        return RespBean.error("删除失败！");
    }
```

![image-20230120160945660](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120160945660.png)

## 18、EasyPOI数据导入与导出

### 18.1、Apache POI简介

开发中经常会设计到excel的处理， 如导出excel、导入excel到数据库中、操作excel等。

Apache POI是使用Java编写的免费开源的跨平台的Java API，Apache POI提供APl给Java程式对Microsoft Office (Excel、WORD 、PowerPoint 、VisiO 等）格式档案读和写的功能。POI 为"Poor Obfuscation Implementation" 的首字母缩写，意为“可怜的模糊实现” 。

- 官方主页：http://poi.apache.org/index.html
- API文档： http://poi.apache.org/apidocs/index.html

缺点：

1. 对于复杂的Excel模板样式需要编写大量的代码实现
2. 大数据量的读取/导出效率低下，甚至可能内存溢出

### 18.2、EasyPOI 简介

为了解决上述poi的缺点，国内有很多开源项目对POI进行了封装，大大减少代码量，使其能够更简单的被我们使用，并提高开发效率， 例如EasyPOI、Excel4j、HuTools等优秀的开源顶目。

EasyPOI功能如同名字easy，主打的功能就是容易，让一个没见接触过POI的人员就可以方便的写出Excel导出、Excel模板导出，Excel导入，Word模板导出，通过简单的注解和模板语言（熟悉的表达式语法），完成以前复杂的写法。

- 官方主页：https://gitee.com/lemur/easypoi?form=gitee.search
- API文档：   http://doc.wupaas.com/docs/easypoi/easypoi-1c0u4mo8p4ro8
- 测试项目：http://git.oschina.net/lemur/easypoi-test

特点：

1. 设计精巧，使用简单
2. 接口丰富，扩展简单
3. 默认值多，write less do more
4. AbstractView支持，web导出简单明了

### 18.3、导出员工依赖

#### 18.3.1、依赖添加

在`pom.xml`中添加如下依赖：

```xml
		<!--easypoi依赖-->
        <dependency>
            <groupId>cn.afterturn</groupId>
            <artifactId>easypoi-spring-boot-starter</artifactId>
            <version>4.1.3</version>
        </dependency>
```

#### 18.3.2、修改员工类

员工类使用@Excel定义了需要导出的属性，name为导出的列名，width可以定义列的宽度，format可以定义导入和导出的时间格式

员工类中还有其他类作为属性，例如民族、政治面貌、职称、职位等，这些使用@ExcelEntity标记为实体类

在`com.chang.yebserver.pojo.Employee`中增加@Excel注解以及@ExcelEntity注解

```java
package com.chang.yebserver.pojo;

import cn.afterturn.easypoi.excel.annotation.Excel;
import cn.afterturn.easypoi.excel.annotation.ExcelEntity;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import java.time.LocalDate;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;

import com.fasterxml.jackson.annotation.JsonFormat;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

/**
 * <p>
 * 
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("t_employee")
@ApiModel(value="Employee对象", description="")
public class Employee implements Serializable {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "员工编号")
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @ApiModelProperty(value = "员工姓名")
    @Excel(name = "员工姓名")
    private String name;

    @ApiModelProperty(value = "性别")
    @Excel(name = "性别")
    private String gender;

    @ApiModelProperty(value = "出生日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    @Excel(name = "出生日期",width = 20,format = "yyyy-MM-dd")
    private LocalDate birthday;

    @ApiModelProperty(value = "身份证号")
    @Excel(name = "身份证号",width = 30)
    private String idCard;

    @ApiModelProperty(value = "婚姻状况")
    @Excel(name = "婚姻状况")
    private String wedlock;

    @ApiModelProperty(value = "民族")
    private Integer nationId;

    @ApiModelProperty(value = "籍贯")
    @Excel(name = "籍贯")
    private String nativePlace;

    @ApiModelProperty(value = "政治面貌")
    private Integer politicId;

    @ApiModelProperty(value = "邮箱")
    @Excel(name = "邮箱",width = 30)
    private String email;

    @ApiModelProperty(value = "电话号码")
    @Excel(name = "电话号码",width = 15)
    private String phone;

    @ApiModelProperty(value = "联系地址")
    @Excel(name = "联系地址",width = 40)
    private String address;

    @ApiModelProperty(value = "所属部门")
    private Integer departmentId;

    @ApiModelProperty(value = "职称ID")
    private Integer jobLevelId;

    @ApiModelProperty(value = "职位ID")
    private Integer posId;

    @ApiModelProperty(value = "聘用形式")
    @Excel(name = "聘用形式")
    private String engageForm;

    @ApiModelProperty(value = "最高学历")
    @Excel(name = "最高学历")
    private String tiptopDegree;

    @ApiModelProperty(value = "所属专业")
    @Excel(name = "所属专业",width = 20)
    private String specialty;

    @ApiModelProperty(value = "毕业院校")
    @Excel(name = "毕业院校",width = 20)
    private String school;

    @ApiModelProperty(value = "入职日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    @Excel(name = "入职日期",width = 20,format = "yyyy-MM-dd")
    private LocalDate beginDate;

    @ApiModelProperty(value = "在职状态")
    @Excel(name = "在职状态")
    private String workState;

    @ApiModelProperty(value = "工号")
    @Excel(name = "工号")
    private String workID;

    @ApiModelProperty(value = "合同期限")
    @Excel(name = "合同期限",suffix = "年")
    private Double contractTerm;

    @ApiModelProperty(value = "转正日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    @Excel(name = "转正日期",width = 20,format = "yyyy-MM-dd")
    private LocalDate conversionTime;

    @ApiModelProperty(value = "离职日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    private LocalDate notWorkDate;

    @ApiModelProperty(value = "合同起始日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    @Excel(name = "合同起始日期",width = 20,format = "yyyy-MM-dd")
    private LocalDate beginContract;

    @ApiModelProperty(value = "合同终止日期")
    @JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
    @Excel(name = "合同终止日期",width = 20,format = "yyyy-MM-dd")
    private LocalDate endContract;

    @ApiModelProperty(value = "工龄")
    private Integer workAge;

    @ApiModelProperty(value = "工资账套ID")
    private Integer salaryId;

    @ApiModelProperty(value = "民族")
    @TableField(exist = false)
    @ExcelEntity(name = "民族")
    private Nation nation;

    @ApiModelProperty(value = "政治面貌")
    @TableField(exist = false)
    @ExcelEntity(name = "政治面貌")
    private PoliticsStatus politicsStatus;

    @ApiModelProperty(value = "部门")
    @TableField(exist = false)
    @ExcelEntity(name = "部门")
    private Department department;

    @ApiModelProperty(value = "职称")
    @TableField(exist = false)
    @ExcelEntity(name = "职称")
    private Joblevel joblevel;

    @ApiModelProperty(value = "职位")
    @TableField(exist = false)
    @ExcelEntity(name = "职位")
    private Position position;

}
```

在`com.chang.yebserver.pojo.Nation`中:

```java
	@ApiModelProperty(value = "民族")
    @Excel(name = "民族")
    private String name;
```

在`com.chang.yebserver.pojo.PoliticsStatus`中:

```java
	@ApiModelProperty(value = "政治面貌")
    @Excel(name = "政治面貌")
    private String name;
```

在`com.chang.yebserver.pojo.Department`中:

```java
	@ApiModelProperty(value = "部门名称")
    @Excel(name = "部门名称")
    private String name;
```

在`com.chang.yebserver.pojo.Joblevel`中:

```java
	@ApiModelProperty(value = "职称名称")
    @Excel(name = "职称名称")
    private String name;
```

在`com.chang.yebserver.pojo.Position`中:

```java
	@ApiModelProperty(value = "职位")
    @Excel(name = "职位")
    private String name;
```

### 18.4、员工数据导出实现

在`com.chang.yebserver.controller.EmployeeController`中增加如下内容

```java
	//使用流的方式导出数据，produces = "application/octet-stream"用来解决乱码问题
    @ApiOperation(value = "使用流的方式导出员工数据")
    @GetMapping(value = "/export",produces = "application/octet-stream")
    public void exportEmployee(HttpServletResponse response){
        //查询获取要导出的数据
        List<Employee> list = employeeService.getEmployee(null);
        //设置导出参数（文件名、表名、类型格式）
        ExportParams params = new ExportParams("员工表", "员工表", ExcelType.HSSF);
        Workbook workbook = ExcelExportUtil.exportExcel(params, Employee.class, list);
        ServletOutputStream out = null;
        try {
            //设置响应头
                //流的形式
            response.setHeader("content-type","application/octet-stream");
                //防止中文乱码
            response.setHeader("content-disposition","attachment;filename="+ URLEncoder.encode("员工表.xls","UTF-8"));
            out = response.getOutputStream();
            workbook.write(out);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            if(out!=null){
                try {
                    out.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
```

在`com.chang.yebserver.service.EmployeeService`中增加如下内容：

```java
	/**
     * 使用流的方式导出员工数据
     * @param o
     */
    List<Employee> getEmployee(Integer id);
```

在`com.chang.yebserver.service.impl.EmployeeServiceImpl`中增加如下内容：

```java
	/**
     * 使用流的方式导出员工数据
     * @param id
     * @return
     */
    @Override
    public List<Employee> getEmployee(Integer id) {
        return employeeMapper.getEmployee(id);
    }
```

在`com.chang.yebserver.mapper.EmployeeMapper`中增加如下内容：

```java
	/**
     * 使用流的方式导出员工数据
     * @param id
     * @return
     */
    List<Employee> getEmployee(Integer id);
```

在`EmployeeMapper.xml`中增加如下内容：

```xml
	<!--使用流的方式导出员工数据-->
    <select id="getEmployee" resultMap="EmployeeInfo">
        SELECT
            e.*,
            n.id AS nid,
            n.`name` as nname,
            p.id AS pid,
            p.`name` as pname,
            d.id AS did,
            d.`name` AS dname,
            j.id AS jid,
            j.`name` AS jname,
            pos.id AS posid,
            pos.`name` AS posname
        FROM
            t_employee e,
            t_nation n,
            t_politics_status p,
            t_department d,
            t_joblevel j,
            t_position pos
        WHERE
            e.nationId = n.id
          AND
            e.politicId = p.id
          AND
            e.departmentId = d.id
          AND
            e.jobLevelId = j.id
          AND
            e.posId = pos.id
          <if test="null!=id">
              AND e.id = #{id}
          </if>
        ORDER BY
            e.id
    </select>
```

![image-20230120174405578](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120174405578.png)

### 18.5、员工数据导入实现 

> - 由于t_employee中存放的是nation等字段的id值，可以根据具体内容到对应的表中查询id值，但这样实现需要的成本比较大
> - 但每个字段内容都是很少发生变动并且唯一的内容，可以采用重写hashcode和equals的方法
> - 由于属性唯一，那么创建的对象也是唯一的，对象的id也是唯一的
> - 实现：
>   - 在对应的类中重写haascode与equals方法，`@EqualsAndHashCode(callSuper = false, of = "name")  //of表示重写某个属性`
>   - `@NoArgsConstructor  //无参构造`
>   - `@RequiredArgsConstructor    //有参构造`
>   - `@NonNull    //使用有参构造时不为空`
>   - 先使用service获取到所有的对象存放在List集合中，然后根据名字创建一个新对象，在List集合中使用indexOf知道创建对象所在位置，然后使用get方法从List中获取到该对象，之后针对获取到的对象使用getId()方法，最后将其设定到employee的对应位置中

下方以`com.chang.yebserver.pojo.Nation`为例，同理继续完善`PoliticsStatus`、`Department`、`Joblevel`、`Position`

```java
package com.chang.yebserver.pojo;

import cn.afterturn.easypoi.excel.annotation.Excel;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.*;
import lombok.experimental.Accessors;

/**
 * <p>
 * 
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@Data
@NoArgsConstructor  //无参构造
@RequiredArgsConstructor    //有参构造
@EqualsAndHashCode(callSuper = false, of = "name")  //of表示重写某个属性
@Accessors(chain = true)
@TableName("t_nation")
@ApiModel(value="Nation对象", description="")
public class Nation implements Serializable {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "id")
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @ApiModelProperty(value = "民族")
    @Excel(name = "民族")
    @NonNull    //使用有参构造时不为空
    private String name;

}
```

在`com.chang.yebserver.controller.EmployeeController`中增加如下内容：

```java
	@ApiOperation(value = "导入员工数据")
    @PostMapping("/import")
    public RespBean importEmployee(MultipartFile file){

        //设置导入参数
        ImportParams params = new ImportParams();
        //删除标题行
        params.setTitleRows(1);
        //查找出所有的nation（民族）信息，之后可以使用indexOf获取索引id
        List<Nation> nationList = nationService.list();
        //同理查询其他的List集合信息
        List<PoliticsStatus> politicsStatusList = politicsStatusService.list();
        List<Department> departmentList = departmentService.list();
        List<Joblevel> joblevelList = joblevelService.list();
        List<Position> positionList = positionService.list();

        InputStream in = null;
        try {
            in=file.getInputStream();
            List<Employee> list = ExcelImportUtil.importExcel(in, Employee.class, params);
            list.forEach(employee -> {
                //民族Id
                employee.setNationId(nationList.get(nationList.indexOf(new Nation(employee.getNation().getName()))).getId());
                //政治面貌Id
                employee.setPoliticId(politicsStatusList.get(politicsStatusList.indexOf(new PoliticsStatus(employee.getPoliticsStatus().getName()))).getId());
                //部门Id
                employee.setDepartmentId(departmentList.get(departmentList.indexOf(new Department(employee.getDepartment().getName()))).getId());
                //职称Id
                employee.setJobLevelId(joblevelList.get(joblevelList.indexOf(new Joblevel(employee.getJoblevel().getName()))).getId());
                //职位Id
                employee.setPosId(positionList.get(positionList.indexOf(new Position(employee.getPosition().getName()))).getId());
            });
            if(employeeService.saveBatch(list)){
                return RespBean.success("导入成功！");
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }
        return RespBean.error("导入失败！");
    }
```

![image-20230120212531910](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120212531910.png)

## 19、邮件发送功能（Mail与RabblitMQ与定时任务）

### 19.1、创建项目并添加依赖

1. 在yebBack中创建Maven子项目yeb-mail，并在`com.chang`中新建包`mail`，然后在包`mail`下创建启动类`MailApplication`：

   `com.chang.mail.MailApplication`

   ```java
   package com.chang.mail;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   /**
    * 启动类
    */
   @SpringBootApplication
   public class MailApplication {
   
       public static void main(String[] args) {
           SpringApplication.run(MailApplication.class, args);
       }
   
   }
   ```

   ![image-20230120220142276](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120220142276.png)

2. 然后在yeb-mail中添加依赖：

`pom.xml`

```xml
	<dependencies>
        <!--rabbitmq依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <!--mail依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        <!--thymeleaf依赖：用来写邮件的模板-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <!--server依赖-->
        <dependency>
            <groupId>com.chang</groupId>
            <artifactId>yeb-server</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
    </dependencies>
```

### 19.2、创建配置文件application.yml

> 在resources文件夹中创建application.yml文件

`application.yml`：

```yml
server:
  # 端口
  port: 8082
spring:
  # 邮件配置
  mail:
    # 邮件服务器地址
    host: smtp.163.com
    # 协议
    protocol: smtp
    # 编码格式
    default-encoding: utf-8
    # 授权码（在邮箱开通服务时获取）
    password: ETXFFMHHHGPBUKTX
    # 发送者邮箱地址
    username: z2648492063c@163.com
    # 端口（不同邮箱端口号不同）
    port: 25

  # rabbitmq配置
  rabbitmq:
    # 用户名
    username: admin
    # 密码
    password: rabbitmq
    # 服务器地址
    host: 47.108.151.162
    # 端口
    port: 5672
    listener:
      simple:
        #开启手动确认
        acknowledge-mode: manual
```

### 19.3、准备邮箱模板

在`resources`目录下创建`templates`文件夹，用来存放邮箱模板

创建`mail.html`，内容如下：

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.theymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>入职欢迎邮件</title>
</head>
<body>
欢迎 <span th:text="${name}"></span>加入XXXX大家庭，您的入职信息如下：
<table border="1">
    <tr>
        <td>姓名</td>
        <td th:text="${name}"></td>
    </tr>
    <tr>
        <td>职位</td>
        <td th:text="${posName}"></td>
    </tr>
    <tr>
        <td>职称</td>
        <td th:text="${joblevelName}"></td>
    </tr>
    <tr>
        <td>部门</td>
        <td th:text="${departmentName}"></td>
    </tr>
</table>

<p>
    我们公司的工作忠旨是严格，创新，诚信，您的加入将为我们带来新鲜的血液，带来创新的思维，以及为我们树立良好的公司形象!希望在以后的工作中我们能够齐心协力，与时俱进，团结协作!同时也祝您在本公司，工作愉快，实现自己的人生价值!希望在未来的日子里，携手共进！
</p>
</body>

</html>
```

### 19.4、yeb-server添加员工发送邮件

> - 发送邮件需要用到RabbitMQ，不仅yeb-mail需要引入依赖，yeb-server也需要引入依赖
> - yeb-server在将员工添加到数据库之后，要重新根据id获取到该对象，然后使用rabbitTemplate将对象发送到RabbitMQ队列当中

在`yeb-server/pom.xml`中引入`RabbitMQ`依赖：

```java
		<!--rabbitmq依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
```

在`yeb-server/src/main/resources/application.yml`中的spring下添加RabbitMQ的配置文件

```yml
  # rabbitmq配置
  rabbitmq:
    # 用户名
    username: admin
    # 密码
    password: rabbitmq
    # 服务器地址
    host: 47.108.151.162
    # 端口
    port: 5672
    listener:
      simple:
        #开启手动确认
        acknowledge-mode: manual
```

在`com.chang.yebserver.service.impl.EmployeeServiceImpl`中进行增加修改，内容如下：

```java
	@Autowired
    private RabbitTemplate rabbitTemplate;
```

```java
	/**
     * 添加员工
     * @param employee
     * @return
     */
    @Override
    public RespBean addEmp(Employee employee) {
        //处理合同期限，二者做差获取所有天数，然后除以365并保留2位小数
        LocalDate beginContract = employee.getBeginContract();
        LocalDate endContract = employee.getEndContract();
        long days = beginContract.until(endContract, ChronoUnit.DAYS);
        DecimalFormat decimalFormat = new DecimalFormat("##.00");
        employee.setContractTerm(Double.parseDouble(decimalFormat.format(days/365.00)));
        if(1==employeeMapper.insert(employee)){
            //获取刚刚添加完成的用户信息
            Employee emp = employeeMapper.getEmployee(employee.getId()).get(0);
            //向RabbitMQ发送信息
            rabbitTemplate.convertAndSend("mail.welcome",emp);
            return RespBean.success("添加成功！");
        }
        return RespBean.error("添加失败！");
    }
```

### 19.5、yeb-mail创建队列接收对象

> - yeb-mail首先会在RabiitMQ中`创建队列`，例如：“mail.welcome”，为简化目录，可以放在启动类中
>
> - 由于yeb-mail的pom中引入了yeb-server，但并不需要与数据库连接，所以修改启动类的注解为：
>
>   `@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})`
>
> - 新建`MailReceiver类`，引入`打印日志`、引入`邮件发送`、引入`邮件配置`、引入`模板引擎`，然后使用注解`@RabbitListener(queues = "mail.welcome")`监听RabbitMQ队列，接收传递过来的对象，并放置模板中渲染，然后以邮件的形式发送出去

`com.chang.mail.MailApplication`：

```java
package com.chang.mail;

import org.springframework.amqp.core.Queue;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.Bean;

/**
 * 启动类
 * 不需连接数据库，所以增加exclude = {DataSourceAutoConfiguration.class}
 */
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MailApplication {

    public static void main(String[] args) {
        SpringApplication.run(MailApplication.class, args);
    }

    @Bean
    public Queue queue(){
        return new Queue("mail.welcome");
    }

}
```

`com.chang.mail.MailReceiver`：

```java
package com.chang.mail;

import com.chang.yebserver.pojo.Employee;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.mail.MailProperties;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Component;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import java.time.temporal.Temporal;
import java.util.Date;

/**
 * RabbitMq消息接收者，接收到消息后，再发送邮件
 */
@Component
public class MailReceiver {

    //打印日志
    private static final Logger LOGGER = LoggerFactory.getLogger(MailReceiver.class);

    //引入邮件发送
    @Autowired
    private JavaMailSender javaMailSender;

    //引入邮件配置
    @Autowired
    private MailProperties mailProperties;

    //引入模板引擎
    @Autowired
    private TemplateEngine templateEngine;

    //使用注解引入对RabbitMQ的队列监听，handler里面接收传递过来的Employee对象
    @RabbitListener(queues = "mail.welcome")
    public void handler(Employee employee){
        //创建消息
        MimeMessage msg = javaMailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(msg);

        try {
            //设置发件人
            helper.setFrom(mailProperties.getUsername());
            //设置收件人
            helper.setTo(employee.getEmail());
            //设置主题
            helper.setSubject("入职欢迎邮件");
            //发送日期
            helper.setSentDate(new Date());
            //邮件内容
            Context context = new Context();
            context.setVariable("name", employee.getName());
            context.setVariable("posName", employee.getPosition().getName());
            context.setVariable("joblevelName", employee.getJoblevel().getName());
            context.setVariable("departmentName", employee.getDepartment().getName());
            //将邮件内容设置到模板引擎
            String mail = templateEngine.process("mail", context);
            //设置内容
            helper.setText(mail, true);
            //发送邮件
            javaMailSender.send(msg);

        } catch (MessagingException e) {
            //日志打印错误信息
            LOGGER.error("邮件发送失败=========>{}", e.getMessage());
        }
    }
}
```

启动MailApplication后可以在`http://47.108.151.162:15672/#/queues`中看到新增加的队列：`“mail.welcome”`：（其中还没有消息）

![image-20230120231124640](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120231124640.png)

### 19.6、发送邮件并查看

- 启动`YebServerApplication`与`MailApplication`
  - `YebServerApplication`作为邮件消息的生产者，在调用添加用户功能时发送消息到RabbitMQ中
  - `MailApplication`作为邮件消息的消费者，监听并接收到RabbitMQ中消息时，发送邮件到指定邮箱

> 添加用户的测试信息为：（重点是其中包含可以收到邮件的邮箱）

```json
{
      "name": "张三",
      "gender": "男",
      "birthday": "1999-11-20",
      "idCard": "341502198810196427",
      "wedlock": "未婚",
      "nationId": 1,
      "nativePlace": "英市",
      "politicId": 11,
      "email": "2648492063@qq.com",
      "phone": "15567487644",
      "address": "贵州省洁市清城汕尾街d座 502246",
      "departmentId": 3,
      "jobLevelId": 5,
      "posId": 5,
      "engageForm": "劳动合同",
      "tiptopDegree": "博士",
      "specialty": "电子工程",
      "school": "中国科学技术大学",
      "beginDate": "2018-10-16",
      "workState": "在职",
      "workID": "00000101",
      "conversionTime": "2018-08-29",
      "notWorkDate": null,
      "beginContract": "2017-09-03",
      "endContract": "2019-08-26",
      "workAge": null,
      "salaryId": 4
}
```

![image-20230120231826065](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120231826065.png)

> 在RabbitMQ Manager尽管看不到mail.welcome队列发生变化，但这是因为生产者已经被消息者处理了

![image-20230120232521515](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120232521515.png)

> 此外，QQ邮箱也确实收到了来自z2648492063c@163.com的邮件

![image-20230120232103938](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120232103938.png)

### 19.7、生产端可靠性投递方案介绍

- 怎样保证消息成功发出
- 怎么保证RabbitMQ成功接收到消息，也就是队列获取到数据
- 生产者收到RabbitMQ确认收到应答
- 完善消息的补偿机制（有2种）：
  - 消息落库（对消息状态进行打标，缺点是过多的操作数据库）
  - 消息延迟投递（做二次确认，回调检查）

**`消息落库`：**

![image-20230120234134266](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120234134266.png)

**`消息延迟投递`：**

![image-20230120234030128](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120234030128.png)

**`项目实现流程：`**

1. 发送消息时，将当前消息数据存入数据库，投递状态为消息投递中
2. 开启消息确认回调机制，确认成功，更新投递状态为消息投递成功
3. 开启定时任务，重新投递失败的消息，重试超过3次，更新投递状态为投递失败

### 19.8、开启消息回调机制

#### 19.8.1、存放消息状态的表t_mail_log

> 在该张中并不存在主键

![image-20230120234645268](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230120234645268.png)

#### 19.8.2、定义消息状态常量

> 在`pojo`中定义一个`MailConstants`类，用来作为消息状态类，定义消息的各种常量信息

`com.chang.yebserver.pojo.MailConstants`：

```java
package com.chang.yebserver.pojo;

/**
 * 定义消息状态常量
 */
public class MailConstants {

    //消息投递状态中
    public static final Integer DELIVERING = 0;

    //消息投递成功
    public static final Integer SUCCESS = 1;

    //消息投递失败
    public static final Integer FAILURE = 2;

    //最大重试次数
    public static final Integer MAX_TRY_COUNT = 3;

    //消息超时时间设置为1分钟
    public static final Integer MSG_TIMEOUT = 1;

    //队列名称
    public static final String MAIL_QUEUE_NAME = "mail.queue";

    //交换机名称
    public static final String MAIL_EXCHANGE_NAME = "mail.exchange";

    //路由键
    public static final String MAIL_ROUTING_KEY_NAME = "mail.routing.key";

}
```

#### 19.8.3、更新消息发送方法

在`com.chang.yebserver.service.impl.EmployeeServiceImpl`中更新`addEmp(Employee employee)`（添加员工方法），对消息进行落户处理，其中用到了之前定义的常量信息，此外在发送消息时，需要添加交换机名称、路由键名称、传递对象、消息的Id

```java
	@Override
    public RespBean addEmp(Employee employee) {
        //处理合同期限，二者做差获取所有天数，然后除以365并保留2位小数
        LocalDate beginContract = employee.getBeginContract();
        LocalDate endContract = employee.getEndContract();
        long days = beginContract.until(endContract, ChronoUnit.DAYS);
        DecimalFormat decimalFormat = new DecimalFormat("##.00");
        employee.setContractTerm(Double.parseDouble(decimalFormat.format(days/365.00)));
        if(1==employeeMapper.insert(employee)){
            //获取刚刚添加完成的用户信息
            Employee emp = employeeMapper.getEmployee(employee.getId()).get(0);

            //以下为消息落库处理：
            //设置数据库记录发送消息的ID
            String msgId = UUID.randomUUID().toString();
            //设置要存储到数据库表t_mail_log的内容
            MailLog mailLog = new MailLog();
            mailLog.setMsgId(msgId);
            mailLog.setEid(employee.getId());
            mailLog.setStatus(MailConstants.DELIVERING);
            mailLog.setRouteKey(MailConstants.MAIL_ROUTING_KEY_NAME);
            mailLog.setExchange(MailConstants.MAIL_EXCHANGE_NAME);
            mailLog.setCount(0);
            //在当前时间的基础之上增加超时时间
            mailLog.setTryTime(LocalDateTime.now().plusMinutes(MailConstants.MSG_TIMEOUT));
            mailLog.setCreateTime(LocalDateTime.now());
            mailLog.setUpdateTime(LocalDateTime.now());
            //将mailLog对象存放到数据库中
            mailLogMapper.insert(mailLog);

            //发送信息：最后一个参数为消息的id
            rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME,MailConstants.MAIL_ROUTING_KEY_NAME,emp,new CorrelationData(msgId));
            return RespBean.success("添加成功！");
        }
        return RespBean.error("添加失败！");
    }
```

#### 19.8.4、更新消息接收队列

> - 使用消息状态常量更新`yeb-mail`中的`com.chang.mail.MailReceiver`监听注解
>
>   `@RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)`
>
> - 更新启动类中创建队列的注解
>
>   - 项目中引入了RabbitMQ,但是在加了@bean配置交换机和queue，启动项目却没自动化创建队列
>
>     原因：RabbitMQ懒加载模式， 需要配置消费者监听才会创建
>
>     @RabbitListener(queues = "short_link.add.link.queue")
>
>     另外一种方式(若Mq中无相应名称的队列,会自动创建Queue)
>
>     @RabbitListener(queuesToDeclare = { @Queue("short_link.add.link.queue") })

`MailApplication`

```java
package com.chang.mail;

import com.chang.yebserver.pojo.MailConstants;
import org.springframework.amqp.core.Queue;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.Bean;

/**
 * 启动类
 * 不需连接数据库，所以增加exclude = {DataSourceAutoConfiguration.class}
 */
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MailApplication {

    public static void main(String[] args) {
        SpringApplication.run(MailApplication.class, args);
    }

    @Bean
    public Queue queue(){
        return new Queue(MailConstants.MAIL_QUEUE_NAME);
    }

}
```

![image-20230121005112828](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230121005112828.png)

#### 19.8.5、RabbitMQ配置

在`com.chang.yebserver.config`中新增类`RabbitMQConfig`，作为RabbitMQ的配置类，其中包含要创建的队列、交换机、二者的绑定关系、发送确认回调、发送失败回调

针对发送确认回调，要使用`mailLogService`更新`t_mail_log`中`status`的状态

`com.chang.yebserver.config.RabbitMQConfig`：

```java
package com.chang.yebserver.config;

import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.chang.yebserver.pojo.MailConstants;
import com.chang.yebserver.pojo.MailLog;
import com.chang.yebserver.service.MailLogService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * RabbitMQ配置类
 */
@Configuration
public class RabbitMQConfig {

    //日志
    private static final Logger LOGGER = LoggerFactory.getLogger(RabbitMQConfig.class);

    //引入连接工厂
    @Autowired
    private CachingConnectionFactory cachingConnectionFactory;

    @Autowired
    private MailLogService mailLogService;

    //配置RabbitMQ消息确认回调以及失败回调
    @Bean
    public RabbitTemplate rabbitTemplate(){
        RabbitTemplate rabbitTemplate = new RabbitTemplate(cachingConnectionFactory);
        /**
         * 1、消息发送确认回调
         * data：消息的唯一标识
         * ack：确认结果
         * cause：失败的原因
         */
        rabbitTemplate.setConfirmCallback((data,ack,cause)->{
            String msgId = data.getId();
            if(ack){
                LOGGER.info("{}==========>消息发送成功",msgId);
                //成功要去更新数据库
                mailLogService.update(new UpdateWrapper<MailLog>().set("status",MailConstants.SUCCESS).eq("msgId",msgId));
            }else {
                LOGGER.info("{}==========>消息发送失败",msgId);
            }
        });

        /**
         * 2、消息发送失败回调，比如router不到queue时回调
         * msg：消息主题
         * repCode：响应码
         * repText：响应描述
         * exchange：交换机
         * routingKey：路由键
         */
        rabbitTemplate.setReturnCallback((msg,repCode,repText,exchange,routingKey)->{
            LOGGER.info("{}==========>消息发送到queue时失败",msg.getBody());
        });

        return rabbitTemplate;
    }

    //创建队列
    @Bean
    public Queue queue(){
        return new Queue(MailConstants.MAIL_QUEUE_NAME);
    }

    //创建交换机
    @Bean
    public DirectExchange directExchange(){
        return new DirectExchange(MailConstants.MAIL_EXCHANGE_NAME);
    }

    //绑定队列与交换机
    @Bean
    public Binding binding(){
        return BindingBuilder.bind(queue()).to(directExchange()).with(MailConstants.MAIL_ROUTING_KEY_NAME);
    }
}
```

#### 19.8.6、修改配置信息开启回调

> 在`yeb-server`的`application.yml`中开启`RabbitMQ的回调功能`

```yml
  # rabbitmq配置
  rabbitmq:
    # 用户名
    username: admin
    # 密码
    password: rabbitmq
    # 服务器地址
    host: 47.108.151.162
    # 端口
    port: 5672
    #消息确认回调
    publisher-confirm-type: correlated
    #消息失败回调
    publisher-returns: true
```

### 19.9、定时任务查询发送邮件

> - 在`com.chang.yebserver`包下新建`task`文件夹，用来存放定时任务，在`task`中新建`MailTask`用来执行邮件发送的定时任务
> - 使用`@Scheduled(cron = "0/10 * * * * ?")`指定每10秒执行一次定时任务
> - 在启动类`YebServerApplication`上使用注解`@EnableScheduling`开启定时任务

`com.chang.yebserver.task.MailTask`：

```java
package com.chang.yebserver.task;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.chang.yebserver.pojo.Employee;
import com.chang.yebserver.pojo.MailConstants;
import com.chang.yebserver.pojo.MailLog;
import com.chang.yebserver.service.EmployeeService;
import com.chang.yebserver.service.MailLogService;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

/**
 * 邮件发送的定时任务
 */

@Component
public class MailTask {

    @Autowired
    private MailLogService mailLogService;

    @Autowired
    private EmployeeService employeeService;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 邮件发送定时任务
     * 10秒执行一次
     */
    @Scheduled(cron = "0/10 * * * * ?")
    public void mailTask(){
        //获取所有处于投递中的消息（status=0），并且重试时间小于当前时间（也就是当前时间达到了重试时间）
        List<MailLog> list = mailLogService.list(new QueryWrapper<MailLog>().eq("status", MailConstants.DELIVERING).lt("tryTime", LocalDateTime.now()));

        list.forEach(mailLog -> {
            //如果重试次数超过3次，更新状态为投递失败，不再重试
            if (3<=mailLog.getCount()){
                mailLogService.update(new UpdateWrapper<MailLog>().set("status",MailConstants.FAILURE).eq("msgId",mailLog.getMsgId()));
            }
            //如果没有，重试次数+1，设置更新时间，设置重试时间（当前时间加延时时间）
            mailLogService.update(new UpdateWrapper<MailLog>().set("count",mailLog.getCount()+1).set("updateTime",LocalDateTime.now()).set("tryTime",LocalDateTime.now().plusMinutes(MailConstants.MSG_TIMEOUT)).eq("msgId",mailLog.getMsgId()));

            //获得Employee对象，重新发送到RabbitMQ
            Employee emp = employeeService.getEmployee(mailLog.getEid()).get(0);
            rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME,MailConstants.MAIL_QUEUE_NAME,emp,new CorrelationData(mailLog.getMsgId()));
        });
    }
}
```

`com.chang.yebserver.YebServerApplication`

```java
package com.chang.yebserver;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@MapperScan("com.chang.yebserver.mapper")
//开启定时任务
@EnableScheduling
public class YebServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(YebServerApplication.class, args);
    }

}
```

### 19.10、消费端幂等性操作

> 幂等性：有可能投递id一样的消息，也就是同一条消息被投递两次
>
> 消费者遇到重复的消息，应该做什么样的操作，只会消费一条消息

消费者消费完后要将msgId存储到缓存中，并且消费者消费之前去redis中查询一下有没有这个id，有这个id说明已经消费过了，就不要再消费了，没有则继续执行。

在`yeb-mail`中的`application.yml`中，将RabbitMQ设置为手动应答，并且配置Redis：

```yml
server:
  # 端口
  port: 8082
spring:
  # 邮件配置
  mail:
    # 邮件服务器地址
    host: smtp.163.com
    # 协议
    protocol: smtp
    # 编码格式
    default-encoding: utf-8
    # 授权码（在邮箱开通服务时获取）
    password: ETXFFMHHHGPBUKTX
    # 发送者邮箱地址
    username: z2648492063c@163.com
    # 端口（不同邮箱端口号不同）
    port: 25

  # rabbitmq配置
  rabbitmq:
    # 用户名
    username: admin
    # 密码
    password: rabbitmq
    # 服务器地址
    host: 47.108.151.162
    # 端口
    port: 5672
    listener:
      simple:
        #开启手动确认
        acknowledge-mode: manual

  redis:
    #超时时间
    timeout: 10000ms
    #服务器地址
    host: 127.0.0.1
    #服务器端口
    port: 6379
    #数据库
    database: 0
    #密码
#    password: redis
    lettuce:
      pool:
        #最大连接数，默认8
        max-active: 1024
        #最大连接阻塞等待时间，默认-1
        max-wait: 10000ms
        #最大空闲连接
        max-idle: 200
        #最小空闲连接
        min-idle: 5
```

在`com.chang.mail.MailReceiver`中实现上述逻辑，接收Message消息，使用Channel信道进行应答

```java
package com.chang.mail;

import com.chang.yebserver.pojo.Employee;
import com.chang.yebserver.pojo.MailConstants;
import com.rabbitmq.client.Channel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.mail.MailProperties;
import org.springframework.data.redis.core.HashOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.stereotype.Component;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import javax.mail.internet.MimeMessage;
import java.io.IOException;
import java.util.Date;

/**
 * RabbitMq消息接收者，接收到消息后，再发送邮件
 */
@Component
public class MailReceiver {

    //打印日志
    private static final Logger LOGGER = LoggerFactory.getLogger(MailReceiver.class);

    //引入邮件发送
    @Autowired
    private JavaMailSender javaMailSender;

    //引入邮件配置
    @Autowired
    private MailProperties mailProperties;

    //引入模板引擎
    @Autowired
    private TemplateEngine templateEngine;
    @Autowired
    private RedisTemplate redisTemplate;

    //使用注解引入对RabbitMQ的队列监听，handler里面接收传递过来的Employee对象
    @RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)
    public void handler(Message message, Channel channel){

        //不再是直接获取Employee对象，而是通过message获取并强转
        Employee employee = (Employee)message.getPayload();

        //获取消息序号
        MessageHeaders headers = message.getHeaders();
        Long tag =(long) headers.get(AmqpHeaders.DELIVERY_TAG);

        //获取发送消息时存放在CorrelationData中的id
        String msgId = (String) headers.get("spring_returned_message_correlation");

        //使用redis以hash形式存储
        HashOperations hashOperations = redisTemplate.opsForHash();


        try {
            if(hashOperations.entries("mail_log").containsKey(msgId)){
                LOGGER.info("消息已经被消费===============>{}",msgId);
                /**
                 * 手动确认消息
                 * tag：消息序号
                 * multiple：是否确认多条，如果为false，则仅确认1条
                 */
                channel.basicAck(tag,false);
                return;
            }

            //创建消息
            MimeMessage msg = javaMailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(msg);
            //设置发件人
            helper.setFrom(mailProperties.getUsername());
            //设置收件人
            helper.setTo(employee.getEmail());
            //设置主题
            helper.setSubject("入职欢迎邮件");
            //发送日期
            helper.setSentDate(new Date());
            //邮件内容
            Context context = new Context();
            context.setVariable("name", employee.getName());
            context.setVariable("posName", employee.getPosition().getName());
            context.setVariable("joblevelName", employee.getJoblevel().getName());
            context.setVariable("departmentName", employee.getDepartment().getName());
            //将邮件内容设置到模板引擎
            String mail = templateEngine.process("mail", context);
            //设置内容
            helper.setText(mail, true);
            //发送邮件
            javaMailSender.send(msg);
            LOGGER.info("邮件发送成功");
            //邮件发送成功，将消息Id存入redis中
            hashOperations.put("mail_log",msgId,"OK");
            //信道手动确认
            channel.basicAck(tag,false);
        } catch (Exception e) {
            /**
             * 手动确认消息
             * tag：消息序号
             * multiple：是否确认多条，如果为false，则仅确认1条
             * requeue：是否重回队列
             */
            try {
                channel.basicNack(tag,false,true);
            } catch (IOException ex) {
                LOGGER.error("邮件发送失败=========>{}", e.getMessage());
            }
            //日志打印错误信息
            LOGGER.error("邮件发送失败=========>{}", e.getMessage());
        }
    }
}
```

![image-20230122002351762](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230122002351762.png)

## 20、工资账套与员工账套功能实现

### 20.1、工资账套功能实现

在`Salary`中`createDate`属性上添加注解：

```java
@JsonFormat(pattern = "yyyy-MM-dd",timezone = "Asia/Shanghai")
```

![image-20230122005732027](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230122005732027.png)

在`com.chang.yebserver.controller.SalaryController`中实现对`Salary`实体的增删改查

```java
package com.chang.yebserver.controller;


import com.chang.yebserver.pojo.Salary;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.service.SalaryService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author ZhangChang
 * @since 2023-01-18
 */
@RestController
@RequestMapping("/salary/sob")
public class SalaryController {
    @Autowired
    private SalaryService salaryService;

    @ApiOperation(value = "获取所有的工资账套")
    @GetMapping("/")
    public List<Salary> getAllSalaries(){
        return salaryService.list();
    }

    @ApiOperation(value = "添加工资账套")
    @PostMapping("/")
    public RespBean addSalary(@RequestBody Salary salary){
        salary.setCreateDate(LocalDateTime.now());
        if(salaryService.save(salary)){
            return RespBean.success("添加成功！");
        }
        return RespBean.error("添加失败！");
    }

    @ApiOperation(value = "删除工资账套")
    @DeleteMapping("/{id}")
    public RespBean deleteSalary(@PathVariable Integer id){
        if(salaryService.removeById(id)){
            return RespBean.success("删除成功！");
        }
        return RespBean.error("删除失败！");
    }

    @ApiOperation(value = "更新工资账套")
    @PutMapping("/")
    public RespBean deleteSalary(@RequestBody Salary salary){
        if(salaryService.updateById(salary)){
            return RespBean.success("更新成功！");
        }
        return RespBean.error("更新失败！");
    }

}
```

### 20.2、员工账套功能实现

> 本质是在查询员工时以Page的形式展示出Salary内容

在`com.chang.yebserver.pojo.Employee`中增加属性：

```java
	@ApiModelProperty(value = "工资账套")
    @TableField(exist = false)
    private Salary salary;
```

在`com.chang.yebserver.controller.SalarySobCfgController`中新增如下内容：

```java
package com.chang.yebserver.controller;

import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.chang.yebserver.pojo.Employee;
import com.chang.yebserver.pojo.Salary;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.respPojo.RespPageBean;
import com.chang.yebserver.service.EmployeeService;
import com.chang.yebserver.service.SalaryService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 员工账套
 */
@RestController
@RequestMapping("/salary/sobcfg")
public class SalarySobCfgController {

    @Autowired
    private SalaryService salaryService;

    @Autowired
    private EmployeeService employeeService;

    @ApiOperation("获取所有工资账套")
    @GetMapping("/salaries")
    public List<Salary> getAllSalaries(){
        return salaryService.list();
    }

    @ApiOperation("获取所有的员工账套")
    @GetMapping("/")
    public RespPageBean getEmployeeWithSalary(@RequestParam(defaultValue = "1") Integer currentPage,
                                              @RequestParam(defaultValue = "10") Integer size){
        return employeeService.getEmployeeWithSalary(currentPage,size);
    }

    @ApiOperation("更新员工账套")
    @PutMapping("/")
    public RespBean updateEmployeeSalary(Integer eid,Integer sid){
        if(employeeService.update(new UpdateWrapper<Employee>().set("salaryId",sid).eq("id",eid))){
            return RespBean.success("更新成功！");
        }
        return RespBean.error("更新失败！");
    }
}
```

在`com.chang.yebserver.service.EmployeeService`中新增如下内容：

```java
	/**
     * 获取所有员工账套
     * @param currentPage
     * @param size
     * @return
     */
    RespPageBean getEmployeeWithSalary(Integer currentPage, Integer size);
```

在`com.chang.yebserver.service.impl.EmployeeServiceImpl`中新增如下内容：

```java
	/**
     * 获取所有员工账套
     * @param currentPage
     * @param size
     * @return
     */
    @Override
    public RespPageBean getEmployeeWithSalary(Integer currentPage, Integer size) {
        //开启分页
        Page<Employee> page = new Page<>(currentPage,size);
        IPage<Employee> employeeIPage = employeeMapper.getEmployeeWithSalary(page);
        /**
         * 获取总条数
         * 获取每条信息
         */
        RespPageBean respPageBean = new RespPageBean(employeeIPage.getTotal(),employeeIPage.getRecords());
        return respPageBean;
    }
```

在`com.chang.yebserver.mapper.EmployeeMapper`中新增如下内容：

```java
	/**
     * 获取所有员工账套
     * @param page
     * @return
     */
    IPage<Employee> getEmployeeWithSalary(Page<Employee> page);
```

在`EmployeeMapper.xml`中新增如下内容：

```xml
	<resultMap id="EmployeeWithSalary" type="com.chang.yebserver.pojo.Employee" extends="BaseResultMap">
        <association property="salary" javaType="com.chang.yebserver.pojo.Salary">
            <id column="sid" property="id" />
            <result column="sname" property="name" />
            <result column="sbasicSalary" property="basicSalary" />
            <result column="sbonus" property="bonus" />
            <result column="slunchSalary" property="lunchSalary" />
            <result column="strafficSalary" property="trafficSalary" />
            <result column="sallSalary" property="allSalary" />
            <result column="spensionBase" property="pensionBase" />
            <result column="spensionPer" property="pensionPer" />
            <result column="smedicalBase" property="medicalBase" />
            <result column="smedicalPer" property="medicalPer" />
            <result column="saccumulationFundBase" property="accumulationFundBase" />
            <result column="saccumulationFundPer" property="accumulationFundPer" />
        </association>
        <association property="department" javaType="com.chang.yebserver.pojo.Department">
            <result column="dname" property="name" />
        </association>
    </resultMap>

    <!--获取所有员工账套-->
    <select id="getEmployeeWithSalary" resultMap="EmployeeWithSalary">
        SELECT
            e.*,
            d.`name` AS dname,
            s.id AS sid,
            s.`name` AS sname,
            s.basicSalary AS sbasicSalary,
            s.bonus AS sbonus,
            s.lunchSalary AS slunchSalary,
            s.trafficSalary AS strafficSalary,
            s.allSalary AS sallSalary,
            s.pensionBase AS spensionBase,
            s.pensionPer AS spensionPer,
            s.medicalBase AS smedicalBase,
            s.medicalPer AS smedicalPer,
            s.accumulationFundBase AS saccumulationFundBase,
            s.accumulationFundPer AS saccumulationFundPer
        FROM
            t_employee e
                LEFT JOIN t_salary s ON e.salaryId = s.id
                LEFT JOIN t_department d ON e.departmentId = d.id
        ORDER BY
            e.id
    </select>
```

## 21、WebSocket

### 21.1、WebSocket简介

WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。

WebSocket使得客户端和服务器之间的数据交换变得简单，运行服务端主动向客户端推送数据，在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并保持双向数据传输。

它最大的特点就是，服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送消息，是真正的双向平等的对话，属于服务器推送技术的一种。

![image-20230122015236295](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230122015236295.png)

其他特点包括：

- 较少的控制开销
- 更强的实时性
- 保持连续状态
- 更好的二进制支持
- 可以支持扩展
- 更好的压缩结果

### 21.2、WebSocket应用场景

举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查洵结果。HTTP 协议做不服务器主动向客户端推送信息。

现在，很多网站为了实现推送技术，所用的技术都是`Ajax轮询`。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺
点，浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，具中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

而比较新的技术去做轮询的效果是`Comet` 。这种技术虽然可以双向通信，但仍然需要反复发出清求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。

HTML5定义的WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。

### 21.3、WebSocket实现聊天功能

#### 21.3.1、添加依赖

在`pom.xml`中添加依赖

```xml
		<!--WebSocket依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
```

#### 21.3.2、WebSocket配置类

在`com.chang.yebserver.config.WebSocketConfig`中增加如下内容：

```java
package com.chang.yebserver.config;

import com.chang.yebserver.config.security.JwtTokenUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.messaging.simp.stomp.StompCommand;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.messaging.support.ChannelInterceptor;
import org.springframework.messaging.support.MessageHeaderAccessor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

/**
 * WebSocket配置类
 */
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Value("${jwt.tokenHead}")
    private String tokenHead;

    @Autowired
    private JwtTokenUtils jwtTokenUtils;

    @Autowired
    private UserDetailsService userDetailsService;

    /**
     * 添加端点Endpoint，这样在网页就可以通过WebSocket连接上服务
     * 也就是我们配置websocket的服务地址，并且可以指定是否使用SocketJS，前端一般使用SocketJS来连接服务
     * @param registry
     */
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        /**
         * 1、将”/ws/ep“路径注册为stomp的端点，用户连接了这个端点就可以进行websocket通讯，支持socketJS
         * 2、setAllowedOrigins("*")：允许跨域
         * 3、withSockJS()：支持socketJS访问
         */
        registry.addEndpoint("/ws/ep").setAllowedOrigins("*").withSockJS();
    }

    /**
     * 输入通道参数配置
     * 如果没有使用Jwt，可以不用配置
     * @param registration
     */
    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
                //使用accessor判断是不是一个连接，如果是连接，获取到其中的token并且设置到用户对象，如果不是则可以直接返回
                if(StompCommand.CONNECT.equals(accessor.getCommand())){
                    //"Auth-Token"前端传递来的
                    String token = accessor.getFirstNativeHeader("Auth-Token");
                    if(!StringUtils.isEmpty(token)){
                        String authToken = token.substring(tokenHead.length());
                        String userName = jwtTokenUtils.getUserNameFormToken(authToken);
                        if(!StringUtils.isEmpty(userName)){
                            //登录
                            UserDetails userDetails = userDetailsService.loadUserByUsername(userName);
                            //验证token是否有效，如果有效重新设置用户对象
                            if(jwtTokenUtils.validateToken(authToken,userDetails)){
                                UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                                SecurityContextHolder.getContext().setAuthentication(authenticationToken);
                                accessor.setUser(authenticationToken);
                            }
                        }

                    }
                }
                return message;
            }
        });
    }

    /**
     * 配置消息代理
     * @param registry
     */
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        //配置代理域，可以配置多个，配置代理目的地的地址前缀为”/queue“，可以在配置域上向客户端推送消息
        registry.enableSimpleBroker("/queue");
    }
}
```

#### 21.3.3、创建聊天消息实体类

在`com.chang.yebserver.pojo.ChatMsg`中增加如下内容：

```java
package com.chang.yebserver.pojo;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

import java.time.LocalDateTime;

/**
 * 消息
 */
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
public class ChatMsg {
    //谁发送的
    private String from;
    //发给谁
    private String to;
    //内容是什么
    private String content;
    //创建时间
    private LocalDateTime date;
    //发送人的昵称
    private String fromNickName;
}
```

#### 21.3.4、创建WebSocket控制层方法

在`com.chang.yebserver.controller.WsController`中增加如下内容：

```java
package com.chang.yebserver.controller;

import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.pojo.ChatMsg;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Controller;

import java.time.LocalDateTime;

/**
 * webSocket
 */
@Controller
public class WsController {

    @Autowired
    private SimpMessagingTemplate simpMessagingTemplate;

    @MessageMapping("/ws/chat")
    public void handleMsg(Authentication authentication, ChatMsg chatMsg){
        Admin admin = (Admin)authentication.getPrincipal();
        chatMsg.setFrom(admin.getUsername());
        chatMsg.setFromNickName(admin.getName());
        chatMsg.setDate(LocalDateTime.now());
        simpMessagingTemplate.convertAndSendToUser(chatMsg.getTo(),"/queue/chat",chatMsg);
    }
}
```

#### 21.3.5、创建消息控制层方法

在`com.chang.yebserver.controller.ChatController`中增加如下内容：

```java
package com.chang.yebserver.controller;

import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.service.AdminService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * 在线聊天
 */
@RestController
@RequestMapping("/chat")
public class ChatController {

    @Autowired
    private AdminService adminService;

    @ApiOperation(value = "获取所有操作员")
    @GetMapping("/admin")
    public List<Admin> getAllAdmins(String keywords){
        return adminService.getAllAdmins(keywords);
    }
}
```

#### 21.3.6、在Security中放行路径

在`com.chang.yebserver.config.security.SecurityConfig`中针对前面设定的路径（"/ws/**"）进行放行：

```java
	/*
    配置Security放行内容
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(
                "/login",
                "/logout",
                "/css/**",
                "/js/**",
                "index.html",
                "favicon.ico",
                "/doc.html",
                "/webjars/**",
                "/swagger-resources/**",
                "/v2/api-docs/**",
                "/captcha",
                "/ws/**"
        );
    }
```

## 22、个人中心功能实现

在普通项目中需要获取当前登录用户的信息，一般做法是在登录成功后，将当前用户信息存入session中。在需要
使用当前用户的时候从session里面读取。更新用户信息也是直接通过数据库进行相应的更新。

在`SpringSecurity`中提供了一个`Authentication`对象，我们可以在`Controller`或者`Service`中， 直接注入`Authentication`，注入成功后，就能直接使用。这样我们就能通过`Authentication`对象直接获取用户信息。

在`SpringSecurity`中更新用户信息，除了正常的去数据库进行相应的更新之外，还需要重新构建`Authentication`对象，这样才能在项目中正确的获取到更新后的用户信息。具体代码如下：

```java
/**
*1、用户对象
*2、凭证（密码）
*3、用户角色
*/
Admin admin = (Admin)authentication.getPrincipal();

SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(admin, authentication.getCredentials(), authentication.getAuthorities()));
```

### 22.1、更新当前用户信息以及更新用户密码

在`com.chang.yebserver.controller.AdminInfoController`中增加如下内容：

```java
package com.chang.yebserver.controller;

import com.chang.yebserver.pojo.Admin;
import com.chang.yebserver.respPojo.RespBean;
import com.chang.yebserver.service.AdminService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

/**
 * 个人中心
 */
@RestController
public class AdminInfoController {
    @Autowired
    private AdminService adminService;

    @ApiOperation(value = "更新当前用户信息")
    @PutMapping("/admin/info")
    public RespBean updateAdmin(@RequestBody Admin admin, Authentication authentication){
        if(adminService.updateById(admin)){
            SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(admin,null,authentication.getAuthorities()));
            return RespBean.success("更新成功！");
        }
        return RespBean.error("更新失败！");
    }

    @ApiOperation(value = "更新用户密码")
    @PutMapping("/admin/pass")
    public RespBean updateAdminPassword(@RequestBody Map<String,Object> info){
        String oldPass = (String) info.get("oldPass");
        String pass = (String) info.get("pass");
        Integer adminId = (Integer) info.get("adminId");
        return adminService.updateAdminPassword(oldPass,pass,adminId);
    }
}
```

在`com.chang.yebserver.service.AdminService`中增加如下内容：

```java
	/**
     * 更新用户密码
     * @param oldPass
     * @param pass
     * @param adminId
     * @return
     */
    RespBean updateAdminPassword(String oldPass, String pass, Integer adminId);
```

在`com.chang.yebserver.service.impl.AdminServiceImpl`中增加如下内容：

```java
	/**
     * 更新用户密码
     * @param oldPass
     * @param pass
     * @param adminId
     * @return
     */
    @Override
    public RespBean updateAdminPassword(String oldPass, String pass, Integer adminId) {
        Admin admin = adminMapper.selectById(adminId);
        //匹配旧密码是否对应，匹配成功后对密码进行加密，然后更新
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        if(encoder.matches(oldPass,admin.getPassword())){
            admin.setPassword(encoder.encode(pass));
            int result = adminMapper.updateById(admin);
            if(1==result){
                return RespBean.success("更新成功！");
            }
        }
        return RespBean.error("更新失败！");
    }
```

### 22.2、自定义反序列化

在`22.1`中使用下方内容进行更新用户信息操作会提示报错，其原因是`Admin`类中重写了`getAuthorities()`方法，因此要针对此方法进行反序列化操作

在`com.chang.yebserver.config`中创建`CustomAuthorityDeserializer`类

```java
package com.chang.yebserver.config;

import com.fasterxml.jackson.core.JacksonException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.io.IOException;
import java.util.Iterator;
import java.util.LinkedList;

/**
 * 自定义Authority解析器
 */
public class CustomAuthorityDeserializer extends JsonDeserializer {

    @Override
    public Object deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JacksonException {
        ObjectMapper mapper = (ObjectMapper) jsonParser.getCodec();
        JsonNode jsonNode = mapper.readTree(jsonParser);
        LinkedList<GrantedAuthority> grantedAuthorities = new LinkedList<>();
        Iterator<JsonNode> elements = jsonNode.elements();
        while (elements.hasNext()){
            JsonNode next = elements.next();
            //"authority"这个是传进来参数的key值
            JsonNode authority = next.get("authority");
            grantedAuthorities.add(new SimpleGrantedAuthority(authority.asText()));
        }
        return grantedAuthorities;
    }
}
```

在`com.chang.yebserver.pojo.Admin`中加入注解

```java
	@Override
    @JsonDeserialize(using = CustomAuthorityDeserializer.class)
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //权限列表
        List<SimpleGrantedAuthority> authorities =
                roles.stream()
                        .map(role -> new SimpleGrantedAuthority(role.getName()))
                        .collect(Collectors.toList());
        return authorities;
    }
```

## 23、FastDFS工具类编写

### 23.1、添加配置依赖

```xml
 		<!--FastDFS依赖-->
        <dependency>
            <groupId>org.csource</groupId>
            <artifactId>fastdfs-client-java</artifactId>
            <version>1.29-SNAPSHOT</version>
        </dependency>
```

若报错，采用下面的步骤将fastdfs的依赖安装到maven当中：

1. 先从 `github` 上拉取下来 `fastdfs-client-java` 项目

   ```bash
   git clone https://github.com/happyfish100/fastdfs-client-java.git
   ```

   ![image-20230122044211931](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230122044211931.png)

2. **进入文件夹**，然后使用`maven`打包

   ```bash
   mvn package
   ```

   ![image-20230122044253528](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230122044253528.png)

3. 可以在项目 `target` 文件夹中查看输入jar包

   ![image-20230122044319684](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230122044319684.png)

4. 然后**进入这个文件夹**，进行最后一步

   ```bash
   mvn install:install-file -DgroupId={输入groupId} -DartifactId={输入artifactId} -Dversion={输入版本号} -Dpackaging=jar -Dfile={输入jar包名称}
   ```

   版本可以通过输出文件夹的jar包查看，这里是1.29-SNAPSHOT

   ```bash
   mvn install:install-file -DgroupId=org.csource -DartifactId=fastdfs-client-java -Dversion=1.29-SNAPSHOT -Dpackaging=jar -Dfile=fastdfs-client-java-1.29-SNAPSHOT.jar
   ```

   注意：字符要区分大小写，不然会报错。

5. 执行之后，如果看见构建成功的提示，就可以在本地仓库中看见该依赖。

   ![image-20230122044652529](https://typora001-zc.oss-cn-chengdu.aliyuncs.com/typoraImg/image-20230122044652529.png)

6. 重新编译器或直接刷新一下依赖，就可以引入依赖而且不报红。

### 23.2、添加配置文件

在`fdfs_client.conf`中添加配置信息

```conf
#连接超时
connect_timeout = 2
#网络超时
network_timeout = 30
#编码格式
charset =UTF-8
#tracker端口号
http.tracker_http_port = 8080
#防盗链功能
http.anti_steal_token= no
#秘钥
http.secret_key = FastDFS1234567890
#tracker ip:端口号
tracker_server = 127.0.0.1:22122
#连接池配置
connection_pool.enabled = true
connection_pool.max_count_per_entry = 500
connection_pool.max_idle_time = 3600
connection_pool.max_wait_time_in_ms = 1000
```

### 23.3、FastDFSUtils工具类

`com.chang.yebserver.utils.FastDFSUtils`：

```java
package com.chang.yebserver.utils;

import org.csource.fastdfs.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * FastDFS工具类
 */
public class FastDFSUtils {

    private static Logger logger = LoggerFactory.getLogger(FastDFSUtils.class);

    /**
     * 初始化客户端
     * ClientGlobal.init(filePath);读取配置文件，并初始化对应的属性
     */
    static {
        try {
            String filePath = new ClassPathResource("fast_client.conf").getFile().getAbsolutePath();
            ClientGlobal.init(filePath);
        } catch (Exception e) {
            logger.error("初始化FastDFS失败",e.getMessage());
        }
    }

    /**
     * 上传文件
     * @param file
     * @return
     */
    public static String[] upload(MultipartFile file){
        //获取文件的名字
        String name = file.getOriginalFilename();
        logger.info("文件名：",name);
        //正式上传:
        //获取storageClient客户端
        StorageClient storageClient = null;
        String[] uploadResults = null;
        try {
            storageClient = getStorageClient();
            /**
             * 字节码
             * 文件后缀名
             * 文件描述信息
             */
            uploadResults = storageClient.upload_file(file.getBytes(), name.substring(name.lastIndexOf(".") + 1), null);
        } catch (Exception e) {
            logger.error("文件上传失败",e.getMessage());
        }
        if(null==uploadResults){
            logger.info("上传失败",storageClient.getErrorCode());   //打印失败的状态码
        }
        return uploadResults;
    }

    /**
     * 获取文件信息
     * @param groupName
     * @param remoteFileName 远程文件名
     * @return
     */
    public static FileInfo getFileInfo(String groupName,String remoteFileName){
        StorageClient storageClient = null;
        try {
            storageClient = getStorageClient();
            FileInfo fileInfo = storageClient.get_file_info(groupName, remoteFileName);
            return fileInfo;
        } catch (Exception e) {
            logger.error("文件信息获取失败",e.getMessage());
        }
        return null;
    }

    /**
     * 下载文件
     * @param groupName
     * @param remoteFileName
     * @return
     */
    public static InputStream downFile(String groupName,String remoteFileName){
        StorageClient storageClient = null;
        try {
            storageClient = getStorageClient();
            byte[] fileByte = storageClient.download_file(groupName, remoteFileName);
            InputStream inputStream = new ByteArrayInputStream(fileByte);
            return inputStream;
        } catch (Exception e) {
            logger.error("文件下载失败",e.getMessage());
        }
        return null;
    }

    /**
     * 删除文件
     * @param groupName
     * @param remoteFileName
     */
    public static void deleteFile(String groupName,String remoteFileName){
        StorageClient storageClient = null;
        try {
            storageClient = getStorageClient();
            storageClient.delete_file(groupName, remoteFileName);
        } catch (Exception e) {
            logger.error("文件删除失败",e.getMessage());
        }
    }


    /**
     * 生成tracker服务器
     */
    private static TrackerServer getTrackerServer() throws IOException {
        TrackerClient trackerClient = new TrackerClient();
        TrackerServer trackerServer = trackerClient.getTrackerServer();
        return trackerServer;
    }

    /**
     * 生成storage客户端
     * @return
     * @throws IOException
     */
    private static StorageClient getStorageClient() throws IOException {
        TrackerServer trackerServer = getTrackerServer();
        StorageClient storageClient = new StorageClient(trackerServer, null);
        return storageClient;
    }

    /**
     * 获取文件路径
     * @return
     */
    public static String getTrackerUrl(){
        TrackerClient trackerClient = new TrackerClient();
        TrackerServer trackerServer = null;
        StorageServer storeStorage = null;
        try {
            trackerServer = trackerClient.getTrackerServer();
            storeStorage = trackerClient.getStoreStorage(trackerServer);
        } catch (Exception e) {
            logger.error("文件路径获取失败",e.getMessage());
        }
        return "http://"+storeStorage.getInetSocketAddress().getHostString()+":8888/";
    }
}
```

### 23.4、用户更新头像功能实现

在`com.chang.yebserver.controller.AdminInfoController`中新增如下内容：

```java
	@ApiOperation(value = "更新用户头像")
    @PostMapping("/admin/userface")
    public RespBean updateAdminUserFace(MultipartFile file,Integer id,Authentication authentication){
        String[] filePath = FastDFSUtils.upload(file);
        String url = FastDFSUtils.getTrackerUrl() + filePath[0] + "/" + filePath[1];
        return adminService.updateAdminUserFace(url,id,authentication);
    }
```

在`com.chang.yebserver.service.AdminService`中新增如下内容：

```java
	/**
     * 更新用户头像
     * @param url
     * @param id
     * @param authentication
     * @return
     */
    RespBean updateAdminUserFace(String url, Integer id, Authentication authentication);
```

在`com.chang.yebserver.service.impl.AdminServiceImpl`中新增如下内容：

```java
	/**
     * 更新用户头像
     * @param url
     * @param id
     * @param authentication
     * @return
     */
    @Override
    public RespBean updateAdminUserFace(String url, Integer id, Authentication authentication) {
        Admin admin = adminMapper.selectById(id);
        admin.setUserFace(url);
        int result = adminMapper.updateById(admin);
        if(result==1){
            Admin principal = (Admin)authentication.getPrincipal();
            principal.setUserFace(url);
            SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(admin,null,authentication.getAuthorities()));
            return RespBean.success("用户头像更新成功！");
        }
        return RespBean.success("用户头像更新失败！");
    }
```

